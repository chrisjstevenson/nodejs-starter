{"version":3,"names":[],"mappings":"","sources":["out/html-page/application.js"],"sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\nvar notBlockName = /^-|^_|__|--/;\n\nfunction hasNoBlock() {\n  return function(result) {\n    var isNotBlock = Array.prototype.every.call(result.element.classList, function (className) {\n      return notBlockName.test(className);\n    });\n\n    return isNotBlock;\n  };\n}\n\nmodule.exports = exports = function (app) {\n  //TODO: This feels like we're not classifying properly. Is this necessary.\n  function remove(name) {\n    name = app.extensions.common.css.qualifiedClassName(name);\n    \n    function isRelatedClassName(className) {\n      if (className === name) return true;\n      if (className.indexOf(name + \"__\") === 0) return true;\n      if (className.indexOf(name + \"--\") === 0) return true;\n      \n      return false;\n    }\n    \n    return function (result) {\n      var elements = app.extensions.common.select(\"*\")(result.element);\n      \n      elements.forEach(function (el) {\n        var classList = [];\n        Array.prototype.forEach.call(el.classList, function (c) {\n          if (!isRelatedClassName(c)) {\n            classList.push(c);\n          }\n        });\n        el.className = classList.join(\" \");\n      });\n      \n      return result;\n    };\n  }\n  \n  function block(name) {\n    return function (result) {\n      name = app.extensions.common.css.qualifiedClassName(name);\n      \n      if (hasNoBlock()(result)) {\n        result.element.classList.add(name);\n      }\n      \n      return result;\n    };\n  }\n  \n  function addBemClass(name) {\n    name = app.extensions.common.css.qualifiedClassName(name);\n    return function (result) {\n      result.element.classList.add(name);\n      return result;\n    };\n  }\n\n  return {\n    block: block,\n    element: addBemClass,\n    modifier: addBemClass,\n    mixin: addBemClass,\n    state: addBemClass,\n    remove: remove,\n    hasNoBlock: hasNoBlock\n  };\n};\n\n},{}],2:[function(require,module,exports){\nmodule.exports = exports = function (app) {\n  function applyLinkBehavior(result) {\n    var linkElements = app.extensions.common.select(\"a,[role*=link]\")(result.element);\n    linkElements.forEach(applyLinkBehaviorToLinkElement);\n    return result;\n  }\n  \n  function applyLinkBehaviorToLinkElement(linkElement) {\n    function followLink(delay) {\n      var options = {};\n      options.type = linkElement.type || linkElement.dataset.type;\n      options.origin = linkElement;\n      \n      if (delay) {\n        options.delay = delay;\n      }\n      \n      app.follow(linkElement.href || linkElement.dataset.href, options);\n    }\n    \n    function isControlledCommand(e) {\n      if (linkElement.tagName !== \"A\") return false;\n      \n      return (e.ctrlKey || e.shiftKey || e.metaKey || e.altKey);\n    }\n\n    linkElement.addEventListener(\"click\", function(e) {\n      if (isControlledCommand(e)) return;\n      \n      e.stopPropagation();\n      e.preventDefault();\n      followLink();\n    });\n\n    linkElement.addEventListener(\"keydown\", function(e) {\n      if (isControlledCommand(e)) return;\n      \n      if (e.keyCode !== 13) return;\n      e.stopPropagation();\n      e.preventDefault();\n      followLink();\n    });\n    \n    if (linkElement.dataset.follow) {\n      followLink(linkElement.dataset.follow);\n    }\n  }\n  \n  return applyLinkBehavior;\n};\n\n},{}],3:[function(require,module,exports){\nmodule.exports = exports = function (app) {\n  \n  function applyOptionsKeyboardBehavior(optionSelector, selectedOptionSelector) {\n    return function (result) {\n      var optionsElement = result.element;\n      \n      if (optionsElement.removeOptionsKeyboardBehavior) return result;\n      \n      function onOptionKeyDown(evt) {\n        var activeOptionElement = getActiveOptionElement(optionsElement, optionSelector);\n        var nextOptionElement;\n        var select = app.extensions.common.select;\n        \n        if (isDownKey(evt) || isRightKey(evt)) {\n          nextOptionElement = getRelatedOptionElement(optionsElement, activeOptionElement, 1, optionSelector);\n          shiftOptionFocus(activeOptionElement, nextOptionElement);\n          evt.preventDefault();\n        } else if (isUpKey(evt) || isLeftKey(evt)) {\n          nextOptionElement = getRelatedOptionElement(optionsElement, activeOptionElement, -1, optionSelector);\n          shiftOptionFocus(activeOptionElement, nextOptionElement);\n          evt.preventDefault();\n        } else if (isSpaceKey(evt)) {\n          activeOptionElement = activeOptionElement ||\n            select(selectedOptionSelector).first() ||\n            select(optionSelector)(optionsElement).first();\n\n          if (activeOptionElement) activeOptionElement.click();\n          evt.preventDefault();\n        }\n      }\n      \n      optionsElement.tabIndex = \"0\";\n      optionsElement.addEventListener(\"keydown\", onOptionKeyDown);\n      \n      optionsElement.removeOptionsKeyboardBehavior = function () {\n        delete optionsElement.removeOptionsKeyboardBehavior;\n        \n        optionsElement.removeAttribute(\"tabindex\");\n        \n        function removeTabIndex(optionElement) {\n          optionElement.removeAttribute(\"tabindex\");\n        }\n        \n        var optionsWithTabIndex = app.extensions.common.select(optionSelector + \"[tabindex]\")(optionsElement);\n        optionsWithTabIndex.forEach(removeTabIndex);\n        \n        optionsElement.removeEventListener(\"keydown\", onOptionKeyDown);\n      };\n      \n      return result;\n    };\n  }\n\n  function shiftOptionFocus(fromOptionElement, toOptionElement) {\n    if (fromOptionElement === toOptionElement) return toOptionElement.focus();\n\n    if (fromOptionElement) fromOptionElement.tabIndex = \"-1\";\n\n    toOptionElement.tabIndex = \"0\";\n    toOptionElement.focus();\n  }\n\n  function getRelatedOptionElement(optionsSourceElement, activeOptionElement, position, optionSelector) {\n    var select = app.extensions.common.select;\n    var optionElements = select(optionSelector)(optionsSourceElement);\n\n    if (!activeOptionElement) return optionElements.first();\n    \n    optionElements = optionElements.array();\n\n    for (var i = 0; i < optionElements.length; i++) {\n      var currentOptionElement = optionElements[i];\n      if (currentOptionElement === activeOptionElement) return optionElements[i + position] || activeOptionElement;\n    }\n\n    return null;\n  }\n\n  function getActiveOptionElement(optionsSourceElement, optionSelector) {\n    var select = app.extensions.common.select;\n    return select(optionSelector + \"[tabindex='0']\")(optionsSourceElement).first();\n  }\n\n  var KEY_SPACE = 32;\n  var KEY_LEFT = 37;\n  var KEY_UP = 38;\n  var KEY_RIGHT = 39;\n  var KEY_DOWN = 40;\n\n  function isSpaceKey(evt) {\n    return evt.keyCode === KEY_SPACE;\n  }\n\n  function isLeftKey(evt) {\n    return evt.keyCode === KEY_LEFT;\n  }\n\n  function isUpKey(evt) {\n    return evt.keyCode === KEY_UP;\n  }\n\n  function isRightKey(evt) {\n    return evt.keyCode === KEY_RIGHT;\n  }\n\n  function isDownKey(evt) {\n    return evt.keyCode === KEY_DOWN;\n  }\n\n  return applyOptionsKeyboardBehavior;\n};\n\n},{}],4:[function(require,module,exports){\n(function (Buffer){\nvar Q = require(\"q\");\n\nmodule.exports = exports = function (app) {\n  function applySubmitBehavior(result) {\n    var select = app.extensions.common.select;\n    var buttonElements = select(\"button,[role*=button]\")(result.element);\n    buttonElements.forEach(applySubmitBehaviorToSubmitElement);\n    return result;\n  }\n\n  function applySubmitBehaviorToSubmitElement(submitElement) {\n    function sendForm() {\n      function addFormData(options) {\n        options.formdata = [];\n\n        var form = app.extensions.common.findNearestAncestor(submitElement, \"[data-lynx-hints~=form]\");\n        if (!form) return options;\n\n        function addFileInputToFormData(elem) {\n          var deferred = Q.defer();\n\n          var fileReader = new FileReader();\n          var file = inputElement.files[0];\n\n          if (!file) return;\n\n          fileReader.onloadend = function () {\n            if (fileReader.error) {\n              deferred.reject(fileReader.error);\n            }\n            else {\n              deferred.resolve({\n                name: elem.name,\n                value: {\n                  type: file.type,\n                  data: new Buffer(fileReader.result, \"binary\")\n                }\n              });\n            }\n          };\n\n          fileReader.readAsBinaryString(file);\n\n          return deferred.promise;\n        }\n\n        function createPromiseForFormData(formElement) {\n          if (formElement.type === \"file\") return addFileInputToFormData(formElement);\n\n          return Q(formElement).then(function (elem) {\n            return {\n              name: elem.name,\n              value: {\n                type: \"\",\n                data: new Buffer(elem.value)\n              }\n            };\n          });\n        }\n\n        var select = app.extensions.common.select;\n        var inputSelector = \"input:not([disabled]),textarea:not([disabled]),select:not([disabled])\";\n        var inputs = select(inputSelector)(form);\n        var promises = inputs.map(createPromiseForFormData).array();\n\n        function updateOptionsWithFormData(formdata) {\n          options.formdata = formdata;\n          return options;\n        }\n\n        return Q.all(promises).then(updateOptionsWithFormData).fail(app.error);\n      }\n\n      function sendFormData(options) {\n        return app.send(submitElement.dataset.action, options);\n      }\n\n      var options = {};\n      options.method = submitElement.dataset.method || \"\";\n      options.enctype = submitElement.dataset.enctype || \"\";\n      options.origin = submitElement;\n\n      Q(options)\n        .then(addFormData)\n        .then(sendFormData);\n    }\n\n    submitElement.addEventListener(\"click\", function(e) {\n      e.stopPropagation();\n      e.preventDefault();\n      sendForm();\n    });\n\n    submitElement.addEventListener(\"keydown\", function(e) {\n      if (e.keyCode !== 13) return;\n      e.stopPropagation();\n      e.preventDefault();\n      sendForm();\n    });\n  }\n\n  return applySubmitBehavior;\n};\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"buffer\":80,\"q\":134}],5:[function(require,module,exports){\nvar Q = require(\"q\");\n\nmodule.exports = exports = function (app) {\n  function apply(selector, elementFunction) {\n    return function (result) {\n      var elements = app.extensions.common.select(selector)(result.element);\n      var promises = [];\n\n      elements.forEach(function (element) {\n        promises.push(elementFunction({element: element}));\n      });\n\n      return Q.all(promises).then( function () { return result; } );\n    };\n  }\n  \n  return apply;\n};\n\n},{\"q\":134}],6:[function(require,module,exports){\nmodule.exports = exports = function (app) {\n  function attachElementByScope(result) {\n    var element = result.element;\n    var origin = result.options.origin;\n    \n    // if the element has already been attached\n    if (element.parentElement) return result;\n    \n    // if the element doesn't have a realm\n    var realm = element.dataset.contentRealm;\n    if (!realm) return result;\n    \n    // if no matching scope is found\n    var matchingElement = app.extensions.common.findNearestElement(origin, function (currentElement) {\n      var scope = currentElement.dataset.contentScope;\n      if (!scope) return false;\n      return app.extensions.common.scopeIncludesRealm(scope, realm);\n    });\n    \n    if (!matchingElement) return result;\n    \n    app.extensions.common.replaceElementAndPreserveAttributes(matchingElement, element);\n    return result;\n  }\n  \n  return attachElementByScope;\n};\n\n},{}],7:[function(require,module,exports){\nmodule.exports = exports = function (app) {\n  return function composite() {\n    var result = app.finishing.composite();\n    \n    Array.prototype.forEach.call(arguments, function (finishingFn) {\n      result.add(finishingFn);\n    });\n    \n    return result;\n  };\n};\n\n},{}],8:[function(require,module,exports){\nmodule.exports = exports = function (app) {\n  function whenReady(fn) {\n    return function (result) {\n      function tryToFinish() {\n        var appElement = app.getApplicationElement();\n        if (appElement.dataset.uaState === \"ready\") {\n          fn(result);\n        } else {\n          setTimeout(tryToFinish, 10);\n        }\n      }\n      \n      tryToFinish();\n      \n      return result;\n    };\n  }\n  \n  return whenReady;\n};\n\n},{}],9:[function(require,module,exports){\nmodule.exports = exports = function (app) {\n  var extension = {};\n  \n  extension.afterRendering = {};\n  extension.afterRendering.setContentContext = require(\"./rendering/after/set-content-context\")(app);\n  \n  extension.finishing = {};\n  extension.finishing.applyLinkBehavior = require(\"./finishing/apply-link-behavior\")(app);\n  extension.finishing.applySubmitBehavior = require(\"./finishing/apply-submit-behavior\")(app);\n  extension.finishing.attachElementByScope = require(\"./finishing/attach-element-by-scope\")(app);\n  extension.finishing.applyOptionsKeyboardBehavior = require(\"./finishing/apply-options-keyboard-behavior\")(app);\n  extension.finishing.apply = require(\"./finishing/apply\")(app);\n  extension.finishing.whenReady = require(\"./finishing/when-ready\")(app);\n  extension.finishing.composite = require(\"./finishing/composite\")(app);\n  \n  extension.setInputElementValue = require(\"./util/set-input-element-value\")(app);\n  extension.findNearestElement = require(\"./util/find-nearest-element\")(app);\n  extension.findNearestAncestor = require(\"./util/find-nearest-ancestor\")(app);\n  extension.replaceElementAndPreserveAttributes = require(\"./util/replace-element-and-preserve-attributes\")(app);\n  extension.scopeIncludesRealm = require(\"./util/scope-includes-realm\")(app);\n  extension.realmsAreEqual = require(\"./util/realms-are-equal\")(app);\n  extension.elementRealmIsInScope = require(\"./util/element-realm-is-in-scope\")(app);\n  extension.matchesSelector = require(\"./util/matches-selector\")(app);\n  extension.findElementsByRealm = require(\"./util/find-elements-by-realm\")(app);\n  extension.elementIsAttached = require(\"./util/element-is-attached\")(app);\n  extension.Iterable = require(\"./util/iterable\");\n  extension.select = require(\"./util/select\")(app);\n  extension.css = require(\"./util/css\")(app);\n  \n  return extension;\n};\n\n},{\"./finishing/apply\":5,\"./finishing/apply-link-behavior\":2,\"./finishing/apply-options-keyboard-behavior\":3,\"./finishing/apply-submit-behavior\":4,\"./finishing/attach-element-by-scope\":6,\"./finishing/composite\":7,\"./finishing/when-ready\":8,\"./rendering/after/set-content-context\":10,\"./util/css\":11,\"./util/element-is-attached\":12,\"./util/element-realm-is-in-scope\":13,\"./util/find-elements-by-realm\":14,\"./util/find-nearest-ancestor\":15,\"./util/find-nearest-element\":16,\"./util/iterable\":17,\"./util/matches-selector\":18,\"./util/realms-are-equal\":19,\"./util/replace-element-and-preserve-attributes\":20,\"./util/scope-includes-realm\":21,\"./util/select\":22,\"./util/set-input-element-value\":23}],10:[function(require,module,exports){\nmodule.exports = exports = function (app) {\n  function setContentContext(result) {\n    var contentLocation = result.content.location || result.content.src;\n    if (contentLocation) result.element.dataset.contentLocation = contentLocation;\n    result.element.dataset.contentType = result.content.type;\n    return result;\n  }\n  \n  return setContentContext;\n};\n\n},{}],11:[function(require,module,exports){\nvar cssParser = require(\"css-selector-tokenizer\");\n\nmodule.exports = exports = function (app) {\n  var extension = {};\n  var isPrefixedClassName = /^-|^_/;\n\n  extension.namespace = \"\";\n\n  extension.qualifiedClassName = function qualifiedClassName(className) {\n    if (!extension.namespace) return className;\n    if (!className) return className;\n    if (className.indexOf(extension.namespace) !== -1) return className;\n    \n    if (isPrefixedClassName.test(className)) {\n      return className[0] + extension.namespace + className.substr(1);\n    }\n    \n    return extension.namespace + className;\n  };\n\n  extension.qualifiedSelector = function qualifiedSelector(selector) {\n    if (!extension.namespace) return selector;\n    if (!selector) return selector;\n    \n    function qualifyClassNames(sel) {\n      if (\"nodes\" in sel) {\n        return sel.nodes.forEach(qualifyClassNames);\n      }\n      \n      if (sel.type !== \"class\") return;\n      sel.name = extension.qualifiedClassName(sel.name);\n    }\n    \n    var parsed = cssParser.parse(selector);\n    qualifyClassNames(parsed);\n    \n    return cssParser.stringify(parsed);\n  };\n  \n  return extension;\n};\n\n},{\"css-selector-tokenizer\":127}],12:[function(require,module,exports){\nmodule.exports = exports = function (app) {\n  function elementIsAttached(element) {\n    while (element !== document && element.parentNode) {\n      element = element.parentNode;\n    }\n    \n    return element === document;\n  }\n  \n  return elementIsAttached;\n};\n\n},{}],13:[function(require,module,exports){\nmodule.exports = exports = function (app) {\n  return function (element, scope) {\n    return app.extensions.common.scopeIncludesRealm(scope, element.dataset.contentRealm);\n  };\n};\n\n},{}],14:[function(require,module,exports){\nmodule.exports = exports = function (app) {\n  function findElementsByRealm(element, realm) {\n    var selector = \"[data-content-realm='\" + realm + \"']\";\n    return app.extensions.common.select(selector)(element);\n  }\n  \n  return findElementsByRealm;\n};\n\n},{}],15:[function(require,module,exports){\nmodule.exports = exports = function (app) {\n  function findNearestAncestor(origin, selectorOrPredicate) {\n    if (!origin) return null;\n    if (!selectorOrPredicate) return null;\n    \n    var predicate = selectorOrPredicate;\n    if (typeof selectorOrPredicate !== \"function\") {\n      predicate = function (element) {\n        return app.extensions.common.matchesSelector(element, selectorOrPredicate);\n      };\n    }\n    \n    var current = origin.parentElement;\n    var applicationElement = app.getApplicationElement();\n    \n    while (current !== applicationElement) {\n      if (predicate(current)) return current;\n      current = current.parentElement;   \n    }\n    \n    return null;\n  }\n  \n  return findNearestAncestor;\n};\n\n},{}],16:[function(require,module,exports){\nmodule.exports = exports = function (app) {\n  function findNearestDescendant(element, predicate) {\n    var descendants = element.getElementsByTagName(\"*\");\n    return Array.prototype.find.call(descendants, predicate);\n  }\n  \n  function findNearestElement(origin, selectorOrPredicate) {\n    if (!origin) return null;\n    if (!selectorOrPredicate) return null;\n    if (origin === app.getApplicationElement()) return null;\n    \n    var predicate = selectorOrPredicate;\n    if (typeof selectorOrPredicate !== \"function\") {\n      predicate = function (element) {\n        return app.extensions.common.matchesSelector(element, selectorOrPredicate);\n      };\n    }\n    \n    if (predicate(origin)) return origin;\n    \n    var nearestDescendant = findNearestDescendant(origin, predicate);\n    if (nearestDescendant) return nearestDescendant;\n    \n    return findNearestElement(origin.parentElement, predicate);\n  }\n  \n  return findNearestElement;\n};\n\n},{}],17:[function(require,module,exports){\nvar util = require(\"util\");\n\nfunction createNodeListIterator(nodeList) {\n  var index = 0;\n  return {\n    next: function () {\n      var child = nodeList.item(index++);\n      if (child) {\n        return {\n          done: false,\n          value: child\n        };\n      } else {\n        return {\n          done: true\n        };\n      }\n    }\n  };\n}\n\nfunction createFilterIterator(sourceIterable, predicate, thisArg) {\n  var index = 0;\n  var iterator = sourceIterable[\"@@iterator\"]();\n\n  function nextFn() {\n    var next = iterator.next();\n    while (next.done === false) {\n      if (predicate.call(thisArg, next.value, index++, sourceIterable)) {\n        return {\n          done: false,\n          value: next.value\n        };\n      }\n\n      next = iterator.next();\n    }\n\n    return {\n      done: true\n    };\n  }\n\n  return {\n    next: nextFn\n  };\n}\n\nfunction createMapIterator(sourceIterable, mapper, thisArg) {\n  var index = 0;\n  var iterator = sourceIterable[\"@@iterator\"]();\n\n  function nextFn() {\n    var next = iterator.next();\n    \n    if (next.done === false) {\n      return {\n        done: false,\n        value: mapper.call(thisArg, next.value, index++, sourceIterable)\n      };\n    }\n\n    return {\n      done: true\n    };\n  }\n\n  return {\n    next: nextFn\n  };\n}\n\nfunction createEmptyIterator() {\n  return {\n    next: function () {\n      return {done: true};\n    }\n  };\n}\n\nfunction createArrayIterator(array) {\n  var index = 0;\n\n  return {\n    next: function () {\n      var child = array[index++];\n      if (child) {\n        return {\n          done: false,\n          value: child\n        };\n      } else {\n        return {\n          done: true\n        };\n      }\n    }\n  };\n}\n\nfunction Iterable(source) {\n  var iteratorFn;\n  \n  if (util.isArray(source)) {\n    iteratorFn = function () {\n      return createArrayIterator(source);\n    };\n  } else if (source && \"item\" in source && typeof(source.item === \"function\")) {\n    iteratorFn = function () {\n      return createNodeListIterator(source);\n    };\n  } else if (typeof source === \"function\") {\n    iteratorFn = source;\n  } else {\n    iteratorFn = createEmptyIterator;\n  }\n  \n  this[\"@@iterator\"] = iteratorFn;\n}\n\nIterable.prototype.filter = function (predicate) {\n\n  var source = this;\n\n  var thisArg = arguments[1];\n\n  return new Iterable(function () {\n    return createFilterIterator(source, predicate, thisArg);\n  });\n};\n\nIterable.prototype.forEach = function (callback) {\n  var iterator = this[\"@@iterator\"]();\n\n  var index = 0;\n  var next = iterator.next();\n\n  var thisArg = arguments[1];\n\n  while (next.done === false) {\n    callback.call(thisArg, next.value, index++, this);\n    next = iterator.next();\n  }\n};\n\nIterable.prototype.find = function (callback) {\n  var source = this;\n\n  var thisArg = arguments[1];\n  var filter = createFilterIterator(source, callback, thisArg);\n  return filter.next().value;\n};\n\nIterable.prototype.first = function () {\n  return this[\"@@iterator\"]().next().value;\n};\n\nIterable.prototype.last = function () {\n  var a = this.array();\n  if (a.length === 0) return;\n  \n  return a[a.length - 1];\n};\n\nIterable.prototype.count = function () {\n  var count = 0;\n  this.forEach(function () {\n    count++;\n  });\n\n  return count;\n};\n\nIterable.prototype.some = function (predicate) {\n  var source = this;\n  if(!predicate) return !source[\"@@iterator\"]().next().done;\n  var thisArg = arguments[1];\n  var filter = createFilterIterator(source, predicate, thisArg);\n\n  return filter.next().done === false;\n};\n\nIterable.prototype.every = function (predicate) {\n  var iterator = this[\"@@iterator\"]();\n\n  var next = iterator.next();\n  var index = 0;\n  var thisArg = arguments[1];\n  while (next.done === false) {\n    if (!predicate.call(thisArg, next.value, index++, this)) {\n      return false;\n    }\n\n    next = iterator.next();\n  }\n\n  return true;\n};\n\nIterable.prototype.concat = function (iterable) {\n  var firstIterator = this[\"@@iterator\"];\n\n  var concatIteratorFn = function () {\n    var first = firstIterator();\n    var second = iterable[\"@@iterator\"]();\n\n    return {\n      next: function () {\n        var next = first.next();\n        if (!next.done) return next;\n        return second.next();\n      }\n    };\n  };\n\n  return new Iterable(concatIteratorFn);\n};\n\nIterable.prototype.map = function (mapper) {\n  var source = this;\n  var thisArg = arguments[1];\n\n  return new Iterable(function () {\n    return createMapIterator(source, mapper, thisArg);\n  });\n};\n\nIterable.prototype.array = function () {\n  var result = [];\n\n  this.forEach(function (item) {\n    result.push(item);\n  });\n\n  return result;\n};\n\nmodule.exports = exports = Iterable;\n\n},{\"util\":113}],18:[function(require,module,exports){\nmodule.exports = exports = function (app) {\n  function matchesSelector(element, selector) {\n    selector = app.extensions.common.css.qualifiedSelector(selector);\n    \n    var matches = element.matches ||\n      element.msMatchesSelector ||\n      element.webkitMatchesSelector ||\n      element.mozMatchesSelector ||\n      element.oMatchesSelector;\n      \n    return matches.call(element, selector);\n  }\n  \n  return matchesSelector;\n};\n\n},{}],19:[function(require,module,exports){\nvar urijs = require(\"urijs\");\n\nmodule.exports = exports = function (app) {\n  return function realmsAreEqual(realmA, realmB) {\n    if (!realmA || !realmB) return false;\n\n    var normalizedRealmA = urijs(realmA).normalize().toString();\n    var normalizedRealmB = urijs(realmB).normalize().toString();\n\n    return normalizedRealmA === normalizedRealmB;\n  };\n};\n\n},{\"urijs\":141}],20:[function(require,module,exports){\nmodule.exports = exports = function (app) {\n  var preservedAttributes = [\"contentScope\"];\n  \n  function isPreservedAttribute(name){\n      return preservedAttributes.some(function (value) {\n        return name === value;\n      });\n  }\n  \n  function copyAttributes(sourceElement, destinationElement) {\n    for(var p in sourceElement.dataset){\n      if(sourceElement.dataset.hasOwnProperty(p) && isPreservedAttribute(p)){\n        destinationElement.dataset[p] = sourceElement.dataset[p];\n      }\n    }\n  }\n  \n  function replaceElementAndPreserveAttributes(element, newElement) {\n    copyAttributes(element, newElement);\n    var parent = element.parentElement;\n    parent.replaceChild(newElement, element);\n  }\n  \n  replaceElementAndPreserveAttributes.addPreservedAttribute = function (name) {\n    preservedAttributes.push(name);\n  };\n  \n  return replaceElementAndPreserveAttributes;\n};\n\n},{}],21:[function(require,module,exports){\nvar urijs = require(\"urijs\");\n\nmodule.exports = exports = function (app) {\n  return function scopeIncludesRealm(scope, realm) {\n    if (!scope || !realm) return false;\n\n    var normalizedRealm = urijs(realm).normalize().toString();\n    var normalizedScope = urijs(scope).normalize().toString();\n\n    return normalizedRealm.indexOf(normalizedScope) === 0;\n  };\n};\n\n},{\"urijs\":141}],22:[function(require,module,exports){\nvar util = require(\"util\");\n\nmodule.exports = exports = function (app) {\n  \n  function createSelectorIterator(element, selector) {\n    var resultsIterator;\n\n    function next() {\n      if (!resultsIterator) {\n        resultsIterator = new app.extensions.common.Iterable(element.querySelectorAll(selector))[\"@@iterator\"]();\n        if (app.extensions.common.matchesSelector(element, selector)) {\n          return {\n            done: false,\n            value: element\n          };\n        }\n      }\n      return resultsIterator.next();\n    }\n\n    return {\n      next: next\n    };\n  }\n\n  function select(selector) {\n    if (util.isFunction(selector)) return selector;\n\n    return function (element) {\n      return new app.extensions.common.Iterable(function () {\n        selector = app.extensions.common.css.qualifiedSelector(selector);\n        return createSelectorIterator(element, selector);\n      });\n    };\n  }\n\n  select.concat = function concat() {\n    var args = arguments;\n    return function(element){\n      var iterable = new app.extensions.common.Iterable();\n\n      Array.prototype.forEach.call(args, function(arg){\n        iterable = iterable.concat(select(arg)(element));\n      });\n\n      return iterable;\n    };\n  };\n  \n  select.children = function children(selector) {\n    return function (element) {\n      var elements = select(selector)(element);\n      if (!elements.some()) return new app.extensions.common.Iterable();\n      \n      return elements.filter(function (match) {\n        return match.parentElement === element;\n      });\n    };\n  };\n\n  select.siblings = function siblings(selector){\n    return function(element){\n      var elements = select(selector)(element.parentElement);\n      if (!elements.some()) return new app.extensions.common.Iterable();\n\n      return elements.filter(function (match) {\n        return match !== element && match.parentElement === element.parentElement;\n      });\n    };\n  };\n  \n  select.parent = function parent(selector) {\n    return function (element) {\n      var elements = select(selector)(element);\n      \n      var parents = [];\n      elements.forEach(function (el) {\n        if (parents.indexOf(el.parentElement) === -1) {\n          parents.push(el.parentElement);\n        }\n      });\n      \n      return new app.extensions.common.Iterable(parents);\n    };\n  };\n\n  select.wrap = function wrap(selector) {\n    return function (element) {\n      var elements = select.children(selector)(element);\n      if (!elements.some()) return new app.extensions.common.Iterable();\n\n      var wrapper = document.createElement(\"div\");\n      elements.forEach(function (matched, index) {\n        if (index === 0) matched.parentElement.replaceChild(wrapper, matched);\n        wrapper.appendChild(matched);\n      });\n\n      return new app.extensions.common.Iterable([wrapper]);\n    };\n  };\n\n  select.wrapEachMatching = function wrapEachMatching(selector) {\n    return function (element) {\n      var elements = select(selector)(element);\n      if (!elements.some()) return new app.extensions.common.Iterable();\n      \n      return elements.map(function (el) {\n        var wrapper = document.createElement(\"div\");\n        el.parentElement.replaceChild(wrapper, el);\n        wrapper.appendChild(el);\n        \n        return wrapper;\n      });\n    };\n  };\n\n  select.fromApp = function fromApp(selector) {\n    return function () {\n      return select(selector)(app.getApplicationElement());\n    };\n  };\n\n  select.first = function first(selector) {\n    return function (element) {\n      var first = select(selector)(element).first();\n      if (!first) return new app.extensions.common.Iterable();\n      return new app.extensions.common.Iterable([first]);\n    };\n  };\n  \n  select.applicationElement = function selectApplicationElement(element) {\n    return new app.extensions.common.Iterable([app.getApplicationElement()]);\n  };\n  \n  return select;\n};\n\n},{\"util\":113}],23:[function(require,module,exports){\nmodule.exports = exports = function (app) {\n  function setInputElementValue(inputElement, newValue) {\n    if (inputElement.value === newValue) return;\n    \n    inputElement.value = newValue;\n    \n    var inputEvent = document.createEvent(\"Event\");\n    inputEvent.initEvent(\"input\", true, false);\n    inputElement.dispatchEvent(inputEvent);\n    \n    var changeEvent = document.createEvent(\"Event\");\n    changeEvent.initEvent(\"change\", true, false);\n    inputElement.dispatchEvent(changeEvent);\n  }\n  \n  return setInputElementValue;\n};\n\n},{}],24:[function(require,module,exports){\n(function (Buffer){\nvar URI = require(\"urijs\");\nvar Q = require(\"q\");\n\nfunction dataTransfer(url, options) {\n  options = options || {};\n  \n  return Q().then(function () {\n    var parsed = URI(url);\n    var delim = parsed.path().indexOf(\",\");\n    var type,encoding;\n    \n    if (delim === 0) {\n      type = \"text/plain;charset=US-ASCII\";\n      encoding = \"ascii\";\n    }\n    else {\n      type = parsed.path().substr(0, delim);\n      if (type.indexOf(\";base64\") !== -1) {\n        encoding = \"base64\";\n        type = type.replace(\";base64\", \"\");\n      }\n    }\n    \n    var data = new Buffer(parsed.path().substr(delim + 1), encoding || \"utf8\");\n    \n    return {\n      location: url,\n      options: options,\n      data: data,\n      type: type\n    };\n  });\n}\n\nmodule.exports = exports = function (/*app*/) {\n  var extension = {\n    transferring: dataTransfer  \n  };\n  \n  return extension;\n};\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"buffer\":80,\"q\":134,\"urijs\":141}],25:[function(require,module,exports){\nfunction createDataUri(content) {\n  return \"data:\" + content.type.fullName + \";base64,\" + content.data.toString(\"base64\");\n}\n\nfunction renderGenericContent(content) {\n  var rootElement = document.createElement(\"object\");\n  \n  var src;\n  if (content.src) src = content.src;\n  else src = createDataUri(content);\n\n  rootElement.data = src;\n\n  var altText = content.alt || \"Unable to display content from: \" + content.src;\n  var altElement = document.createElement(\"a\");\n  altElement.setAttribute(\"download\", \"content\");\n  altElement.href = content.src;\n  altElement.textContent = altText;\n\n  rootElement.appendChild(altElement);\n\n  return rootElement;\n}\n\nmodule.exports = exports = function (/*app*/) {\n  var extension = {\n    rendering: renderGenericContent\n  };\n  \n  return extension;\n};\n\n},{}],26:[function(require,module,exports){\nfunction createDataUri(content) {\n  return \"data:\" + content.type + \";base64,\" + content.data.toString(\"base64\");\n}\n\nfunction renderHtml(content) {\n  var rootElement = document.createElement(\"iframe\");\n  \n  if (content.src) rootElement.src = content.src;\n  else rootElement.src = createDataUri(content);\n\n  return rootElement;\n}\n\nmodule.exports = exports = function (/*app*/) {\n  var extension = {\n    rendering: renderHtml\n  };\n  \n  return extension;\n};\n\n},{}],27:[function(require,module,exports){\n(function (Buffer){\nvar http = require(\"http\");\nvar https = require(\"https\");\nvar URI = require(\"urijs\");\nvar urlParser = require(\"url\");\nvar Q = require(\"q\");\n\nvar useBodyForMethod = {\n  GET: false,\n  DELETE: false,\n  PUT: true,\n  POST: true\n};\n\nvar defaultRetrievalMethod = \"GET\";\n\nfunction httpTransfer(url, options) {\n  options = options || {};\n  \n  var method = options.method || defaultRetrievalMethod;\n  var body = options.body;\n  var deferred = Q.defer();\n\n  if (body && useBodyForMethod[method] === false) {\n    var queryComponent = body.data.toString();\n    url = URI(url).query(queryComponent).toString();\n  }\n\n  var requestOptions = urlParser.parse(url);\n  requestOptions.method = method;\n  requestOptions.headers = {};\n  requestOptions.headers.accept = \"*/*\";\n  \n  if (httpTransfer.headers) {\n    for (var globalHeader in httpTransfer.headers) {\n      if (!httpTransfer.headers.hasOwnProperty(globalHeader)) continue;\n      requestOptions.headers[globalHeader] = httpTransfer.headers[globalHeader];\n    }\n  }\n  \n  if (options.headers) {\n    for (var requestHeader in options.headers) {\n      if (!options.headers.hasOwnProperty(requestHeader)) continue;\n      requestOptions.headers[requestHeader] = options.headers[requestHeader];\n    }\n  }\n  \n  if (body && useBodyForMethod[method]) requestOptions.headers[\"content-type\"] = body.type;\n\n  requestOptions.withCredentials = options.withCredentials || httpTransfer.withCredentials || false;\n  requestOptions.responseType = \"arraybuffer\";\n\n  var protocolPackage = http;\n  if (requestOptions.protocol === \"https:\") protocolPackage = https;\n  \n  function responseHandler(response) {\n    var data = [];\n\n    response.on(\"data\", function (chunk) {\n      data.push(new Buffer(chunk));\n    });\n\n    response.on(\"error\", function (err) {\n      deferred.reject(err);\n    });\n\n    response.on(\"end\", function () {\n      var result = {\n        location: url,\n        data: null,\n        type: response.headers[\"content-type\"]\n      };\n      \n      if (data.length > 0) {\n        result.data = Buffer.concat(data);\n      }\n\n      deferred.resolve(result);\n    });\n  }\n\n  var request = protocolPackage.request(requestOptions, responseHandler);\n  \n  request.on(\"error\", function (err) {\n    deferred.reject(err);\n  });\n\n  if (body && useBodyForMethod[method]) request.write(body.data);\n\n  request.end();\n\n  return deferred.promise;\n}\n\nmodule.exports = exports = function (/*app*/) {\n  var extension = {\n    transferring: httpTransfer  \n  };\n  \n  return extension;\n};\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"buffer\":80,\"http\":85,\"https\":89,\"q\":134,\"urijs\":141,\"url\":111}],28:[function(require,module,exports){\nfunction createDataUri(content) {\n  return \"data:\" + content.type + \";base64,\" + content.data.toString(\"base64\");\n}\n\nfunction renderImageContent(content) {\n  var img = document.createElement(\"img\");\n  \n  if (content.src) img.src = content.src;\n  else img.src = createDataUri(content);\n\n  return img;\n}\n\nmodule.exports = exports = function (/*app*/) {\n  var extension = {\n    rendering: renderImageContent\n  };\n  \n  return extension;\n};\n\n},{}],29:[function(require,module,exports){\n(function (Buffer){\nvar util = require(\"util\");\nvar Q = require(\"q\");\nvar contentType = require(\"content-type\");\n\nmodule.exports = exports = function (app) {\n  var Iterable = app.extensions.common.Iterable;\n  var iterators = require(\"./iterators\")(app);\n  \n  function parseSpecContent(content) {\n    var spec = JSON.parse(content.data.toString());\n    spec.url = content.location;\n    return spec;\n  }\n\n  function resolveSpec(document) {\n    return function (spec) {\n      if (typeof spec === \"string\") {\n        var url = document.resolveURI(spec);\n        return app.transferring(url).then(parseSpecContent);\n      }\n\n      return spec;\n    };\n  }\n\n  function resolveSpecFromValue(node) {\n    var value = node.value;\n\n    if (!value || !value.spec) return node;\n\n    var specFromValue = value.spec;\n    \n    if (\"value\" in value) {\n      // (value,spec) tuple\n      node.value = value.value;\n    }\n    else {\n      delete value.spec;\n    }\n    \n    function finish(spec) {\n      if (node.spec) spec.name = node.spec.name;\n      node.spec = spec;\n      return node;\n    }\n    \n    return Q(specFromValue)\n      .then(resolveSpec(node.document))\n      .then(finish);\n  }\n\n  function buildVisibility(node) {\n    node.spec.visibility = node.spec.visibility || \"visible\";\n    return node;\n  }\n  \n  function expandHints(spec) {\n    spec.hints = spec.hints.map(function (hint) {\n      if (util.isObject(hint)) return hint;\n      return { name: hint };\n    });\n  }\n\n  function buildHints(node) {\n    var spec = node.spec;\n    expandHints(spec);\n    return node;\n  }\n\n  function isValidInputValue(inputValue) {\n    if (inputValue === true ||\n      (!util.isArray(inputValue) && util.isObject(inputValue)) ||\n      typeof inputValue === \"string\") {\n      return true;\n    }\n\n    return false;\n  }\n\n  function buildInput(node) {\n    var input = node.spec.input;\n\n    if (!input || !isValidInputValue(input)) {\n      node.spec.input = null;\n      return node;\n    }\n\n    if (input === true) input = node.spec.input = {};\n    else if (typeof input === \"string\") input = node.spec.input = { name: input };\n\n    if (!input.name) {\n      input.name = node.spec.name;\n    }\n\n    return node;\n  }\n  \n  function buildSubmit(node) {\n    if (!node.hasHint(\"submit\")) return node;\n    node.value.enctype = node.value.enctype || \"application/x-www-form-urlencoded\";\n    // this should be changed to resolve the default method for the action's protocol\n    node.value.method = node.value.method || \"GET\";\n    return node;\n  }\n\n  function buildContent(node) {\n    var leastSpecificHint = node.spec.hints[node.spec.hints.length - 1];\n    if (leastSpecificHint.name !== \"content\") return node;\n    if (!node.value) return node;\n    \n    var value = node.value;\n    \n    if (value.src) {\n      value.src = node.document.resolveURI(value.src);\n    }\n\n    if (!value.src && value.data) {\n      var encoding = value.encoding || \"utf8\";\n      value.data = new Buffer(value.data, encoding);\n    }\n    \n    return node;\n  }\n\n  function buildChildren(node) {\n    node.children = [];\n    \n    if (node.hasHint(\"text\")) return node;\n    if (!node.value) return node;\n    \n    var childPromises = [];\n    \n    function buildNodeForResolvedChildSpec(parentNode) {\n      return function (childSpec) {\n        var childValue = parentNode.value[childSpec.name];\n        return buildNode(childValue, childSpec, parentNode.document);\n      };\n    }\n    \n    var usedValueDrivenStrategy = false;\n    \n    if (util.isArray(node.spec.children)) {\n      // node.spec.children is an array (map) [spec driven approach]\n      node.spec.children.forEach(function (childSpec) {\n        var childPromise = Q(childSpec)\n                            .then(resolveSpec(node.document))\n                            .then(buildNodeForResolvedChildSpec(node));\n                            \n        childPromises.push(childPromise);\n      });\n    }\n    else {\n      usedValueDrivenStrategy = true;\n      \n      // node.spec.children is an object (template) [value driven approach]\n      if (node.spec.input && node.spec.children.input === true) {\n        // if the container is an input and the children spec template is a bool\n        // then apply the parent's input specification to the children spec template\n        node.spec.children.input = node.spec.input;\n      }\n      \n      if (node.spec.children) expandHints(node.spec.children);\n      \n      for (var p in node.value) {\n        if (!node.value.hasOwnProperty(p)) continue;\n        var childSpec = node.spec.children ? JSON.parse(JSON.stringify(node.spec.children)) : null;\n        var childValue = node.value[p];\n        // preserve the name of the value/spec tuple\n        if (childSpec) childSpec.name = p;\n        \n        if (!childSpec && !isSelfSpecified(childValue)) continue;\n        \n        childPromises.push(buildNode(childValue, childSpec, node.document));\n      }\n    }\n    \n    var parentValueIsArray = util.isArray(node.value);\n    \n    function attachChildrenAndReturnNode(childNodes) {\n      childNodes.forEach(function (childNode, index) {\n        if (!childNode) return;\n        node.children.push(childNode);\n        childNode.parent = node;\n        \n        if (usedValueDrivenStrategy && parentValueIsArray) {\n          // rename the child nodes to their index/ordinal\n          childNode.name = childNode.spec.name = index.toString();\n        }\n      });\n      \n      return node;\n    }\n    \n    return Q.all(childPromises).then(attachChildrenAndReturnNode);\n  }\n\n  function buildName(node) {\n    node.name = node.spec.name;\n    return node;\n  }\n\n  function buildIterators(node) {\n    Iterable.call(node, function () {\n      return iterators.node(node);\n    });\n    \n    for (var p in Iterable.prototype) {\n      node[p] = Iterable.prototype[p];\n    }\n\n    node.descendants = new Iterable(function () {\n      return iterators.descendants(node);\n    });\n\n    node.ancestors = new Iterable(function () {\n      return iterators.ancestors(node);\n    });\n    \n    return node;\n  }\n\n  function hasHint(hintName) {\n    return this.spec.hints.some(function (hint) {\n      return hint.name === hintName;\n    });\n  }\n\n  function isSelfSpecified(value) {\n    return util.isObject(value) && (\"spec\" in value);\n  }\n\n  function buildNode(value, spec, document) {\n    if (!spec && !isSelfSpecified(value)) throw new Error(\"No specification was provided for the value.\");\n    \n    var node = {};\n    \n    node.document = document;\n    node.value = value;\n    node.hasHint = hasHint;\n    \n    function attachSpec(resolvedSpec) {\n      if (!resolvedSpec) return node;\n      node.spec = resolvedSpec;\n      return node;\n    }\n    \n    return Q(spec)\n      .then(resolveSpec(document))\n      .then(attachSpec)\n      .then(resolveSpecFromValue)\n      .then(buildVisibility)\n      .then(buildHints)\n      .then(buildInput)\n      .then(buildContent)\n      .then(buildSubmit)\n      .then(buildChildren)\n      .then(buildName)\n      .then(buildIterators);\n  }\n\n  function buildDocument(value, spec, content) {\n    var document = {};\n    \n    document.location = content && content.location;\n    \n    var parsedContentType = contentType.parse(content.type);\n    document.base = value.base || parsedContentType.parameters.base || document.location || \"document://\";\n    document.realm = value.realm || parsedContentType.parameters.realm || null;\n    \n    document.resolveURI = function resolveURI(uri) {\n      return app.resolveURI(document.base, uri);\n    };\n    \n    function attachRootAndReturnDocument(node) {\n      document.root = node;\n      return document;\n    }\n    \n    return buildNode(value, spec, document).then(attachRootAndReturnDocument);\n  }\n\n  // the parsing function returned from this module\n  function parse(content) {\n    var value = JSON.parse(content.data.toString());\n    var parsedType = contentType.parse(content.type);\n    var specValue = parsedType.parameters.spec || null;\n    var spec = specValue && specValue.indexOf(\"{\") === 0 ? \n      JSON.parse(specValue) : \n      specValue;\n    \n    return buildDocument(value, spec, content);\n  }\n  \n  parse.buildNode = buildNode;\n  \n  return parse;\n};\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"./iterators\":30,\"buffer\":80,\"content-type\":126,\"q\":134,\"util\":113}],30:[function(require,module,exports){\nmodule.exports = exports = function (app) {\n  var iterators = {};\n  \n  iterators.children = function children(node) {\n    return new app.extensions.common.Iterable(node.children)[\"@@iterator\"]();\n  };\n  \n  iterators.ancestors = function ancestors(node) {\n  \n    var current = node;\n  \n    function next() {\n  \n      var result = current.parent;\n      if (result) {\n        current = result;\n        return {\n          done: false,\n          value: result\n        };\n      }\n  \n      return {\n        done: true\n      };\n    }\n  \n    return {\n      next: next\n    };\n  };\n  \n  iterators.node = function nodeIterator(node) {\n    var descendants;\n  \n    function next() {\n      if (!descendants) {\n        descendants = iterators.descendants(node);\n        return {\n          done: false,\n          value: node\n        };\n      }\n  \n      return descendants.next();\n    }\n  \n    return {\n      next: next\n    };\n  };\n  \n  iterators.descendants = function descendants(node) {\n    var iters = [];\n    var current = iterators.children(node);\n  \n    function next() {\n      var result = current.next();\n  \n      // not done?\n      if (!result.done) {\n  \n        if (result.value.children.length > 0) {\n          iters.push(current);\n          current = iterators.children(result.value);\n        }\n  \n        return {\n          done: false,\n          value: result.value\n        };\n      }\n  \n      // all done?\n      if (result.done && iters.length === 0) {\n        return result;\n      }\n  \n      // done w/ this one!\n      current = iters.pop();\n      return next();\n    }\n  \n    return {\n      next: next\n    };\n  };\n  \n  return iterators;\n};\n\n},{}],31:[function(require,module,exports){\nvar util = require(\"util\");\n\nmodule.exports = exports = function (app) {\n  function accumulateValidationStatesForConstraints(validationElement, validationStates) {\n    var validationConstraintSet = validationElement.lynx.validation;\n    \n    function pushValidationConstraintState(validationConstraint) {\n      validationStates.push(validationConstraint.state);\n    }\n    \n    var reserved = [\"invalid\", \"valid\", \"unknown\"];\n    \n    for (var constraintName in validationConstraintSet) {\n      if (reserved.indexOf(constraintName) > -1) continue;\n      var constraintsOrConstraint = validationConstraintSet[constraintName];\n      \n      if (util.isArray(constraintsOrConstraint)) {\n        constraintsOrConstraint.forEach(pushValidationConstraintState);\n      }\n      else {\n        pushValidationConstraintState(constraintsOrConstraint);\n      }\n    }\n  }\n  \n  return accumulateValidationStatesForConstraints;\n};\n\n},{\"util\":113}],32:[function(require,module,exports){\nmodule.exports = exports = function (app) {\n  var accumulateValidationStatesForConstraints = require(\"./accumulate-validation-states-for-constraint-set\")(app);\n  \n  function accumulateValidationStatesForDescendants(validationElement, validationStates) {\n    if (!validationElement) return;\n    \n    var selector = \"[data-lynx-validation-state]\";\n    var validationElements = app.extensions.common.select(selector)(validationElement);\n    \n    function accumulateValidationState(descendant) {\n      accumulateValidationStatesForConstraints(descendant, validationStates);\n    }\n    \n    validationElements.forEach(accumulateValidationState);\n  }\n  \n  return accumulateValidationStatesForDescendants;\n};\n\n},{\"./accumulate-validation-states-for-constraint-set\":31}],33:[function(require,module,exports){\nmodule.exports = exports = function (app) {\n  function applyContainerInputBehavior(result) {\n    var containerInput = result.element;\n\n    var removeSel = \"[data-lynx-container-input-remove]\";\n    var addSel = \"[data-lynx-container-input-add]\";\n    \n    function applyRemoveBehavior(removeElement) {\n      removeElement.addEventListener(\"click\", function () {\n        containerInput.lynx.removeElement(removeElement);\n      });\n    }\n    \n    var removeElements = app.extensions.common.select(removeSel)(containerInput);\n    removeElements.forEach(applyRemoveBehavior);\n    \n    var addElements = app.extensions.common.select(addSel)(containerInput);\n    var addElement = addElements.first();\n    if (!addElement) return;\n    \n    function isRemoveElement(elem) {\n      return app.extensions.common.matchesSelector(elem, removeSel);\n    }\n    \n    addElement.addEventListener(\"click\", function () {\n      containerInput.lynx.addElement().then(function (addedElement) {\n        var removeElement = app.extensions.common.findNearestElement(addedElement, isRemoveElement);\n        applyRemoveBehavior(removeElement);\n      });\n    });\n    \n    return result;\n  }\n  \n  return applyContainerInputBehavior;\n};\n\n},{}],34:[function(require,module,exports){\nvar util = require(\"util\");\n\n\nfunction getTextConstraintWithFormat(element) {\n  if (!element.lynx || !element.lynx.validation || !element.lynx.validation.text) return null;\n\n  function hasPatternAndFormat(textConstraint) {\n    return (\"pattern\" in element.lynx.validation.text) && (\"format\" in element.lynx.validation.text);\n  }\n\n  if (!util.isArray(element.lynx.validation.text)) {\n    if (hasPatternAndFormat(element.lynx.validation.text)) return element.lynx.validation.text;\n    return null;\n  }\n\n  return element.lynx.validation.text.find(hasPatternAndFormat);\n}\n\nfunction applyFormattedBehavior(result) {\n  var element = result.element;\n  var textConstraint = getTextConstraintWithFormat(element);\n  if (!textConstraint || !textConstraint.pattern || !textConstraint.format) return result;\n\n  var regex = new RegExp(textConstraint.pattern);\n\n  element.addEventListener(\"blur\", function () {\n    if (!regex.test(element.value)) return;\n    element.value = element.value.replace(regex, textConstraint.format);\n  });\n  \n  return result;\n}\n\nmodule.exports = exports = function (app) {\n  return applyFormattedBehavior;\n};\n\n},{\"util\":113}],35:[function(require,module,exports){\nmodule.exports = exports = function (app) {\n  function applyOptionsBehavior(callbacks) {\n    function inputElementContainsValue(inputElement, value) {\n      var inputElements = app.extensions.common.select(\"input,textarea\")(inputElement);\n      return inputElements.some(function (elem) {\n        return value === elem.value;\n      });\n    }\n\n    function findMatchingInputElements(inputElement, value) {\n      var inputElements = app.extensions.common.select(\"input,textarea\")(inputElement);\n      return inputElements.filter(function (elem) {\n        return value === elem.value;\n      });\n    }\n\n    function isAddElement(elem) {\n      return app.extensions.common.matchesSelector(elem, \"[data-lynx-container-input-add]\");\n    }\n\n    function isRemoveElement(elem) {\n      return app.extensions.common.matchesSelector(elem, \"[data-lynx-container-input-remove]\");\n    }\n\n    function removeInputElement(inputElement) {\n      var removeElement = app.extensions.common.findNearestElement(inputElement, isRemoveElement);\n      if (removeElement) removeElement.click();\n    }\n\n    function findOptionElementFor(valueElement, mostSpecificHint) {\n      valueElement.dataset.lynxOptionValue = \"true\";\n      var optionElement = valueElement;\n      var parentLynxElement = app.extensions.common.findNearestAncestor(optionElement, \"[data-lynx-hints]\");\n\n      var optionMatches = app.extensions.lynx.findElementsWithHint(parentLynxElement, mostSpecificHint);\n      if (optionMatches.count() === 1) {\n        optionElement = parentLynxElement;\n      }\n\n      optionElement.dataset.lynxOption = true;\n\n      return optionElement;\n    }\n\n    function setSingleSelectOptionContextAndBehavior(optionsSourceElement, inputElement, mostSpecificHint) {\n      var setSelectedFunctions = [];\n      \n      function onInput() {\n        setSelectedFunctions.forEach( function (setSelected) {\n          setSelected();\n        });\n      }\n      \n      inputElement.addEventListener(\"input\", onInput);\n      \n      optionsSourceElement.lynx.addCleanup(function () {\n        inputElement.removeEventListener(\"input\", onInput);\n      });\n\n      return function (valueElement) {\n        var optionElement = findOptionElementFor(valueElement, mostSpecificHint);\n\n        var setSelected = function () {\n          var isSelected = valueElement.textContent === inputElement.value;\n          optionElement.dataset.lynxOptionSelected = isSelected;\n          \n          var state = isSelected ? \"selected\" : \"\";\n          callbacks.optionSelectedChanged({ element: optionElement, state: state });\n        };\n\n        setSelected();\n        setSelectedFunctions.push(setSelected);\n\n        function onOptionClick () {\n          if (optionElement.dataset.lynxOptionSelected === \"true\") {\n            app.extensions.common.setInputElementValue(inputElement, null);\n          }\n          else {\n            app.extensions.common.setInputElementValue(inputElement, valueElement.textContent);\n          }\n\n          setSelectedFunctions.forEach( function (setSelected) {\n            setSelected();\n          });\n        }\n\n        optionElement.addEventListener(\"click\", onOptionClick);\n        \n        optionsSourceElement.lynx.addCleanup(function () {\n          optionElement.removeEventListener(\"click\", onOptionClick);\n        });\n        \n        callbacks.optionRoleChanged({ element: optionElement, state: \"option\" });\n      };\n    }\n\n    function setMultiSelectOptionContextAndBehavior(optionsSourceElement, inputElement, mostSpecificHint) {\n      return function (valueElement) {\n        var optionElement = findOptionElementFor(valueElement, mostSpecificHint);\n\n        if (inputElementContainsValue(inputElement, valueElement.textContent)) {\n          optionElement.dataset.lynxOptionSelected = true;\n        }\n\n        function onOptionClick(evt) {\n          if (optionElement.dataset.lynxOptionSelected === \"true\") {\n            optionElement.dataset.lynxOptionSelected = false;\n            var inputElements = findMatchingInputElements(inputElement, valueElement.textContent);\n            inputElements.forEach(removeInputElement);\n            callbacks.optionSelectedChanged({ element: optionElement, state: \"\" });\n          }\n          else {\n            optionElement.dataset.lynxOptionSelected = true;\n\n            var addElement = app.extensions.common.findNearestElement(inputElement, isAddElement);\n            addElement.click();\n\n            window.setTimeout(function () {\n              var newElement = inputElement.lastElementChild;\n              var newInputElement = app.extensions.common.select(\"input,textarea\")(newElement).first();\n              newInputElement.value = valueElement.textContent;\n              callbacks.optionSelectedChanged({ element: optionElement, state: \"selected\" });\n            }, 10);\n          }\n        }\n\n        optionElement.addEventListener(\"click\", onOptionClick);\n        \n        optionsSourceElement.lynx.addCleanup(function () {\n          optionElement.removeEventListener(\"click\", onOptionClick);\n        });\n        \n        callbacks.optionRoleChanged({ element: optionElement, state: \"option\" });\n      };\n    }\n    \n    function removeOptionsAttributes(optionsSourceElement) {\n      delete optionsSourceElement.dataset.lynxOptionsFor;\n      delete optionsSourceElement.dataset.lynxOptionsMultiSelect;\n      \n      app.extensions.common.select(\"[data-lynx-option-value]\")(optionsSourceElement)\n        .forEach(function (valueElement) {\n          delete valueElement.dataset.lynxOptionValue;\n        });\n        \n      app.extensions.common.select(\"[data-lynx-option]\")(optionsSourceElement)\n        .forEach(function (optionElement) {\n          delete optionElement.dataset.lynxOption;\n          delete optionElement.dataset.lynxOptionSelected;\n          callbacks.optionRoleChanged({ element: optionElement, state: \"\" });\n        });\n        \n      callbacks.optionsRoleChanged({ element: optionsSourceElement, state: \"\" });\n    }\n    \n    function removeAllOptionsAttributesAndEventListeners(optionsSourceElement) {\n      if (optionsSourceElement.lynx && optionsSourceElement.lynx.cleanup) {\n        optionsSourceElement.lynx.cleanup();\n      }\n    }\n    \n    function initializeOptionsSourceElement(optionsSourceElement) {  \n      var cleanups = [];\n      \n      optionsSourceElement.lynx = optionsSourceElement.lynx || {};\n      \n      optionsSourceElement.lynx.addCleanup = function (cleanup) {\n        cleanups.push(cleanup);\n      };\n      \n      optionsSourceElement.lynx.cleanup = function () {\n        cleanups.forEach(function (cleanup) {\n          cleanup();\n        });\n        \n        removeOptionsAttributes(optionsSourceElement);\n      };\n    }\n\n    function applyOptionsBehaviorToInputElement(inputElement) {\n      var optionsSourceSelector = \"[data-lynx-name='\" + inputElement.dataset.lynxOptions + \"']\";\n      var optionsSourceElement = app.extensions.common.findNearestElement(inputElement, optionsSourceSelector);\n      if (!optionsSourceElement) return;\n      \n      initializeOptionsSourceElement(optionsSourceElement);\n\n      var mostSpecificHint = inputElement.dataset.lynxOptionsValueHint;\n      var valueElements = app.extensions.lynx.findElementsWithHint(optionsSourceElement, mostSpecificHint).filter( function (valueElement) {\n        return valueElement !== inputElement;\n      });\n      \n      if (valueElements.count() === 0) return;\n\n      optionsSourceElement.dataset.lynxOptionsFor = inputElement.dataset.lynxName;\n      callbacks.optionsRoleChanged({ element: optionsSourceElement, state: \"options\" });\n\n      var setOptionContextAndBehavior;\n\n      if (app.extensions.common.matchesSelector(inputElement, \"[data-lynx-hints~='container']\")) {\n        optionsSourceElement.dataset.lynxOptionsMultiSelect = true;\n        setOptionContextAndBehavior = setMultiSelectOptionContextAndBehavior(optionsSourceElement, inputElement, mostSpecificHint);\n      }\n      else {\n        setOptionContextAndBehavior = setSingleSelectOptionContextAndBehavior(optionsSourceElement, inputElement, mostSpecificHint);\n      }\n\n      valueElements.forEach(setOptionContextAndBehavior);\n    }\n    \n    return function (result) {\n      var scopeElement = result.element;\n      \n      var optionsSelector = \"[data-lynx-options-for]\";\n      var optionsSourceElements = app.extensions.common.select(optionsSelector)(scopeElement);\n      optionsSourceElements.forEach(removeAllOptionsAttributesAndEventListeners);\n      \n      var inputSelector = \"[data-lynx-options]\";\n      var inputElements = app.extensions.common.select(inputSelector)(scopeElement);\n      inputElements.forEach(applyOptionsBehaviorToInputElement);\n\n      return result;\n    };\n  }\n\n  return applyOptionsBehavior;\n};\n\n},{}],36:[function(require,module,exports){\nmodule.exports = exports = function (app) {\n  var calculateDerivedValidationState = require(\"./calculate-derived-validation-state\")(app);\n  \n  function setVisibility(originElement, elementName, visibility, validationState, visibilityChanged) {\n    if (!elementName) return;\n    \n    function finder(element) {\n      return element.dataset.lynxName === elementName;\n    }\n    \n    var element = app.extensions.common.findNearestElement(originElement, finder);\n    if (!element) return;\n    \n    if (element.dataset.lynxVisibility !== visibility) {\n      element.dataset.lynxVisibility = visibility;\n      visibilityChanged(element);  \n    }\n    \n    element.dataset.lynxValidationContentForState = validationState;\n  }\n  \n  function showHideValidationConstraintContent(validationElement, validationObject, validationState, visibilityChanged) {\n    validationState = validationState || \"unknown\";\n    var elementNameToShow = validationObject[validationState];\n    setVisibility(validationElement, elementNameToShow, \"visible\", validationState, visibilityChanged);\n    \n    [\"unknown\", \"invalid\", \"valid\"].filter(function (state) {\n      return state !== validationState;\n    }).forEach(function (stateToHide) {\n      var elementNameToHide = validationObject[stateToHide];\n      setVisibility(validationElement, elementNameToHide, \"hidden\", stateToHide, visibilityChanged);\n    });\n  }\n  \n  function evaluateValidationConstraints(validationElement, visibilityChanged) {\n    function updateConstraintState(constraint, validator) {\n      if (validator) {\n        constraint.state = validator(validationElement, constraint);\n      }\n      else {\n        constraint.state = \"unknown\";\n      }\n      \n      showHideValidationConstraintContent(validationElement, constraint, constraint.state, visibilityChanged);\n    }\n    \n    // update the state of the validation constraints in validationElement\n    app.extensions.lynx.forEachValidationConstraint(validationElement, function (constraint, constraintName) {\n      var validator = app.extensions.lynx.validators[constraintName];\n      updateConstraintState(constraint, validator);\n    });\n  }\n  \n  function showHideValidationConstraintContentForAll(visibilityChanged) {\n    return function (result) {\n      var applicationElement = app.getApplicationElement();\n      var selector = \"[data-lynx-validation-state]\";\n      \n      app.extensions.common.select(selector)(applicationElement)\n        .forEach(function (validationElement) {\n          showHideValidationConstraintContent(validationElement, validationElement.lynx.validation, validationElement.dataset.lynxValidationState, visibilityChanged);\n          \n          app.extensions.lynx.forEachValidationConstraint(validationElement, function (constraint) {\n            showHideValidationConstraintContent(validationElement, constraint, constraint.state, visibilityChanged);\n          });\n        });\n        \n      return result;\n    };\n  }\n  \n  function applyValidationBehavior(visibilityChanged, validityChanged) {\n    return function (result) {\n      function applyValidationBehaviorElement(validationElement) {\n        \n        function setValidationState(newValidationState) {\n          if (validationElement.dataset.lynxValidationState === newValidationState) return;\n          validationElement.dataset.lynxValidationState = newValidationState;\n          validityChanged(validationElement);\n        }\n        \n        function recalculateValidationState() {\n          evaluateValidationConstraints(validationElement, visibilityChanged);\n          setValidationState(calculateDerivedValidationState(validationElement));\n          showHideValidationConstraintContent(validationElement, validationElement.lynx.validation, validationElement.dataset.lynxValidationState, visibilityChanged);\n        }\n        \n        validationElement.addEventListener(\"input\", recalculateValidationState);\n        setValidationState(calculateDerivedValidationState(validationElement));\n      }\n      \n      var selector = \"[data-lynx-validation-state]\";\n      var validationElements = app.extensions.common.select(selector)(result.element);\n      validationElements.forEach(applyValidationBehaviorElement);\n      \n      return result;\n    };\n  }\n  \n  return {\n    applyValidationBehavior: applyValidationBehavior,\n    showHideValidationConstraintContentForAll: showHideValidationConstraintContentForAll\n  };\n};\n\n},{\"./calculate-derived-validation-state\":37}],37:[function(require,module,exports){\nmodule.exports = exports = function (app) {\n  var accumulateValidationStatesForConstraints = require(\"./accumulate-validation-states-for-constraint-set\")(app);\n  var accumulateValidationStatesForDescendants = require(\"./accumulate-validation-states-for-descendants\")(app);\n  \n  function calculateDerivedValidationState(validationElement, cb) {\n    var validationStates = [];\n    accumulateValidationStatesForConstraints(validationElement, validationStates);\n    accumulateValidationStatesForDescendants(validationElement, validationStates);\n    \n    function are(expected) {\n      return function (actual) {\n        return actual === expected;\n      };\n    }\n    \n    if (validationStates.some(are(\"invalid\"))) return \"invalid\";\n    if (validationStates.some(are(\"unknown\"))) return \"unknown\";\n    if (validationStates.some(are(\"valid\"))) return \"valid\";\n    return \"unknown\";\n  }\n  \n  return calculateDerivedValidationState;\n};\n\n},{\"./accumulate-validation-states-for-constraint-set\":31,\"./accumulate-validation-states-for-descendants\":32}],38:[function(require,module,exports){\nmodule.exports = exports = function (app) {\n  var extension = {};\n\n  extension.parsing = require(\"jsua-lynx-parsing\")(app);\n  extension.rendering = require(\"./rendering/render\")(app);\n\n  extension.finishing = {};\n  extension.finishing.applyOptionsBehavior = require(\"./finishing/apply-options-behavior\")(app);\n  var validationBehavior = require(\"./finishing/apply-validation-behavior\")(app);\n  extension.finishing.applyValidationBehavior = validationBehavior.applyValidationBehavior;\n  extension.finishing.showHideValidationConstraintContentForAll = validationBehavior.showHideValidationConstraintContentForAll;\n  extension.finishing.applyContainerInputBehavior = require(\"./finishing/apply-container-input-behavior\")(app);\n  extension.finishing.applyFormattedBehavior = require(\"./finishing/apply-formatted-behavior\")(app);\n\n  extension.nodeRendering = {};\n  extension.nodeRendering.container = require(\"./rendering/functions/container\")(app);\n  extension.nodeRendering.containerInput = require(\"./rendering/functions/container-input\")(app);\n  extension.nodeRendering.content = require(\"./rendering/functions/content\")(app);\n  extension.nodeRendering.image = require(\"./rendering/functions/image\")(app);\n  extension.nodeRendering.form = require(\"./rendering/functions/form\")(app);\n  extension.nodeRendering.submit = require(\"./rendering/functions/submit\")(app);\n  extension.nodeRendering.link = require(\"./rendering/functions/link\")(app);\n  extension.nodeRendering.text = require(\"./rendering/functions/text\")(app);\n  extension.nodeRendering.textInput = require(\"./rendering/functions/text-input\")(app);\n\n  extension.afterNodeRendering = {};\n  extension.afterNodeRendering.setName = require(\"./rendering/after/set-name\")(app);\n  extension.afterNodeRendering.setHints = require(\"./rendering/after/set-hints\")(app);\n  extension.afterNodeRendering.setVisibility = require(\"./rendering/after/set-visibility\")(app);\n  extension.afterNodeRendering.setScope = require(\"./rendering/after/set-scope\")(app);\n  extension.afterNodeRendering.setOptions = require(\"./rendering/after/set-options\")(app);\n  extension.afterNodeRendering.link = require(\"./rendering/after/link\")(app);\n  extension.afterNodeRendering.submit = require(\"./rendering/after/submit\")(app);\n  extension.afterNodeRendering.setValidation = require(\"./rendering/after/set-validation\")(app);\n  extension.afterNodeRendering.setLabeledBy = require(\"./rendering/after/set-labeled-by\")(app);\n  extension.afterNodeRendering.setFormatted = require(\"./rendering/after/set-formatted\")(app);\n\n  extension.validators = {};\n  extension.validators.required = require(\"./util/validators/required-validator\")(app);\n  extension.validators.text = require(\"./util/validators/text-validator\")(app);\n  extension.validators.number = require(\"./util/validators/number-validator\")(app);\n\n  extension.getHintsForElement = require(\"./util/get-hints-for-element\")(app);\n  extension.setHintsForElement = require(\"./util/set-hints-for-element\")(app);\n  extension.findElementsWithHint = require(\"./util/find-elements-with-hint\")(app);\n  extension.findLabelElement = require(\"./util/find-label-element\")(app);\n  extension.findOptionsElement = require(\"./util/find-options-element\")(app);\n  extension.forEachValidationConstraint = require(\"./util/for-each-validation-constraint\")(app);\n\n  return extension;\n};\n\n},{\"./finishing/apply-container-input-behavior\":33,\"./finishing/apply-formatted-behavior\":34,\"./finishing/apply-options-behavior\":35,\"./finishing/apply-validation-behavior\":36,\"./rendering/after/link\":39,\"./rendering/after/set-formatted\":40,\"./rendering/after/set-hints\":41,\"./rendering/after/set-labeled-by\":42,\"./rendering/after/set-name\":43,\"./rendering/after/set-options\":44,\"./rendering/after/set-scope\":45,\"./rendering/after/set-validation\":46,\"./rendering/after/set-visibility\":47,\"./rendering/after/submit\":48,\"./rendering/functions/container\":50,\"./rendering/functions/container-input\":49,\"./rendering/functions/content\":51,\"./rendering/functions/form\":52,\"./rendering/functions/image\":53,\"./rendering/functions/link\":54,\"./rendering/functions/submit\":55,\"./rendering/functions/text\":57,\"./rendering/functions/text-input\":56,\"./rendering/render\":58,\"./util/find-elements-with-hint\":59,\"./util/find-label-element\":60,\"./util/find-options-element\":61,\"./util/for-each-validation-constraint\":62,\"./util/get-hints-for-element\":63,\"./util/set-hints-for-element\":64,\"./util/validators/number-validator\":65,\"./util/validators/required-validator\":66,\"./util/validators/text-validator\":67,\"jsua-lynx-parsing\":29}],39:[function(require,module,exports){\nmodule.exports = exports = function (app) {\n  function afterLink(result) {\n    if (!result.node.hasHint(\"link\")) return result;\n    \n    var node = result.node;\n    var element = result.element;\n    \n    if (element.tagName !== \"A\") {\n      app.extensions.common.addAriaRole(element, \"link\");\n      element.setAttribute(\"tabindex\", \"0\");\n      element.dataset.href = node.document.resolveURI(node.value.href);\n      element.dataset.type = node.value.type || \"\";\n    }\n    \n    if (\"follow\" in node.spec) {\n      element.dataset.follow = node.spec.follow;\n    }\n    \n    return result;\n  }\n  \n  return afterLink;\n};\n\n},{}],40:[function(require,module,exports){\nvar util = require(\"util\");\n\nmodule.exports = exports = function (app) {\n  function hasFormat(textConstraint) {\n    if (util.isArray(textConstraint)) return textConstraint.some(hasFormat);\n    return \"format\" in textConstraint;\n  }\n  \n  function setFormatted(result) {\n    if (!result.node.spec.validation || !result.node.spec.validation.text) return result;\n    if (!hasFormat(result.node.spec.validation.text)) return result;\n\n    result.element.dataset.lynxValidationFormatted = true;\n    return result;\n  }\n\n  return setFormatted;\n};\n\n},{\"util\":113}],41:[function(require,module,exports){\nmodule.exports = exports = function (app) {\n  function setHints(result) {\n    function getHintName(hint) {\n      return hint.name;\n    }\n    \n    var hintNames = result.node.spec.hints.map(getHintName);\n    \n    // TODO: Review this. How do we ensure specificity when merging?\n    if (result.element.dataset.lynxHints) {\n      var currentHints = app.extensions.lynx.getHintsForElement(result.element);\n      hintNames = currentHints.concat(hintNames);\n    }\n    \n    app.extensions.lynx.setHintsForElement(result.element, hintNames);\n    \n    return result;\n  }\n  \n  return setHints;\n};\n\n},{}],42:[function(require,module,exports){\nmodule.exports = exports = function (app) {\n  function setLabeledBy(result) {\n    if (!result.node.spec.labeledBy) return result;\n    \n    result.element.dataset.lynxLabeledBy = result.node.spec.labeledBy;\n    \n    return result;\n  }\n  \n  return setLabeledBy;\n};\n\n},{}],43:[function(require,module,exports){\nmodule.exports = exports = function (app) {\n  function setName(result) {\n    if (!result.node.name) return result;\n    result.element.dataset.lynxName = result.node.name;\n    return result;\n  }\n  \n  return setName;\n};\n\n},{}],44:[function(require,module,exports){\nmodule.exports = exports = function (app) {\n  function setOptions(result) {\n    if (!result.node.spec.options) return result;\n    result.element.dataset.lynxOptions = result.node.spec.options;\n    return result;\n  }\n  \n  return setOptions;\n};\n\n},{}],45:[function(require,module,exports){\nvar util = require(\"util\");\n\nmodule.exports = exports = function (app) {\n  function setScope(result) {\n    if (!util.isObject(result.node.value)) return result;\n    if (!result.node.value.scope) return result;\n    \n    result.element.dataset.contentScope = result.node.value.scope;\n    return result;\n  }\n  \n  return setScope;\n};\n\n},{\"util\":113}],46:[function(require,module,exports){\nmodule.exports = exports = function (app) {\n  function setValidation(result) {\n    var node = result.node;\n    var element = result.element;\n    \n    if (!node.spec.validation) return result;\n    \n    element.lynx = element.lynx || {};\n    element.lynx.validation = node.spec.validation;\n    element.dataset.lynxValidationState = \"unknown\";\n    \n    return result;\n  }\n  \n  return setValidation;\n};\n\n},{}],47:[function(require,module,exports){\nmodule.exports = exports = function (app) {\n  function setVisibility(result) {\n    result.element.dataset.lynxVisibility = result.node.spec.visibility;\n    return result;\n  }\n  \n  return setVisibility;\n};\n\n},{}],48:[function(require,module,exports){\nmodule.exports = exports = function (app) {\n  function afterSubmit(result) {\n    if (!result.node.hasHint(\"submit\")) return result;\n    \n    var node = result.node;\n    var element = result.element;\n    \n    if (element.tagName !== \"BUTTON\") \n    {\n      app.extensions.common.addAriaRole(element, \"button\");\n      element.setAttribute(\"tabindex\", \"0\");\n    }\n    \n    element.dataset.action = node.document.resolveURI(node.value.action);\n    element.dataset.enctype = node.value.enctype || \"\";\n    element.dataset.method = node.value.method || \"\";\n    \n    return result;\n  }\n  \n  return afterSubmit;\n};\n\n},{}],49:[function(require,module,exports){\nvar Q = require(\"q\");\n\nmodule.exports = exports = function (app) {\n  function renderContainerInput(node) {\n    var rootElement = document.createElement(\"div\");\n    rootElement.dataset.lynxInput = true;\n    rootElement.appendChild(createAddElement());\n    \n    rootElement.lynx = rootElement.lynx || {};\n    \n    if (node.spec.options) rootElement.dataset.lynxOptionsValueHint = node.spec.children.hints[0].name;\n    \n    rootElement.lynx.addElement = function addContainerInputElement() {\n      return app.extensions.lynx.parsing.buildNode(null, node.spec.children, node.document)\n        .then(app.extensions.lynx.rendering.node)\n        .then(appendChild);\n    };\n    \n    function isContainerItem(elem) {\n      return app.extensions.common.matchesSelector(elem, \"[data-lynx-container-input-item]\");\n    }\n    \n    rootElement.lynx.removeElement = function removeContainerInputElement(removeElement) {\n      var containerItem = app.extensions.common.findNearestElement(removeElement, isContainerItem);\n      containerItem.parentElement.removeChild(containerItem);\n    };\n\n    function createAddElement() {\n      var add = document.createElement(\"div\");\n      add.textContent = \"+\";\n      add.dataset.lynxContainerInputAdd = true;\n      return add;\n    }\n    \n    function createRemoveElement() {\n      var remove = document.createElement(\"div\");\n      remove.textContent = \"-\";\n      remove.dataset.lynxContainerInputRemove = true;\n      return remove;\n    }\n\n    function appendChild(child) {\n      var container = document.createElement(\"div\");\n      container.dataset.lynxContainerInputItem = true;\n      \n      container.appendChild(child);\n      container.appendChild(createRemoveElement());\n      rootElement.appendChild(container);\n      \n      return container;\n    }\n    \n    function appendChildren(children) {\n      children.forEach(appendChild);\n      return rootElement;\n    }\n    \n    return Q(node)\n      .then(app.extensions.lynx.rendering.children)\n      .then(appendChildren);\n  }\n  \n  return renderContainerInput;\n};\n\n},{\"q\":134}],50:[function(require,module,exports){\nvar Q = require(\"q\");\n\nmodule.exports = exports = function (app) {\n  function renderContainer(node) {\n    var rootElement = document.createElement(\"div\");\n\n    function appendChild(child) {\n      rootElement.appendChild(child);\n    }\n    \n    function appendChildren(children) {\n      children.forEach(appendChild);\n    }\n    \n    return Q(node)\n      .then(app.extensions.lynx.rendering.children)\n      .then(appendChildren)\n      .then(function () { return rootElement; });\n  }\n  \n  return renderContainer;\n};\n\n},{\"q\":134}],51:[function(require,module,exports){\nvar Q = require(\"q\");\n\nmodule.exports = exports = function (app) {\n  function renderContent(node) {\n    var content = node.value;\n    \n    if (content.data) {\n      content.location = node.document.location;\n    }\n    \n    function returnElement(result) {\n      return result.element;\n    }\n    \n    return Q(content)\n      .then(app.rendering)\n      .then(returnElement);\n  }\n  \n  return renderContent;\n};\n\n},{\"q\":134}],52:[function(require,module,exports){\nvar Q = require(\"q\");\n\nmodule.exports = exports = function(app) {\n  function renderForm(node) {\n    var rootElement = document.createElement(\"form\");\n\n    function appendChild(child) {\n      rootElement.appendChild(child);\n    }\n    \n    function appendChildren(children) {\n      children.forEach(appendChild);\n    }\n\n    return Q(node)\n      .then(app.extensions.lynx.rendering.children)\n      .then(appendChildren)\n      .then(function () { return rootElement; });\n  }\n  \n  return renderForm;\n};\n\n},{\"q\":134}],53:[function(require,module,exports){\nmodule.exports = exports = function (app) {\n  function renderImage(node) {\n    var rootElement = document.createElement(\"img\");\n    rootElement.src = node.document.resolveURI(node.value.src);\n\n    var height = parseInt(node.value.height);\n    if (height) rootElement.height = height;\n\n    var width = parseInt(node.value.width);\n    if (width) rootElement.width = width;\n    \n    return rootElement;\n  }\n  \n  return renderImage;\n};\n\n},{}],54:[function(require,module,exports){\nmodule.exports = exports = function (app) {\n  function renderLink(node) {\n    var rootElement = document.createElement(\"a\");\n    var href = node.document.resolveURI(node.value.href);\n    rootElement.href = href;\n    \n    if (node.value.type) {\n      rootElement.type = node.value.type;\n    }\n\n    function appendChild(child) {\n      rootElement.appendChild(child);\n    }\n    \n    function appendChildren(children) {\n      if (children.length === 0) {\n        rootElement.textContent = href;\n      }\n      else {\n        children.forEach(appendChild);  \n      }\n    }\n    \n    return app.extensions.lynx.rendering.children(node)\n      .then(appendChildren)\n      .then(function () { return rootElement; });\n  }\n\n  return renderLink;\n};\n\n},{}],55:[function(require,module,exports){\nvar Q = require(\"q\");\n\nmodule.exports = exports = function (app) {\n  function renderSubmit(node) {\n    var rootElement = document.createElement(\"button\");\n\n    function appendChild(child) {\n      rootElement.appendChild(child);\n    }\n    \n    function appendChildren(children) {\n      if (children.length === 0) {\n        rootElement.textContent = node.document.resolveURI(node.value.action);\n      }\n      else {\n        children.forEach(appendChild);\n      }\n    }\n    \n    return Q(node)\n      .then(app.extensions.lynx.rendering.children)\n      .then(appendChildren)\n      .then(function () { return rootElement; });\n  }\n  \n  return renderSubmit;\n};\n\n},{\"q\":134}],56:[function(require,module,exports){\nmodule.exports = exports = function (app) {\n  function renderTextInput(node) {\n    var rootElement;\n    \n    var isPhrasing = node.spec.hints.some(function (hint) { \n      return hint.name === \"phrasing\";\n    });\n    \n    if (isPhrasing) {\n      rootElement = document.createElement(\"input\");\n      \n      if (node.spec.visibility === \"concealed\") {\n        rootElement.type = \"password\";\n      } else {\n        rootElement.type = \"text\";\n      }\n    } else {\n       rootElement = document.createElement(\"textarea\");\n    }\n    \n    rootElement.name = node.spec.input.name || \"\";\n    rootElement.value = node.value && node.value.toString();\n    rootElement.dataset.lynxInput = \"true\";\n    \n    if (node.spec.options) rootElement.dataset.lynxOptionsValueHint = node.spec.hints[0].name;\n    \n    return rootElement;\n  }\n  \n  return renderTextInput;\n};\n\n},{}],57:[function(require,module,exports){\nmodule.exports = exports = function (app) {\n  function renderText(node) {\n    var rootElement = document.createElement(\"pre\");\n    rootElement.textContent = node.value.toString();\n    return rootElement;\n  }\n  \n  return renderText;\n};\n\n},{}],58:[function(require,module,exports){\nvar Q = require(\"q\");\n\nmodule.exports = exports = function (app) {\n  var renderFunctions = [];\n  var afterFunctions = [];\n  \n  function applyContentRealm(document) {\n    return function (rootElement) {\n      if (document.realm) {\n        rootElement.dataset.contentRealm = document.realm;\n      }\n\n      return rootElement;\n    };\n  }\n  \n  function ensureContentHasData(content) {\n    if (content.data) return Q(content);\n    return app.transferring(content.src);\n  }\n  \n  function renderLynxChildren(node) {\n    var childPromises = [];\n\n    node.children.forEach(function (child) {\n      childPromises.push(Q(child)\n        .then(renderLynxNode)\n        .fail(app.error));\n    });\n\n    return Q.all(childPromises);\n  }\n  \n  function renderLynxNode(node) {\n    function filter(hintName, isInput) {\n      return function (lynxNodeRenderingFunction) {\n        return lynxNodeRenderingFunction.hintName == hintName &&\n          lynxNodeRenderingFunction.isInput === isInput;\n      };\n    }\n    \n    function setLynxNodeRenderingContext(renderingHint, hintNames) {\n      return function (element) {\n        element.dataset.lynxRenderingHint = renderingHint;\n        return element;\n      };\n    }\n    \n    var hintNames = node.spec.hints.map(function (hint) {\n      return hint.name;\n    });\n\n    var promiseForElement;\n\n    // If there is no value to render, then there is nothing to return\n    if ((node.value === null || node.value === undefined) && !node.spec.input) {\n      return document.createComment(\"Value was null or undefined for node w/ name: \" + node.name);\n    }\n    \n    var isInput = !!node.spec.input;\n    \n    var currentPromiseForElement;\n        \n    hintNames.forEach(function (hintName) {\n      var lynxNodeRenderingFunction = renderFunctions.find( filter(hintName, isInput) );\n      if (!lynxNodeRenderingFunction) return;\n      if(!promiseForElement) {\n        promiseForElement = Q(node)\n          .then(lynxNodeRenderingFunction.fn)\n          .then(setLynxNodeRenderingContext(hintName, hintNames));\n        currentPromiseForElement = promiseForElement;\n      }\n      else {\n        currentPromiseForElement = currentPromiseForElement.fail( function (err) {\n          app.error(err);\n          return Q(node)\n            .then(lynxNodeRenderingFunction.fn)\n            .then(setLynxNodeRenderingContext(hintName, hintNames));\n        });\n      }\n    });\n    \n    currentPromiseForElement.fail(function (err) {\n      // TODO: consider returning an element here to visually indicate a node rendering failure\n      app.error(err);\n    });\n    \n    if (!promiseForElement) throw new Error(\"No node rendering functions are available to render node hints: \" + hintNames.join(\", \"));\n    \n    function returnElement(result) {\n      return result.element;\n    }\n    \n    function createLynxNodeRenderingResult(element) {\n      return { \n        node: node, \n        element: element \n      };\n    }\n    \n    promiseForElement = promiseForElement.then(createLynxNodeRenderingResult);\n    \n    promiseForElement = afterFunctions.reduce(\n      Q.when, \n      promiseForElement\n    );\n    \n    return promiseForElement\n      .then(returnElement);\n  }\n  \n  function renderLynxDocument(lynxDocument) {\n    return Q(lynxDocument.root)\n      .then(renderLynxNode)\n      .then(applyContentRealm(lynxDocument));\n  }\n  \n  function addLynxNodeRenderingFunction(hintName, lynxNodeRenderingFunction, isInput) {\n    if (!hintName) throw new Error(\"Parameter 'hintName' is required.\");\n    if (!lynxNodeRenderingFunction) throw new Error(\"Parameter 'lynxNodeRenderingFunction' is required.\");\n    isInput = isInput || false;\n    \n    renderFunctions.push({\n      hintName: hintName,\n      isInput: isInput,\n      fn: lynxNodeRenderingFunction\n    });\n  }\n  \n  function addLynxNodePostRenderingFunction(lynxNodePostRenderingFunction) {\n    afterFunctions.push(lynxNodePostRenderingFunction);\n  }\n  \n  function renderLynxContent(content) {\n    return ensureContentHasData(content)\n  \t\t.then(app.extensions.lynx.parsing)\n      .then(renderLynxDocument);\n  }\n  \n  renderLynxContent.add = addLynxNodeRenderingFunction;\n  renderLynxContent.after = addLynxNodePostRenderingFunction;\n  renderLynxContent.children = renderLynxChildren;\n  renderLynxContent.node = renderLynxNode;\n  \n  return renderLynxContent;\n};\n\n},{\"q\":134}],59:[function(require,module,exports){\nmodule.exports = exports = function (app) {\n  function findElementsWithHint(element, hintName) {\n    return app.extensions.common.select(\"[data-lynx-hints~='\" + hintName + \"']\")(element);\n  }\n\n  return findElementsWithHint;\n};\n\n},{}],60:[function(require,module,exports){\nmodule.exports = exports = function (app) {\n  return function findLabelElement(labeledElement) {\n    var labeledBy = labeledElement.dataset.lynxLabeledBy;\n    if (!labeledBy) return null;\n    \n    return app.extensions.common.findNearestElement(labeledElement, function (el) {\n      return el.dataset.lynxName === labeledBy;\n    });\n  };\n};\n\n},{}],61:[function(require,module,exports){\nmodule.exports = exports = function (app) {\n  return function findOptionsElement(inputElement) {\n    var optionsName = inputElement.dataset.lynxOptions;\n    if (!optionsName) return null;\n    \n    return app.extensions.common.findNearestElement(inputElement, function (el) {\n      return el.dataset.lynxName === optionsName;\n    });\n  };\n};\n\n},{}],62:[function(require,module,exports){\nvar util = require(\"util\");\n\nmodule.exports = exports = function(app){\n  return function forEachValidationConstraint(validationElement, cb) {\n    var validationConstraintSet = validationElement.lynx.validation;\n\n    function invokeCb(constraintName) {\n      return function (constraint) {\n        cb(constraint, constraintName);\n      };\n    }\n\n    for (var constraintName in validationConstraintSet) {\n      var constraintsOrConstraint = validationConstraintSet[constraintName];\n\n      if (util.isArray(constraintsOrConstraint)) {\n        constraintsOrConstraint.forEach(invokeCb(constraintName));\n      }\n      else {\n        cb(constraintsOrConstraint, constraintName);\n      }\n    }\n  };\n};\n},{\"util\":113}],63:[function(require,module,exports){\nmodule.exports = exports = function (app) {\n  function getHintsForElement(element) {\n    var hints = element.dataset.lynxHints;\n    if (!hints) return [];\n    return hints.split(\" \");\n  }\n  \n  return getHintsForElement;\n};\n\n},{}],64:[function(require,module,exports){\nmodule.exports = exports = function (app) {\n  function setHintsForElement(element, hints) {\n    element.dataset.lynxHints = hints.join(\" \");\n  }\n  \n  return setHintsForElement;\n};\n\n},{}],65:[function(require,module,exports){\nmodule.exports = exports = function (app) {\n  function validateNumber(element, constraint) {\n    var value = element.value;\n    var empty = (value === undefined || value === null || value === \"\");\n    if (empty) {\n      return \"valid\";\n    }\n\n    if(isNaN(+value)){\n      return \"invalid\";\n    }\n\n    if (constraint.min && (value < Number(constraint.min))) {\n      return \"invalid\";\n    }\n\n    if (constraint.max && (value > Number(constraint.max))) {\n      return \"invalid\";\n    }\n\n    if (constraint.step && (value % Number(constraint.step) !== 0)) {\n      return \"invalid\";\n    }\n    \n    return \"valid\";\n  }\n  \n  return validateNumber;\n};\n\n},{}],66:[function(require,module,exports){\nvar util = require(\"util\");\n\nmodule.exports = exports = function (app) {\n  function validateRequired(element, constraint) {\n    var value = element.value;\n    var valid = !(value === undefined || value === null || value === \"\" || (util.isArray(value) && value.length === 0));\n    return valid ? \"valid\" : \"invalid\";\n  }\n  \n  return validateRequired;\n};\n\n},{\"util\":113}],67:[function(require,module,exports){\nmodule.exports = exports = function (app) {\n  function validateText(element, constraint) {\n    var value = element.value;\n    var empty = (value === undefined || value === null || value === \"\");\n    if (empty) {\n      return \"valid\";\n    }\n\n    if (constraint.minLength && (value.length < constraint.minLength)) {\n      return \"invalid\";\n    }\n\n    if (constraint.maxLength && (value.length > constraint.maxLength)) {\n      return \"invalid\";\n    }\n\n    if (constraint.pattern) {\n      var pattern = constraint.pattern;\n      if (pattern.substring(0, 1) !== \"^\") pattern = \"^\" + pattern;\n      if (pattern.substring(pattern.length - 1, 1) !== \"$\") pattern += \"$\";\n      if (new RegExp(pattern).test(value) === false) {\n        return \"invalid\";\n      }\n    }\n    \n    return \"valid\";\n  }\n  \n  return validateText;\n};\n\n},{}],68:[function(require,module,exports){\nvar Q = require(\"q\");\nvar commonmark = require(\"commonmark\");\n\nmodule.exports = exports = function (app) {\n  function ensureContentHasData(content) {\n    if (content.data !== undefined) return Q(content);\n    return app.transferring(content.src);\n  }\n\n  function renderMarkdown(content) {\n    var rootElement = document.createElement(\"div\");\n\n    var reader = new commonmark.Parser();\n    var parsedMarkdown = reader.parse(content.data.toString());\n\n    var writer = new commonmark.HtmlRenderer();\n    rootElement.innerHTML = writer.render(parsedMarkdown);\n\n    return rootElement;\n  }\n\n  function render(content) {\n    return ensureContentHasData(content)\n      .then(renderMarkdown);\n  }\n  \n  var extension = {\n    rendering: render\n  };\n  \n  return extension;\n};\n\n},{\"commonmark\":121,\"q\":134}],69:[function(require,module,exports){\nvar Q = require(\"q\");\n\nmodule.exports = exports = function (app) {\n  function convertLineBreaksToHtmlBreaks(value) {\n    return value && value.toString().replace(/\\r?\\n/g, \"<br />\");\n  }\n\n  function convertHtmlToText(htmlElement) {\n\n    function accumulateText(htmlElement, accum) {\n      var child = htmlElement.firstChild;\n\n      while (child) {\n        if (child.nodeName === \"#text\") {\n          accum.push(child.textContent);\n        } else if (child.previousSibling && child.nodeName === \"BR\" && child.previousSibling.nodeName === \"BR\") {\n          accum.push(\"\");\n        } else if (child.nodeName !== \"BR\" && child.textContent === \"\") {\n          accum.push(\"\");\n        }\n\n        accumulateText(child, accum);\n\n        child = child.nextSibling;\n      }\n    }\n\n    var accum = [];\n    accumulateText(htmlElement, accum);\n\n    return accum.join(\"\\n\");\n  }\n\n  function ensureContentHasData(content) {\n    if (content.data !== undefined) return Q(content);\n    return app.transferring(content.src);\n  }\n\n  function renderTextPlain(content) {\n    var rootElement = document.createElement(\"pre\");\n    rootElement.textContent = content.data.toString();\n    return rootElement;\n  }\n\n  function render(content) {\n    return ensureContentHasData(content)\n      .then(renderTextPlain);\n  }\n  \n  render.convertLineBreaksToHtmlBreaks = convertLineBreaksToHtmlBreaks;\n  // render.convertHtmlToText = convertHtmlToText;\n  \n  var extension = {\n    rendering: render\n  };\n  \n  return extension;\n};\n\n},{\"q\":134}],70:[function(require,module,exports){\n(function (Buffer){\nfunction urlFormDataEncoding(formdata) {\n  function urlEncodeNameValuePair(item) {\n    var value = item.value.data || \"\";\n    return encodeURIComponent(item.name) + \"=\" + encodeURIComponent(value);\n  }\n  \n  var content = formdata.map(urlEncodeNameValuePair)\n    .join(\"&\")\n    .replace(/%20/g, \"+\")\n    .replace(\"'\", \"%27\");\n\n  return {\n    data: new Buffer(content, \"utf8\"),\n    type: \"application/x-www-form-urlencoded\"\n  };\n}\n\nmodule.exports = exports = function (/*app*/) {\n  var extension = {\n    encoding: urlFormDataEncoding\n  };\n  \n  return extension;\n};\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"buffer\":80}],71:[function(require,module,exports){\nvar Q = require(\"q\");\n\nvar encodingFunctions = [];\n\nfunction typeFilter(type) {\n  return function (encodingFunction) {\n    return encodingFunction.type === type;\n  };\n}\n\nfunction encodeFormData(formdata, enctype) {\n  var encodingFunction = encodingFunctions.find( typeFilter(enctype) );\n  if (!encodingFunction) throw new Error(\"No encoding functions are available to encode type: \" + enctype);\n  return Q(formdata).then(encodingFunction);\n}\n\nfunction addEncodingFunction(type, encodingFunction) {\n  if (!type) throw new Error(\"Parameter 'type' is required.\");\n  if (!encodingFunction) throw new Error(\"Parameter 'encodingFunction' is required.\");\n  encodingFunction.type = type;\n  encodingFunctions.push(encodingFunction);\n}\n\nencodeFormData.add = addEncodingFunction;\n\nmodule.exports = exports = function (/*app*/) {\n  return encodeFormData;\n};\n\n},{\"q\":134}],72:[function(require,module,exports){\nvar Q = require(\"q\");\n\nmodule.exports = exports = function (app) {\n  \n  function makeCompositeFinishingFunction(predicate) {\n    var finishingFunctions = [];\n    \n    function makeFailSafePromise(finishingFunction) {\n      return function (result) {\n        return Q(result)\n          .then(finishingFunction)\n          .fail(function (err) {\n            app.error(err);\n            return result;\n          });\n      };\n    }\n    \n    function finishResult(result) {\n      if (predicate && !predicate(result)) return result;\n      return finishingFunctions.reduce(Q.when, Q(result));\n    }\n\n    finishResult.add = function addFinishingFunction(finishingFunction) {\n      finishingFunctions.push(makeFailSafePromise(finishingFunction));\n      return finishResult;\n    };\n\n    return finishResult;  \n  }\n  \n  \n  \n  var rootFinishingFunction = makeCompositeFinishingFunction();\n  \n  rootFinishingFunction.composite = makeCompositeFinishingFunction;\n  \n  rootFinishingFunction.scope = function (scope) {\n    return rootFinishingFunction.composite(function (result) {\n      return app.extensions.common.scopeIncludesRealm(scope, result.element.dataset.contentRealm);\n    });\n  };\n  \n  rootFinishingFunction.realm = function (realm) {\n    return rootFinishingFunction.composite(function (result) {\n      var current = result.element;\n      var appElement = app.getApplicationElement();\n      while (current !== appElement) {\n        if (app.extensions.common.realmsAreEqual(realm, current.dataset.contentRealm)) {\n          return true;\n        }\n        current = current.parentElement;\n      }\n      \n      return false;\n    });\n  };\n  \n  return rootFinishingFunction;\n};\n\n},{\"q\":134}],73:[function(require,module,exports){\nvar Q = require(\"q\");\nvar util = require(\"util\");\n\nmodule.exports = exports = function (app) {\n\n  var getTransitionPromiseHandlers = require(\"./get-transition-promise-handlers\")(app);\n\n  function follow(href, options) {\n    function finish(result) {\n      result.options = options;\n      return app.finishing(result);\n    }\n\n    var content = {\n      src: href\n    };\n\n    options = options || {};\n    options.transition = new Date().valueOf();\n\n    if (options.type) content.type = options.type;\n\n    var promise = Q(content);\n    \n    var transitions = getTransitionPromiseHandlers(options.transition);\n    promise.then(transitions.starting);\n\n    if (options.delay) {\n      promise = promise.delay(options.delay);\n    }\n    \n    function onRejected(err) {\n      var message = [];\n      message.push(\"URL:\");\n      message.push(href);\n      message.push(\"Content:\");\n      message.push(err.message);\n      err.message = message.join(\"\\n\");\n      \n      app.error(err);\n      throw err;\n    }\n\n    return promise.then(app.rendering)\n      .then(finish)\n      .fail(onRejected)\n      .finally(transitions.ending);\n  }\n\n  return follow;\n};\n\n},{\"./get-transition-promise-handlers\":74,\"q\":134,\"util\":113}],74:[function(require,module,exports){\nmodule.exports = exports = function (app) {\n  function getTransitionPromiseHandlers(transition) {\n    function setUserAgentState(applicationElement, newState) {\n      // valid state transitions:\n      //    ready -> loading, loading -> busy, busy -> ready\n      var currentState = applicationElement.dataset.uaState;\n      if (currentState === newState) return;\n      if (currentState === \"ready\" && newState !== \"loading\") return;\n      if (currentState === \"busy\" && newState !== \"ready\") return;\n\n      applicationElement.dataset.uaState = newState;\n\n      var jsuaEvent = document.createEvent(\"Event\");\n      jsuaEvent.initEvent(\"jsua\", true, false);\n      jsuaEvent.state = newState;\n      applicationElement.dispatchEvent(jsuaEvent);\n    }\n\n    function startingTransition(passthrough) {\n      var applicationElement = app.getApplicationElement();\n      var transitionCount = +applicationElement.dataset.uaTransitionCount;\n      if (isNaN(transitionCount)) transitionCount = 0;\n      applicationElement.dataset.uaTransitionCount = ++transitionCount;\n\n      if (transitionCount === 1) {\n        window.setTimeout(setUserAgentState, 100, applicationElement, \"busy\");\n      }\n      setUserAgentState(applicationElement, \"loading\");\n      return passthrough;\n    }\n\n    function endingTransition() {\n      var applicationElement = app.getApplicationElement();\n\n      var transitionCount = +applicationElement.dataset.uaTransitionCount;\n      applicationElement.dataset.uaTransitionCount = --transitionCount;\n\n      if (transitionCount !== 0) return;\n      setUserAgentState(applicationElement, \"ready\");\n    }\n\n    return {\n      starting: startingTransition,\n      ending: endingTransition\n    };\n  }\n\n  return getTransitionPromiseHandlers;\n};\n\n},{}],75:[function(require,module,exports){\nvar url = require(\"url\");\n\nmodule.exports = exports = function () {\n  var app = {};\n  \n  app.encoding = require(\"./encoding\")(app);\n  app.transferring = require(\"./transferring\")(app);\n  app.rendering = require(\"./rendering\")(app);\n  app.finishing = require(\"./finishing\")(app);\n  app.follow = require(\"./follow\")(app);\n  app.send = require(\"./send\")(app);\n  app.extensions = {};\n  \n  app.resolveURI = function (base, uri) {\n    return url.resolve(base, uri);\n  };\n  \n  app.error = function defaultErrorHandler(err) { \n    console.error(err);\n  };\n  \n  var applicationElement = null;\n  \n  app.getApplicationElement = function getApplicationElement() {\n    if (!applicationElement) throw new Error(\"Use the 'setApplicationElement' function to configure the application's root element.\");\n    return applicationElement;\n  };\n  \n  app.setApplicationElement = function setApplicationElement(element) {\n    applicationElement = element;\n  };\n  \n  app.getLocation = function getLocation() {\n    var appElement = app.getApplicationElement();\n    \n    var contentElement = appElement.querySelector(\"[data-content-location]\");\n    return contentElement && contentElement.dataset.contentLocation;\n  };\n  \n  return app;\n};\n\n},{\"./encoding\":71,\"./finishing\":72,\"./follow\":73,\"./rendering\":76,\"./send\":77,\"./transferring\":78,\"url\":111}],76:[function(require,module,exports){\nvar Q = require(\"q\");\nvar contentType = require(\"content-type\");\n\nmodule.exports = exports = function (app) {\n  var contentRenderingFunctions = [];\n  var postContentRenderingFunctions = [];\n\n  // TODO: Improve Matching\n  // we should make the finding of content rendering functions\n  // weighted according to the same rules as Accept\n  // so that it is not dependent upon the order in which the functions are added\n  // e.g. an exact match of text/plain has higher precedence than\n  // a type/* match which has a higher precedence than a */* match\n  function typeRangeFilter(type) {\n    return function (contentRenderingFunction) {\n      var typeRange = contentRenderingFunction.typeRange;\n      type = contentType.parse(type).type;\n      \n      if (typeRange === \"*/*\") return true;\n      if (typeRange === type) return true;\n      \n      var expected = typeRange.split(\"/\");\n      var actual = type.split(\"/\");\n      if (expected[1] === \"*\") return expected[0] === actual[0];\n      \n      return false;\n    };\n  }\n\n  function createContentObjectFromHeadResult(content) {\n    return function (result) {\n      return {\n        src: content.src,\n        type: result.type\n      };\n    };\n  }\n\n  function ensureTypeAttribute(content) {\n    if (content.type) {\n      return content;\n    }\n\n    return app.transferring(content.src, { method: \"HEAD\" })\n      .then(createContentObjectFromHeadResult(content));\n  }\n\n  // TODO: Catch error from rendering package and \n  // try other matching but less specific rendering packages\n  function renderContent(content) {\n    function createResult(element) {\n      return {\n        content: content,\n        element: element\n      };\n    }\n    \n    function findRenderingFunctionAndRender(content) {\n      var contentRenderingFunction = contentRenderingFunctions.find( typeRangeFilter(content.type) );\n      \n      if (!contentRenderingFunction) {\n        throw new Error(\"No content rendering functions are available to render type: \" + content.type);  \n      }\n      \n      return Q(content)\n        .then(contentRenderingFunction.fn)\n        .then(function (element) {\n          var functionName = contentRenderingFunction.fn.name;\n          if (!element) throw new Error(\"The content rendering function failed to return an element: \" + functionName);\n          \n          element.dataset.renderingTypeRange = contentRenderingFunction.typeRange;\n          return element;\n        });\n    }\n    \n    var promise = Q(content)\n      .then(ensureTypeAttribute)\n      .then(function (expandedContent) {\n        content = expandedContent;\n        return content;\n      })\n      .then(findRenderingFunctionAndRender)\n      .then(createResult);\n      \n    return postContentRenderingFunctions.reduce(Q.when, promise);\n  }\n\n  function addContentRenderingFunction(typeRange, contentRenderingFunction) {\n    contentRenderingFunctions.push({\n      typeRange: typeRange,\n      fn: contentRenderingFunction\n    });\n  }\n\n  function addPostContentRenderingFunction(postContentRenderingFunction) {\n    postContentRenderingFunctions.push(postContentRenderingFunction);\n  }\n\n  renderContent.add = addContentRenderingFunction;\n  renderContent.after = addPostContentRenderingFunction;\n\n  return renderContent;\n};\n\n},{\"content-type\":126,\"q\":134}],77:[function(require,module,exports){\nvar Q = require(\"q\");\nvar util = require(\"util\");\n\nmodule.exports = exports = function (app) {\n\n  var getTransitionPromiseHandlers = require(\"./get-transition-promise-handlers\")(app);\n\n  return function send(url, options) {\n\n    options = options || {};\n    options.transition = new Date().valueOf();\n\n    function encode() {\n      if (options.body) return options.body;\n      if (options.formdata) return app.encoding(options.formdata, options.enctype);\n      return null;\n    }\n\n    function transfer(content) {\n      options.body = content;\n      return app.transferring(url, options);\n    }\n\n    function finish(result) {\n      result.options = options;\n      return app.finishing(result);\n    }\n\n    var promise = Q();\n\n    var transitions = getTransitionPromiseHandlers(options.transition);\n    promise.then(transitions.starting);\n\n    if (options.delay) {\n      promise = promise.delay(options.delay);\n    }\n    \n    function onRejected(err) {\n      var message = [];\n      message.push(\"URL:\");\n      message.push(href);\n      message.push(\"Content:\");\n      message.push(err.message);\n      err.message = message.join(\"\\n\");\n      \n      app.error(err);\n      throw err;\n    }\n\n    return promise.then(encode)\n      .then(transfer)\n      .then(app.rendering)\n      .then(finish)\n      .fail(onRejected)\n      .finally(transitions.ending);\n  };\n};\n\n},{\"./get-transition-promise-handlers\":74,\"q\":134,\"util\":113}],78:[function(require,module,exports){\nvar Q = require(\"q\");\nvar URI = require(\"urijs\");\n\nvar transferringFunctions = [];\n\nfunction protocolFilter(protocol) {\n  return function (transferringFunction) {\n    return transferringFunction.protocol === protocol;\n  };\n}\n\nfunction transfer(url, options) {\n  var protocol = URI(url).protocol();\n  if (!protocol) throw new Error(\"Missing protocol scheme in URL: '\" + url + \"'\");\n  \n  var transferringFunction = transferringFunctions.find( protocolFilter(protocol) );\n  if (!transferringFunction) throw new Error(\"No transferring functions are available for protocol: '\" + protocol + \"'\");\n  \n  return Q.spread([url, options], transferringFunction.fn);\n}\n\nfunction addTransferringFunction(protocol, transferringFunction) {\n  transferringFunctions.push({\n    protocol: protocol,\n    fn: transferringFunction\n  });\n}\n\ntransfer.add = addTransferringFunction;\n\nmodule.exports = exports = function (/*app*/) {\n  return transfer;\n};\n\n},{\"q\":134,\"urijs\":141}],79:[function(require,module,exports){\n\n},{}],80:[function(require,module,exports){\n(function (global){\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\nvar isArray = require('is-array')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\nBuffer.poolSize = 8192 // not used by this implementation\n\nvar rootParent = {}\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Safari 5-7 lacks support for changing the `Object.prototype.constructor` property\n *     on objects.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : (function () {\n      function Bar () {}\n      try {\n        var arr = new Uint8Array(1)\n        arr.foo = function () { return 42 }\n        arr.constructor = Bar\n        return arr.foo() === 42 && // typed array instances can be augmented\n            arr.constructor === Bar && // constructor can be set\n            typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n            arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n      } catch (e) {\n        return false\n      }\n    })()\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\n/**\n * Class: Buffer\n * =============\n *\n * The Buffer constructor returns instances of `Uint8Array` that are augmented\n * with function properties for all the node `Buffer` API functions. We use\n * `Uint8Array` so that square bracket notation works as expected -- it returns\n * a single octet.\n *\n * By augmenting the instances, we can avoid modifying the `Uint8Array`\n * prototype.\n */\nfunction Buffer (arg) {\n  if (!(this instanceof Buffer)) {\n    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.\n    if (arguments.length > 1) return new Buffer(arg, arguments[1])\n    return new Buffer(arg)\n  }\n\n  this.length = 0\n  this.parent = undefined\n\n  // Common case.\n  if (typeof arg === 'number') {\n    return fromNumber(this, arg)\n  }\n\n  // Slightly less common case.\n  if (typeof arg === 'string') {\n    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')\n  }\n\n  // Unusual.\n  return fromObject(this, arg)\n}\n\nfunction fromNumber (that, length) {\n  that = allocate(that, length < 0 ? 0 : checked(length) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < length; i++) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'\n\n  // Assumption: byteLength() return value is always < kMaxLength.\n  var length = byteLength(string, encoding) | 0\n  that = allocate(that, length)\n\n  that.write(string, encoding)\n  return that\n}\n\nfunction fromObject (that, object) {\n  if (Buffer.isBuffer(object)) return fromBuffer(that, object)\n\n  if (isArray(object)) return fromArray(that, object)\n\n  if (object == null) {\n    throw new TypeError('must start with number, buffer, array or string')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined') {\n    if (object.buffer instanceof ArrayBuffer) {\n      return fromTypedArray(that, object)\n    }\n    if (object instanceof ArrayBuffer) {\n      return fromArrayBuffer(that, object)\n    }\n  }\n\n  if (object.length) return fromArrayLike(that, object)\n\n  return fromJsonObject(that, object)\n}\n\nfunction fromBuffer (that, buffer) {\n  var length = checked(buffer.length) | 0\n  that = allocate(that, length)\n  buffer.copy(that, 0, 0, length)\n  return that\n}\n\nfunction fromArray (that, array) {\n  var length = checked(array.length) | 0\n  that = allocate(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\n// Duplicate of fromArray() to keep fromArray() monomorphic.\nfunction fromTypedArray (that, array) {\n  var length = checked(array.length) | 0\n  that = allocate(that, length)\n  // Truncating the elements is probably not what people expect from typed\n  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior\n  // of the old Buffer constructor.\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array) {\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    array.byteLength\n    that = Buffer._augment(new Uint8Array(array))\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromTypedArray(that, new Uint8Array(array))\n  }\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = checked(array.length) | 0\n  that = allocate(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\n// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.\n// Returns a zero-length buffer for inputs that don't conform to the spec.\nfunction fromJsonObject (that, object) {\n  var array\n  var length = 0\n\n  if (object.type === 'Buffer' && isArray(object.data)) {\n    array = object.data\n    length = checked(array.length) | 0\n  }\n  that = allocate(that, length)\n\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n}\n\nfunction allocate (that, length) {\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = Buffer._augment(new Uint8Array(length))\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that.length = length\n    that._isBuffer = true\n  }\n\n  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1\n  if (fromPool) that.parent = rootParent\n\n  return that\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (subject, encoding) {\n  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)\n\n  var buf = new Buffer(subject, encoding)\n  delete buf.parent\n  return buf\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  var i = 0\n  var len = Math.min(x, y)\n  while (i < len) {\n    if (a[i] !== b[i]) break\n\n    ++i\n  }\n\n  if (i !== len) {\n    x = a[i]\n    y = b[i]\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'binary':\n    case 'base64':\n    case 'raw':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')\n\n  if (list.length === 0) {\n    return new Buffer(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; i++) {\n      length += list[i].length\n    }\n  }\n\n  var buf = new Buffer(length)\n  var pos = 0\n  for (i = 0; i < list.length; i++) {\n    var item = list[i]\n    item.copy(buf, pos)\n    pos += item.length\n  }\n  return buf\n}\n\nfunction byteLength (string, encoding) {\n  if (typeof string !== 'string') string = '' + string\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'binary':\n      // Deprecated\n      case 'raw':\n      case 'raws':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\n// pre-set for values that may exist in the future\nBuffer.prototype.length = undefined\nBuffer.prototype.parent = undefined\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  start = start | 0\n  end = end === undefined || end === Infinity ? this.length : end | 0\n\n  if (!encoding) encoding = 'utf8'\n  if (start < 0) start = 0\n  if (end > this.length) end = this.length\n  if (end <= start) return ''\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'binary':\n        return binarySlice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return 0\n  return Buffer.compare(this, b)\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset) {\n  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff\n  else if (byteOffset < -0x80000000) byteOffset = -0x80000000\n  byteOffset >>= 0\n\n  if (this.length === 0) return -1\n  if (byteOffset >= this.length) return -1\n\n  // Negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)\n\n  if (typeof val === 'string') {\n    if (val.length === 0) return -1 // special case: looking for empty string always fails\n    return String.prototype.indexOf.call(this, val, byteOffset)\n  }\n  if (Buffer.isBuffer(val)) {\n    return arrayIndexOf(this, val, byteOffset)\n  }\n  if (typeof val === 'number') {\n    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {\n      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)\n    }\n    return arrayIndexOf(this, [ val ], byteOffset)\n  }\n\n  function arrayIndexOf (arr, val, byteOffset) {\n    var foundIndex = -1\n    for (var i = 0; byteOffset + i < arr.length; i++) {\n      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex\n      } else {\n        foundIndex = -1\n      }\n    }\n    return -1\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\n// `get` is deprecated\nBuffer.prototype.get = function get (offset) {\n  console.log('.get() is deprecated. Access using array indexes instead.')\n  return this.readUInt8(offset)\n}\n\n// `set` is deprecated\nBuffer.prototype.set = function set (v, offset) {\n  console.log('.set() is deprecated. Access using array indexes instead.')\n  return this.writeUInt8(v, offset)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new Error('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; i++) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) throw new Error('Invalid hex string')\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction binaryWrite (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    var swap = encoding\n    encoding = offset\n    offset = length | 0\n    length = swap\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'binary':\n        return binaryWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; i++) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction binarySlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; i++) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; i++) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = Buffer._augment(this.subarray(start, end))\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; i++) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  if (newBuf.length) newBuf.parent = this.parent || this\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('value is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = value\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = value\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = value\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = value\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = value\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = value < 0 ? 1 : 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = value < 0 ? 1 : 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = value\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = value\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = value\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = value\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = value\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (value > max || value < min) throw new RangeError('value is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('index out of range')\n  if (offset < 0) throw new RangeError('index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; i--) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; i++) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    target._set(this.subarray(start, start + len), targetStart)\n  }\n\n  return len\n}\n\n// fill(value, start=0, end=buffer.length)\nBuffer.prototype.fill = function fill (value, start, end) {\n  if (!value) value = 0\n  if (!start) start = 0\n  if (!end) end = this.length\n\n  if (end < start) throw new RangeError('end < start')\n\n  // Fill 0 bytes; we're done\n  if (end === start) return\n  if (this.length === 0) return\n\n  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')\n  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')\n\n  var i\n  if (typeof value === 'number') {\n    for (i = start; i < end; i++) {\n      this[i] = value\n    }\n  } else {\n    var bytes = utf8ToBytes(value.toString())\n    var len = bytes.length\n    for (i = start; i < end; i++) {\n      this[i] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n/**\n * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.\n * Added in Node 0.12. Only available in browsers that support ArrayBuffer.\n */\nBuffer.prototype.toArrayBuffer = function toArrayBuffer () {\n  if (typeof Uint8Array !== 'undefined') {\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n      return (new Buffer(this)).buffer\n    } else {\n      var buf = new Uint8Array(this.length)\n      for (var i = 0, len = buf.length; i < len; i += 1) {\n        buf[i] = this[i]\n      }\n      return buf.buffer\n    }\n  } else {\n    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')\n  }\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar BP = Buffer.prototype\n\n/**\n * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods\n */\nBuffer._augment = function _augment (arr) {\n  arr.constructor = Buffer\n  arr._isBuffer = true\n\n  // save reference to original Uint8Array set method before overwriting\n  arr._set = arr.set\n\n  // deprecated\n  arr.get = BP.get\n  arr.set = BP.set\n\n  arr.write = BP.write\n  arr.toString = BP.toString\n  arr.toLocaleString = BP.toString\n  arr.toJSON = BP.toJSON\n  arr.equals = BP.equals\n  arr.compare = BP.compare\n  arr.indexOf = BP.indexOf\n  arr.copy = BP.copy\n  arr.slice = BP.slice\n  arr.readUIntLE = BP.readUIntLE\n  arr.readUIntBE = BP.readUIntBE\n  arr.readUInt8 = BP.readUInt8\n  arr.readUInt16LE = BP.readUInt16LE\n  arr.readUInt16BE = BP.readUInt16BE\n  arr.readUInt32LE = BP.readUInt32LE\n  arr.readUInt32BE = BP.readUInt32BE\n  arr.readIntLE = BP.readIntLE\n  arr.readIntBE = BP.readIntBE\n  arr.readInt8 = BP.readInt8\n  arr.readInt16LE = BP.readInt16LE\n  arr.readInt16BE = BP.readInt16BE\n  arr.readInt32LE = BP.readInt32LE\n  arr.readInt32BE = BP.readInt32BE\n  arr.readFloatLE = BP.readFloatLE\n  arr.readFloatBE = BP.readFloatBE\n  arr.readDoubleLE = BP.readDoubleLE\n  arr.readDoubleBE = BP.readDoubleBE\n  arr.writeUInt8 = BP.writeUInt8\n  arr.writeUIntLE = BP.writeUIntLE\n  arr.writeUIntBE = BP.writeUIntBE\n  arr.writeUInt16LE = BP.writeUInt16LE\n  arr.writeUInt16BE = BP.writeUInt16BE\n  arr.writeUInt32LE = BP.writeUInt32LE\n  arr.writeUInt32BE = BP.writeUInt32BE\n  arr.writeIntLE = BP.writeIntLE\n  arr.writeIntBE = BP.writeIntBE\n  arr.writeInt8 = BP.writeInt8\n  arr.writeInt16LE = BP.writeInt16LE\n  arr.writeInt16BE = BP.writeInt16BE\n  arr.writeInt32LE = BP.writeInt32LE\n  arr.writeInt32BE = BP.writeInt32BE\n  arr.writeFloatLE = BP.writeFloatLE\n  arr.writeFloatBE = BP.writeFloatBE\n  arr.writeDoubleLE = BP.writeDoubleLE\n  arr.writeDoubleBE = BP.writeDoubleBE\n  arr.fill = BP.fill\n  arr.inspect = BP.inspect\n  arr.toArrayBuffer = BP.toArrayBuffer\n\n  return arr\n}\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; i++) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00 | 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; i++) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; i++) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; i++) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"base64-js\":81,\"ieee754\":82,\"is-array\":83}],81:[function(require,module,exports){\nvar lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n;(function (exports) {\n\t'use strict';\n\n  var Arr = (typeof Uint8Array !== 'undefined')\n    ? Uint8Array\n    : Array\n\n\tvar PLUS   = '+'.charCodeAt(0)\n\tvar SLASH  = '/'.charCodeAt(0)\n\tvar NUMBER = '0'.charCodeAt(0)\n\tvar LOWER  = 'a'.charCodeAt(0)\n\tvar UPPER  = 'A'.charCodeAt(0)\n\tvar PLUS_URL_SAFE = '-'.charCodeAt(0)\n\tvar SLASH_URL_SAFE = '_'.charCodeAt(0)\n\n\tfunction decode (elt) {\n\t\tvar code = elt.charCodeAt(0)\n\t\tif (code === PLUS ||\n\t\t    code === PLUS_URL_SAFE)\n\t\t\treturn 62 // '+'\n\t\tif (code === SLASH ||\n\t\t    code === SLASH_URL_SAFE)\n\t\t\treturn 63 // '/'\n\t\tif (code < NUMBER)\n\t\t\treturn -1 //no match\n\t\tif (code < NUMBER + 10)\n\t\t\treturn code - NUMBER + 26 + 26\n\t\tif (code < UPPER + 26)\n\t\t\treturn code - UPPER\n\t\tif (code < LOWER + 26)\n\t\t\treturn code - LOWER + 26\n\t}\n\n\tfunction b64ToByteArray (b64) {\n\t\tvar i, j, l, tmp, placeHolders, arr\n\n\t\tif (b64.length % 4 > 0) {\n\t\t\tthrow new Error('Invalid string. Length must be a multiple of 4')\n\t\t}\n\n\t\t// the number of equal signs (place holders)\n\t\t// if there are two placeholders, than the two characters before it\n\t\t// represent one byte\n\t\t// if there is only one, then the three characters before it represent 2 bytes\n\t\t// this is just a cheap hack to not do indexOf twice\n\t\tvar len = b64.length\n\t\tplaceHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0\n\n\t\t// base64 is 4/3 + up to two characters of the original data\n\t\tarr = new Arr(b64.length * 3 / 4 - placeHolders)\n\n\t\t// if there are placeholders, only get up to the last complete 4 chars\n\t\tl = placeHolders > 0 ? b64.length - 4 : b64.length\n\n\t\tvar L = 0\n\n\t\tfunction push (v) {\n\t\t\tarr[L++] = v\n\t\t}\n\n\t\tfor (i = 0, j = 0; i < l; i += 4, j += 3) {\n\t\t\ttmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))\n\t\t\tpush((tmp & 0xFF0000) >> 16)\n\t\t\tpush((tmp & 0xFF00) >> 8)\n\t\t\tpush(tmp & 0xFF)\n\t\t}\n\n\t\tif (placeHolders === 2) {\n\t\t\ttmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)\n\t\t\tpush(tmp & 0xFF)\n\t\t} else if (placeHolders === 1) {\n\t\t\ttmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)\n\t\t\tpush((tmp >> 8) & 0xFF)\n\t\t\tpush(tmp & 0xFF)\n\t\t}\n\n\t\treturn arr\n\t}\n\n\tfunction uint8ToBase64 (uint8) {\n\t\tvar i,\n\t\t\textraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes\n\t\t\toutput = \"\",\n\t\t\ttemp, length\n\n\t\tfunction encode (num) {\n\t\t\treturn lookup.charAt(num)\n\t\t}\n\n\t\tfunction tripletToBase64 (num) {\n\t\t\treturn encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)\n\t\t}\n\n\t\t// go through the array every three bytes, we'll deal with trailing stuff later\n\t\tfor (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {\n\t\t\ttemp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n\t\t\toutput += tripletToBase64(temp)\n\t\t}\n\n\t\t// pad the end with zeros, but make sure to not forget the extra bytes\n\t\tswitch (extraBytes) {\n\t\t\tcase 1:\n\t\t\t\ttemp = uint8[uint8.length - 1]\n\t\t\t\toutput += encode(temp >> 2)\n\t\t\t\toutput += encode((temp << 4) & 0x3F)\n\t\t\t\toutput += '=='\n\t\t\t\tbreak\n\t\t\tcase 2:\n\t\t\t\ttemp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])\n\t\t\t\toutput += encode(temp >> 10)\n\t\t\t\toutput += encode((temp >> 4) & 0x3F)\n\t\t\t\toutput += encode((temp << 2) & 0x3F)\n\t\t\t\toutput += '='\n\t\t\t\tbreak\n\t\t}\n\n\t\treturn output\n\t}\n\n\texports.toByteArray = b64ToByteArray\n\texports.fromByteArray = uint8ToBase64\n}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))\n\n},{}],82:[function(require,module,exports){\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n},{}],83:[function(require,module,exports){\n\n/**\n * isArray\n */\n\nvar isArray = Array.isArray;\n\n/**\n * toString\n */\n\nvar str = Object.prototype.toString;\n\n/**\n * Whether or not the given `val`\n * is an array.\n *\n * example:\n *\n *        isArray([]);\n *        // > true\n *        isArray(arguments);\n *        // > false\n *        isArray('');\n *        // > false\n *\n * @param {mixed} val\n * @return {bool}\n */\n\nmodule.exports = isArray || function (val) {\n  return !! val && '[object Array]' == str.call(val);\n};\n\n},{}],84:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      }\n      throw TypeError('Uncaught, unspecified \"error\" event.');\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        len = arguments.length;\n        args = new Array(len - 1);\n        for (i = 1; i < len; i++)\n          args[i - 1] = arguments[i];\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    len = arguments.length;\n    args = new Array(len - 1);\n    for (i = 1; i < len; i++)\n      args[i - 1] = arguments[i];\n\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    var m;\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  var ret;\n  if (!emitter._events || !emitter._events[type])\n    ret = 0;\n  else if (isFunction(emitter._events[type]))\n    ret = 1;\n  else\n    ret = emitter._events[type].length;\n  return ret;\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n\n},{}],85:[function(require,module,exports){\nvar http = module.exports;\nvar EventEmitter = require('events').EventEmitter;\nvar Request = require('./lib/request');\nvar url = require('url')\n\nhttp.request = function (params, cb) {\n    if (typeof params === 'string') {\n        params = url.parse(params)\n    }\n    if (!params) params = {};\n    if (!params.host && !params.port) {\n        params.port = parseInt(window.location.port, 10);\n    }\n    if (!params.host && params.hostname) {\n        params.host = params.hostname;\n    }\n\n    if (!params.protocol) {\n        if (params.scheme) {\n            params.protocol = params.scheme + ':';\n        } else {\n            params.protocol = window.location.protocol;\n        }\n    }\n\n    if (!params.host) {\n        params.host = window.location.hostname || window.location.host;\n    }\n    if (/:/.test(params.host)) {\n        if (!params.port) {\n            params.port = params.host.split(':')[1];\n        }\n        params.host = params.host.split(':')[0];\n    }\n    if (!params.port) params.port = params.protocol == 'https:' ? 443 : 80;\n    \n    var req = new Request(new xhrHttp, params);\n    if (cb) req.on('response', cb);\n    return req;\n};\n\nhttp.get = function (params, cb) {\n    params.method = 'GET';\n    var req = http.request(params, cb);\n    req.end();\n    return req;\n};\n\nhttp.Agent = function () {};\nhttp.Agent.defaultMaxSockets = 4;\n\nvar xhrHttp = (function () {\n    if (typeof window === 'undefined') {\n        throw new Error('no window object present');\n    }\n    else if (window.XMLHttpRequest) {\n        return window.XMLHttpRequest;\n    }\n    else if (window.ActiveXObject) {\n        var axs = [\n            'Msxml2.XMLHTTP.6.0',\n            'Msxml2.XMLHTTP.3.0',\n            'Microsoft.XMLHTTP'\n        ];\n        for (var i = 0; i < axs.length; i++) {\n            try {\n                var ax = new(window.ActiveXObject)(axs[i]);\n                return function () {\n                    if (ax) {\n                        var ax_ = ax;\n                        ax = null;\n                        return ax_;\n                    }\n                    else {\n                        return new(window.ActiveXObject)(axs[i]);\n                    }\n                };\n            }\n            catch (e) {}\n        }\n        throw new Error('ajax not supported in this browser')\n    }\n    else {\n        throw new Error('ajax not supported in this browser');\n    }\n})();\n\nhttp.STATUS_CODES = {\n    100 : 'Continue',\n    101 : 'Switching Protocols',\n    102 : 'Processing',                 // RFC 2518, obsoleted by RFC 4918\n    200 : 'OK',\n    201 : 'Created',\n    202 : 'Accepted',\n    203 : 'Non-Authoritative Information',\n    204 : 'No Content',\n    205 : 'Reset Content',\n    206 : 'Partial Content',\n    207 : 'Multi-Status',               // RFC 4918\n    300 : 'Multiple Choices',\n    301 : 'Moved Permanently',\n    302 : 'Moved Temporarily',\n    303 : 'See Other',\n    304 : 'Not Modified',\n    305 : 'Use Proxy',\n    307 : 'Temporary Redirect',\n    400 : 'Bad Request',\n    401 : 'Unauthorized',\n    402 : 'Payment Required',\n    403 : 'Forbidden',\n    404 : 'Not Found',\n    405 : 'Method Not Allowed',\n    406 : 'Not Acceptable',\n    407 : 'Proxy Authentication Required',\n    408 : 'Request Time-out',\n    409 : 'Conflict',\n    410 : 'Gone',\n    411 : 'Length Required',\n    412 : 'Precondition Failed',\n    413 : 'Request Entity Too Large',\n    414 : 'Request-URI Too Large',\n    415 : 'Unsupported Media Type',\n    416 : 'Requested Range Not Satisfiable',\n    417 : 'Expectation Failed',\n    418 : 'I\\'m a teapot',              // RFC 2324\n    422 : 'Unprocessable Entity',       // RFC 4918\n    423 : 'Locked',                     // RFC 4918\n    424 : 'Failed Dependency',          // RFC 4918\n    425 : 'Unordered Collection',       // RFC 4918\n    426 : 'Upgrade Required',           // RFC 2817\n    428 : 'Precondition Required',      // RFC 6585\n    429 : 'Too Many Requests',          // RFC 6585\n    431 : 'Request Header Fields Too Large',// RFC 6585\n    500 : 'Internal Server Error',\n    501 : 'Not Implemented',\n    502 : 'Bad Gateway',\n    503 : 'Service Unavailable',\n    504 : 'Gateway Time-out',\n    505 : 'HTTP Version Not Supported',\n    506 : 'Variant Also Negotiates',    // RFC 2295\n    507 : 'Insufficient Storage',       // RFC 4918\n    509 : 'Bandwidth Limit Exceeded',\n    510 : 'Not Extended',               // RFC 2774\n    511 : 'Network Authentication Required' // RFC 6585\n};\n},{\"./lib/request\":86,\"events\":84,\"url\":111}],86:[function(require,module,exports){\nvar Stream = require('stream');\nvar Response = require('./response');\nvar Base64 = require('Base64');\nvar inherits = require('inherits');\n\nvar Request = module.exports = function (xhr, params) {\n    var self = this;\n    self.writable = true;\n    self.xhr = xhr;\n    self.body = [];\n    \n    self.uri = (params.protocol || 'http:') + '//'\n        + params.host\n        + (params.port ? ':' + params.port : '')\n        + (params.path || '/')\n    ;\n    \n    if (typeof params.withCredentials === 'undefined') {\n        params.withCredentials = true;\n    }\n\n    try { xhr.withCredentials = params.withCredentials }\n    catch (e) {}\n    \n    if (params.responseType) try { xhr.responseType = params.responseType }\n    catch (e) {}\n    \n    xhr.open(\n        params.method || 'GET',\n        self.uri,\n        true\n    );\n\n    xhr.onerror = function(event) {\n        self.emit('error', new Error('Network error'));\n    };\n\n    self._headers = {};\n    \n    if (params.headers) {\n        var keys = objectKeys(params.headers);\n        for (var i = 0; i < keys.length; i++) {\n            var key = keys[i];\n            if (!self.isSafeRequestHeader(key)) continue;\n            var value = params.headers[key];\n            self.setHeader(key, value);\n        }\n    }\n    \n    if (params.auth) {\n        //basic auth\n        this.setHeader('Authorization', 'Basic ' + Base64.btoa(params.auth));\n    }\n\n    var res = new Response;\n    res.on('close', function () {\n        self.emit('close');\n    });\n    \n    res.on('ready', function () {\n        self.emit('response', res);\n    });\n\n    res.on('error', function (err) {\n        self.emit('error', err);\n    });\n    \n    xhr.onreadystatechange = function () {\n        // Fix for IE9 bug\n        // SCRIPT575: Could not complete the operation due to error c00c023f\n        // It happens when a request is aborted, calling the success callback anyway with readyState === 4\n        if (xhr.__aborted) return;\n        res.handle(xhr);\n    };\n};\n\ninherits(Request, Stream);\n\nRequest.prototype.setHeader = function (key, value) {\n    this._headers[key.toLowerCase()] = value\n};\n\nRequest.prototype.getHeader = function (key) {\n    return this._headers[key.toLowerCase()]\n};\n\nRequest.prototype.removeHeader = function (key) {\n    delete this._headers[key.toLowerCase()]\n};\n\nRequest.prototype.write = function (s) {\n    this.body.push(s);\n};\n\nRequest.prototype.destroy = function (s) {\n    this.xhr.__aborted = true;\n    this.xhr.abort();\n    this.emit('close');\n};\n\nRequest.prototype.end = function (s) {\n    if (s !== undefined) this.body.push(s);\n\n    var keys = objectKeys(this._headers);\n    for (var i = 0; i < keys.length; i++) {\n        var key = keys[i];\n        var value = this._headers[key];\n        if (isArray(value)) {\n            for (var j = 0; j < value.length; j++) {\n                this.xhr.setRequestHeader(key, value[j]);\n            }\n        }\n        else this.xhr.setRequestHeader(key, value)\n    }\n\n    if (this.body.length === 0) {\n        this.xhr.send('');\n    }\n    else if (typeof this.body[0] === 'string') {\n        this.xhr.send(this.body.join(''));\n    }\n    else if (isArray(this.body[0])) {\n        var body = [];\n        for (var i = 0; i < this.body.length; i++) {\n            body.push.apply(body, this.body[i]);\n        }\n        this.xhr.send(body);\n    }\n    else if (/Array/.test(Object.prototype.toString.call(this.body[0]))) {\n        var len = 0;\n        for (var i = 0; i < this.body.length; i++) {\n            len += this.body[i].length;\n        }\n        var body = new(this.body[0].constructor)(len);\n        var k = 0;\n        \n        for (var i = 0; i < this.body.length; i++) {\n            var b = this.body[i];\n            for (var j = 0; j < b.length; j++) {\n                body[k++] = b[j];\n            }\n        }\n        this.xhr.send(body);\n    }\n    else if (isXHR2Compatible(this.body[0])) {\n        this.xhr.send(this.body[0]);\n    }\n    else {\n        var body = '';\n        for (var i = 0; i < this.body.length; i++) {\n            body += this.body[i].toString();\n        }\n        this.xhr.send(body);\n    }\n};\n\n// Taken from http://dxr.mozilla.org/mozilla/mozilla-central/content/base/src/nsXMLHttpRequest.cpp.html\nRequest.unsafeHeaders = [\n    \"accept-charset\",\n    \"accept-encoding\",\n    \"access-control-request-headers\",\n    \"access-control-request-method\",\n    \"connection\",\n    \"content-length\",\n    \"cookie\",\n    \"cookie2\",\n    \"content-transfer-encoding\",\n    \"date\",\n    \"expect\",\n    \"host\",\n    \"keep-alive\",\n    \"origin\",\n    \"referer\",\n    \"te\",\n    \"trailer\",\n    \"transfer-encoding\",\n    \"upgrade\",\n    \"user-agent\",\n    \"via\"\n];\n\nRequest.prototype.isSafeRequestHeader = function (headerName) {\n    if (!headerName) return false;\n    return indexOf(Request.unsafeHeaders, headerName.toLowerCase()) === -1;\n};\n\nvar objectKeys = Object.keys || function (obj) {\n    var keys = [];\n    for (var key in obj) keys.push(key);\n    return keys;\n};\n\nvar isArray = Array.isArray || function (xs) {\n    return Object.prototype.toString.call(xs) === '[object Array]';\n};\n\nvar indexOf = function (xs, x) {\n    if (xs.indexOf) return xs.indexOf(x);\n    for (var i = 0; i < xs.length; i++) {\n        if (xs[i] === x) return i;\n    }\n    return -1;\n};\n\nvar isXHR2Compatible = function (obj) {\n    if (typeof Blob !== 'undefined' && obj instanceof Blob) return true;\n    if (typeof ArrayBuffer !== 'undefined' && obj instanceof ArrayBuffer) return true;\n    if (typeof FormData !== 'undefined' && obj instanceof FormData) return true;\n};\n\n},{\"./response\":87,\"Base64\":88,\"inherits\":90,\"stream\":109}],87:[function(require,module,exports){\nvar Stream = require('stream');\nvar util = require('util');\n\nvar Response = module.exports = function (res) {\n    this.offset = 0;\n    this.readable = true;\n};\n\nutil.inherits(Response, Stream);\n\nvar capable = {\n    streaming : true,\n    status2 : true\n};\n\nfunction parseHeaders (res) {\n    var lines = res.getAllResponseHeaders().split(/\\r?\\n/);\n    var headers = {};\n    for (var i = 0; i < lines.length; i++) {\n        var line = lines[i];\n        if (line === '') continue;\n        \n        var m = line.match(/^([^:]+):\\s*(.*)/);\n        if (m) {\n            var key = m[1].toLowerCase(), value = m[2];\n            \n            if (headers[key] !== undefined) {\n            \n                if (isArray(headers[key])) {\n                    headers[key].push(value);\n                }\n                else {\n                    headers[key] = [ headers[key], value ];\n                }\n            }\n            else {\n                headers[key] = value;\n            }\n        }\n        else {\n            headers[line] = true;\n        }\n    }\n    return headers;\n}\n\nResponse.prototype.getResponse = function (xhr) {\n    var respType = String(xhr.responseType).toLowerCase();\n    if (respType === 'blob') return xhr.responseBlob || xhr.response;\n    if (respType === 'arraybuffer') return xhr.response;\n    return xhr.responseText;\n}\n\nResponse.prototype.getHeader = function (key) {\n    return this.headers[key.toLowerCase()];\n};\n\nResponse.prototype.handle = function (res) {\n    if (res.readyState === 2 && capable.status2) {\n        try {\n            this.statusCode = res.status;\n            this.headers = parseHeaders(res);\n        }\n        catch (err) {\n            capable.status2 = false;\n        }\n        \n        if (capable.status2) {\n            this.emit('ready');\n        }\n    }\n    else if (capable.streaming && res.readyState === 3) {\n        try {\n            if (!this.statusCode) {\n                this.statusCode = res.status;\n                this.headers = parseHeaders(res);\n                this.emit('ready');\n            }\n        }\n        catch (err) {}\n        \n        try {\n            this._emitData(res);\n        }\n        catch (err) {\n            capable.streaming = false;\n        }\n    }\n    else if (res.readyState === 4) {\n        if (!this.statusCode) {\n            this.statusCode = res.status;\n            this.emit('ready');\n        }\n        this._emitData(res);\n        \n        if (res.error) {\n            this.emit('error', this.getResponse(res));\n        }\n        else this.emit('end');\n        \n        this.emit('close');\n    }\n};\n\nResponse.prototype._emitData = function (res) {\n    var respBody = this.getResponse(res);\n    if (respBody.toString().match(/ArrayBuffer/)) {\n        this.emit('data', new Uint8Array(respBody, this.offset));\n        this.offset = respBody.byteLength;\n        return;\n    }\n    if (respBody.length > this.offset) {\n        this.emit('data', respBody.slice(this.offset));\n        this.offset = respBody.length;\n    }\n};\n\nvar isArray = Array.isArray || function (xs) {\n    return Object.prototype.toString.call(xs) === '[object Array]';\n};\n\n},{\"stream\":109,\"util\":113}],88:[function(require,module,exports){\n;(function () {\n\n  var object = typeof exports != 'undefined' ? exports : this; // #8: web workers\n  var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\n  function InvalidCharacterError(message) {\n    this.message = message;\n  }\n  InvalidCharacterError.prototype = new Error;\n  InvalidCharacterError.prototype.name = 'InvalidCharacterError';\n\n  // encoder\n  // [https://gist.github.com/999166] by [https://github.com/nignag]\n  object.btoa || (\n  object.btoa = function (input) {\n    for (\n      // initialize result and counter\n      var block, charCode, idx = 0, map = chars, output = '';\n      // if the next input index does not exist:\n      //   change the mapping table to \"=\"\n      //   check if d has no fractional digits\n      input.charAt(idx | 0) || (map = '=', idx % 1);\n      // \"8 - idx % 1 * 8\" generates the sequence 2, 4, 6, 8\n      output += map.charAt(63 & block >> 8 - idx % 1 * 8)\n    ) {\n      charCode = input.charCodeAt(idx += 3/4);\n      if (charCode > 0xFF) {\n        throw new InvalidCharacterError(\"'btoa' failed: The string to be encoded contains characters outside of the Latin1 range.\");\n      }\n      block = block << 8 | charCode;\n    }\n    return output;\n  });\n\n  // decoder\n  // [https://gist.github.com/1020396] by [https://github.com/atk]\n  object.atob || (\n  object.atob = function (input) {\n    input = input.replace(/=+$/, '');\n    if (input.length % 4 == 1) {\n      throw new InvalidCharacterError(\"'atob' failed: The string to be decoded is not correctly encoded.\");\n    }\n    for (\n      // initialize result and counters\n      var bc = 0, bs, buffer, idx = 0, output = '';\n      // get next character\n      buffer = input.charAt(idx++);\n      // character found in table? initialize bit storage and add its ascii value;\n      ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer,\n        // and if not first of each 4 characters,\n        // convert the first 8 bits to one ascii character\n        bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0\n    ) {\n      // try to find character in table (0-63, not found => -1)\n      buffer = chars.indexOf(buffer);\n    }\n    return output;\n  });\n\n}());\n\n},{}],89:[function(require,module,exports){\nvar http = require('http');\n\nvar https = module.exports;\n\nfor (var key in http) {\n    if (http.hasOwnProperty(key)) https[key] = http[key];\n};\n\nhttps.request = function (params, cb) {\n    if (!params) params = {};\n    params.scheme = 'https';\n    params.protocol = 'https:';\n    return http.request.call(this, params, cb);\n}\n\n},{\"http\":85}],90:[function(require,module,exports){\nif (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n\n},{}],91:[function(require,module,exports){\n/**\n * Determine if an object is Buffer\n *\n * Author:   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * License:  MIT\n *\n * `npm install is-buffer`\n */\n\nmodule.exports = function (obj) {\n  return !!(obj != null &&\n    (obj._isBuffer || // For Safari 5-7 (missing Object.prototype.constructor)\n      (obj.constructor &&\n      typeof obj.constructor.isBuffer === 'function' &&\n      obj.constructor.isBuffer(obj))\n    ))\n}\n\n},{}],92:[function(require,module,exports){\nmodule.exports = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]';\n};\n\n},{}],93:[function(require,module,exports){\n// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = setTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    clearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n},{}],94:[function(require,module,exports){\n(function (global){\n/*! https://mths.be/punycode v1.3.2 by @mathias */\n;(function(root) {\n\n\t/** Detect free variables */\n\tvar freeExports = typeof exports == 'object' && exports &&\n\t\t!exports.nodeType && exports;\n\tvar freeModule = typeof module == 'object' && module &&\n\t\t!module.nodeType && module;\n\tvar freeGlobal = typeof global == 'object' && global;\n\tif (\n\t\tfreeGlobal.global === freeGlobal ||\n\t\tfreeGlobal.window === freeGlobal ||\n\t\tfreeGlobal.self === freeGlobal\n\t) {\n\t\troot = freeGlobal;\n\t}\n\n\t/**\n\t * The `punycode` object.\n\t * @name punycode\n\t * @type Object\n\t */\n\tvar punycode,\n\n\t/** Highest positive signed 32-bit float value */\n\tmaxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1\n\n\t/** Bootstring parameters */\n\tbase = 36,\n\ttMin = 1,\n\ttMax = 26,\n\tskew = 38,\n\tdamp = 700,\n\tinitialBias = 72,\n\tinitialN = 128, // 0x80\n\tdelimiter = '-', // '\\x2D'\n\n\t/** Regular expressions */\n\tregexPunycode = /^xn--/,\n\tregexNonASCII = /[^\\x20-\\x7E]/, // unprintable ASCII chars + non-ASCII chars\n\tregexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g, // RFC 3490 separators\n\n\t/** Error messages */\n\terrors = {\n\t\t'overflow': 'Overflow: input needs wider integers to process',\n\t\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t\t'invalid-input': 'Invalid input'\n\t},\n\n\t/** Convenience shortcuts */\n\tbaseMinusTMin = base - tMin,\n\tfloor = Math.floor,\n\tstringFromCharCode = String.fromCharCode,\n\n\t/** Temporary variable */\n\tkey;\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/**\n\t * A generic error utility function.\n\t * @private\n\t * @param {String} type The error type.\n\t * @returns {Error} Throws a `RangeError` with the applicable error message.\n\t */\n\tfunction error(type) {\n\t\tthrow RangeError(errors[type]);\n\t}\n\n\t/**\n\t * A generic `Array#map` utility function.\n\t * @private\n\t * @param {Array} array The array to iterate over.\n\t * @param {Function} callback The function that gets called for every array\n\t * item.\n\t * @returns {Array} A new array of values returned by the callback function.\n\t */\n\tfunction map(array, fn) {\n\t\tvar length = array.length;\n\t\tvar result = [];\n\t\twhile (length--) {\n\t\t\tresult[length] = fn(array[length]);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * A simple `Array#map`-like wrapper to work with domain name strings or email\n\t * addresses.\n\t * @private\n\t * @param {String} domain The domain name or email address.\n\t * @param {Function} callback The function that gets called for every\n\t * character.\n\t * @returns {Array} A new string of characters returned by the callback\n\t * function.\n\t */\n\tfunction mapDomain(string, fn) {\n\t\tvar parts = string.split('@');\n\t\tvar result = '';\n\t\tif (parts.length > 1) {\n\t\t\t// In email addresses, only the domain name should be punycoded. Leave\n\t\t\t// the local part (i.e. everything up to `@`) intact.\n\t\t\tresult = parts[0] + '@';\n\t\t\tstring = parts[1];\n\t\t}\n\t\t// Avoid `split(regex)` for IE8 compatibility. See #17.\n\t\tstring = string.replace(regexSeparators, '\\x2E');\n\t\tvar labels = string.split('.');\n\t\tvar encoded = map(labels, fn).join('.');\n\t\treturn result + encoded;\n\t}\n\n\t/**\n\t * Creates an array containing the numeric code points of each Unicode\n\t * character in the string. While JavaScript uses UCS-2 internally,\n\t * this function will convert a pair of surrogate halves (each of which\n\t * UCS-2 exposes as separate characters) into a single code point,\n\t * matching UTF-16.\n\t * @see `punycode.ucs2.encode`\n\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t * @memberOf punycode.ucs2\n\t * @name decode\n\t * @param {String} string The Unicode input string (UCS-2).\n\t * @returns {Array} The new array of code points.\n\t */\n\tfunction ucs2decode(string) {\n\t\tvar output = [],\n\t\t    counter = 0,\n\t\t    length = string.length,\n\t\t    value,\n\t\t    extra;\n\t\twhile (counter < length) {\n\t\t\tvalue = string.charCodeAt(counter++);\n\t\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t\t// high surrogate, and there is a next character\n\t\t\t\textra = string.charCodeAt(counter++);\n\t\t\t\tif ((extra & 0xFC00) == 0xDC00) { // low surrogate\n\t\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t\t} else {\n\t\t\t\t\t// unmatched surrogate; only append this code unit, in case the next\n\t\t\t\t\t// code unit is the high surrogate of a surrogate pair\n\t\t\t\t\toutput.push(value);\n\t\t\t\t\tcounter--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toutput.push(value);\n\t\t\t}\n\t\t}\n\t\treturn output;\n\t}\n\n\t/**\n\t * Creates a string based on an array of numeric code points.\n\t * @see `punycode.ucs2.decode`\n\t * @memberOf punycode.ucs2\n\t * @name encode\n\t * @param {Array} codePoints The array of numeric code points.\n\t * @returns {String} The new Unicode string (UCS-2).\n\t */\n\tfunction ucs2encode(array) {\n\t\treturn map(array, function(value) {\n\t\t\tvar output = '';\n\t\t\tif (value > 0xFFFF) {\n\t\t\t\tvalue -= 0x10000;\n\t\t\t\toutput += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n\t\t\t\tvalue = 0xDC00 | value & 0x3FF;\n\t\t\t}\n\t\t\toutput += stringFromCharCode(value);\n\t\t\treturn output;\n\t\t}).join('');\n\t}\n\n\t/**\n\t * Converts a basic code point into a digit/integer.\n\t * @see `digitToBasic()`\n\t * @private\n\t * @param {Number} codePoint The basic numeric code point value.\n\t * @returns {Number} The numeric value of a basic code point (for use in\n\t * representing integers) in the range `0` to `base - 1`, or `base` if\n\t * the code point does not represent a value.\n\t */\n\tfunction basicToDigit(codePoint) {\n\t\tif (codePoint - 48 < 10) {\n\t\t\treturn codePoint - 22;\n\t\t}\n\t\tif (codePoint - 65 < 26) {\n\t\t\treturn codePoint - 65;\n\t\t}\n\t\tif (codePoint - 97 < 26) {\n\t\t\treturn codePoint - 97;\n\t\t}\n\t\treturn base;\n\t}\n\n\t/**\n\t * Converts a digit/integer into a basic code point.\n\t * @see `basicToDigit()`\n\t * @private\n\t * @param {Number} digit The numeric value of a basic code point.\n\t * @returns {Number} The basic code point whose value (when used for\n\t * representing integers) is `digit`, which needs to be in the range\n\t * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n\t * used; else, the lowercase form is used. The behavior is undefined\n\t * if `flag` is non-zero and `digit` has no uppercase form.\n\t */\n\tfunction digitToBasic(digit, flag) {\n\t\t//  0..25 map to ASCII a..z or A..Z\n\t\t// 26..35 map to ASCII 0..9\n\t\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n\t}\n\n\t/**\n\t * Bias adaptation function as per section 3.4 of RFC 3492.\n\t * http://tools.ietf.org/html/rfc3492#section-3.4\n\t * @private\n\t */\n\tfunction adapt(delta, numPoints, firstTime) {\n\t\tvar k = 0;\n\t\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\t\tdelta += floor(delta / numPoints);\n\t\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\t\tdelta = floor(delta / baseMinusTMin);\n\t\t}\n\t\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n\t}\n\n\t/**\n\t * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n\t * symbols.\n\t * @memberOf punycode\n\t * @param {String} input The Punycode string of ASCII-only symbols.\n\t * @returns {String} The resulting string of Unicode symbols.\n\t */\n\tfunction decode(input) {\n\t\t// Don't use UCS-2\n\t\tvar output = [],\n\t\t    inputLength = input.length,\n\t\t    out,\n\t\t    i = 0,\n\t\t    n = initialN,\n\t\t    bias = initialBias,\n\t\t    basic,\n\t\t    j,\n\t\t    index,\n\t\t    oldi,\n\t\t    w,\n\t\t    k,\n\t\t    digit,\n\t\t    t,\n\t\t    /** Cached calculation results */\n\t\t    baseMinusT;\n\n\t\t// Handle the basic code points: let `basic` be the number of input code\n\t\t// points before the last delimiter, or `0` if there is none, then copy\n\t\t// the first basic code points to the output.\n\n\t\tbasic = input.lastIndexOf(delimiter);\n\t\tif (basic < 0) {\n\t\t\tbasic = 0;\n\t\t}\n\n\t\tfor (j = 0; j < basic; ++j) {\n\t\t\t// if it's not a basic code point\n\t\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\t\terror('not-basic');\n\t\t\t}\n\t\t\toutput.push(input.charCodeAt(j));\n\t\t}\n\n\t\t// Main decoding loop: start just after the last delimiter if any basic code\n\t\t// points were copied; start at the beginning otherwise.\n\n\t\tfor (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\n\n\t\t\t// `index` is the index of the next character to be consumed.\n\t\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t\t// which gets added to `i`. The overflow checking is easier\n\t\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t\t// value at the end to obtain `delta`.\n\t\t\tfor (oldi = i, w = 1, k = base; /* no condition */; k += base) {\n\n\t\t\t\tif (index >= inputLength) {\n\t\t\t\t\terror('invalid-input');\n\t\t\t\t}\n\n\t\t\t\tdigit = basicToDigit(input.charCodeAt(index++));\n\n\t\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\ti += digit * w;\n\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\n\t\t\t\tif (digit < t) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tbaseMinusT = base - t;\n\t\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tw *= baseMinusT;\n\n\t\t\t}\n\n\t\t\tout = output.length + 1;\n\t\t\tbias = adapt(i - oldi, out, oldi == 0);\n\n\t\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t\t// incrementing `n` each time, so we'll fix that now:\n\t\t\tif (floor(i / out) > maxInt - n) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tn += floor(i / out);\n\t\t\ti %= out;\n\n\t\t\t// Insert `n` at position `i` of the output\n\t\t\toutput.splice(i++, 0, n);\n\n\t\t}\n\n\t\treturn ucs2encode(output);\n\t}\n\n\t/**\n\t * Converts a string of Unicode symbols (e.g. a domain name label) to a\n\t * Punycode string of ASCII-only symbols.\n\t * @memberOf punycode\n\t * @param {String} input The string of Unicode symbols.\n\t * @returns {String} The resulting Punycode string of ASCII-only symbols.\n\t */\n\tfunction encode(input) {\n\t\tvar n,\n\t\t    delta,\n\t\t    handledCPCount,\n\t\t    basicLength,\n\t\t    bias,\n\t\t    j,\n\t\t    m,\n\t\t    q,\n\t\t    k,\n\t\t    t,\n\t\t    currentValue,\n\t\t    output = [],\n\t\t    /** `inputLength` will hold the number of code points in `input`. */\n\t\t    inputLength,\n\t\t    /** Cached calculation results */\n\t\t    handledCPCountPlusOne,\n\t\t    baseMinusT,\n\t\t    qMinusT;\n\n\t\t// Convert the input in UCS-2 to Unicode\n\t\tinput = ucs2decode(input);\n\n\t\t// Cache the length\n\t\tinputLength = input.length;\n\n\t\t// Initialize the state\n\t\tn = initialN;\n\t\tdelta = 0;\n\t\tbias = initialBias;\n\n\t\t// Handle the basic code points\n\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\tcurrentValue = input[j];\n\t\t\tif (currentValue < 0x80) {\n\t\t\t\toutput.push(stringFromCharCode(currentValue));\n\t\t\t}\n\t\t}\n\n\t\thandledCPCount = basicLength = output.length;\n\n\t\t// `handledCPCount` is the number of code points that have been handled;\n\t\t// `basicLength` is the number of basic code points.\n\n\t\t// Finish the basic string - if it is not empty - with a delimiter\n\t\tif (basicLength) {\n\t\t\toutput.push(delimiter);\n\t\t}\n\n\t\t// Main encoding loop:\n\t\twhile (handledCPCount < inputLength) {\n\n\t\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t\t// larger one:\n\t\t\tfor (m = maxInt, j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\t\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\t\tm = currentValue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t\t// but guard against overflow\n\t\t\thandledCPCountPlusOne = handledCPCount + 1;\n\t\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\t\tn = m;\n\n\t\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\n\t\t\t\tif (currentValue < n && ++delta > maxInt) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tif (currentValue == n) {\n\t\t\t\t\t// Represent delta as a generalized variable-length integer\n\t\t\t\t\tfor (q = delta, k = base; /* no condition */; k += base) {\n\t\t\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\t\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tqMinusT = q - t;\n\t\t\t\t\t\tbaseMinusT = base - t;\n\t\t\t\t\t\toutput.push(\n\t\t\t\t\t\t\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\n\t\t\t\t\t\t);\n\t\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t\t}\n\n\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n\t\t\t\t\tdelta = 0;\n\t\t\t\t\t++handledCPCount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t++delta;\n\t\t\t++n;\n\n\t\t}\n\t\treturn output.join('');\n\t}\n\n\t/**\n\t * Converts a Punycode string representing a domain name or an email address\n\t * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n\t * it doesn't matter if you call it on a string that has already been\n\t * converted to Unicode.\n\t * @memberOf punycode\n\t * @param {String} input The Punycoded domain name or email address to\n\t * convert to Unicode.\n\t * @returns {String} The Unicode representation of the given Punycode\n\t * string.\n\t */\n\tfunction toUnicode(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexPunycode.test(string)\n\t\t\t\t? decode(string.slice(4).toLowerCase())\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/**\n\t * Converts a Unicode string representing a domain name or an email address to\n\t * Punycode. Only the non-ASCII parts of the domain name will be converted,\n\t * i.e. it doesn't matter if you call it with a domain that's already in\n\t * ASCII.\n\t * @memberOf punycode\n\t * @param {String} input The domain name or email address to convert, as a\n\t * Unicode string.\n\t * @returns {String} The Punycode representation of the given domain name or\n\t * email address.\n\t */\n\tfunction toASCII(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexNonASCII.test(string)\n\t\t\t\t? 'xn--' + encode(string)\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/** Define the public API */\n\tpunycode = {\n\t\t/**\n\t\t * A string representing the current Punycode.js version number.\n\t\t * @memberOf punycode\n\t\t * @type String\n\t\t */\n\t\t'version': '1.3.2',\n\t\t/**\n\t\t * An object of methods to convert from JavaScript's internal character\n\t\t * representation (UCS-2) to Unicode code points, and back.\n\t\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t\t * @memberOf punycode\n\t\t * @type Object\n\t\t */\n\t\t'ucs2': {\n\t\t\t'decode': ucs2decode,\n\t\t\t'encode': ucs2encode\n\t\t},\n\t\t'decode': decode,\n\t\t'encode': encode,\n\t\t'toASCII': toASCII,\n\t\t'toUnicode': toUnicode\n\t};\n\n\t/** Expose `punycode` */\n\t// Some AMD build optimizers, like r.js, check for specific condition patterns\n\t// like the following:\n\tif (\n\t\ttypeof define == 'function' &&\n\t\ttypeof define.amd == 'object' &&\n\t\tdefine.amd\n\t) {\n\t\tdefine('punycode', function() {\n\t\t\treturn punycode;\n\t\t});\n\t} else if (freeExports && freeModule) {\n\t\tif (module.exports == freeExports) { // in Node.js or RingoJS v0.8.0+\n\t\t\tfreeModule.exports = punycode;\n\t\t} else { // in Narwhal or RingoJS v0.7.0-\n\t\t\tfor (key in punycode) {\n\t\t\t\tpunycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);\n\t\t\t}\n\t\t}\n\t} else { // in Rhino or a web browser\n\t\troot.punycode = punycode;\n\t}\n\n}(this));\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],95:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n// If obj.hasOwnProperty has been overridden, then calling\n// obj.hasOwnProperty(prop) will break.\n// See: https://github.com/joyent/node/issues/1707\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nmodule.exports = function(qs, sep, eq, options) {\n  sep = sep || '&';\n  eq = eq || '=';\n  var obj = {};\n\n  if (typeof qs !== 'string' || qs.length === 0) {\n    return obj;\n  }\n\n  var regexp = /\\+/g;\n  qs = qs.split(sep);\n\n  var maxKeys = 1000;\n  if (options && typeof options.maxKeys === 'number') {\n    maxKeys = options.maxKeys;\n  }\n\n  var len = qs.length;\n  // maxKeys <= 0 means that we should not limit keys count\n  if (maxKeys > 0 && len > maxKeys) {\n    len = maxKeys;\n  }\n\n  for (var i = 0; i < len; ++i) {\n    var x = qs[i].replace(regexp, '%20'),\n        idx = x.indexOf(eq),\n        kstr, vstr, k, v;\n\n    if (idx >= 0) {\n      kstr = x.substr(0, idx);\n      vstr = x.substr(idx + 1);\n    } else {\n      kstr = x;\n      vstr = '';\n    }\n\n    k = decodeURIComponent(kstr);\n    v = decodeURIComponent(vstr);\n\n    if (!hasOwnProperty(obj, k)) {\n      obj[k] = v;\n    } else if (isArray(obj[k])) {\n      obj[k].push(v);\n    } else {\n      obj[k] = [obj[k], v];\n    }\n  }\n\n  return obj;\n};\n\nvar isArray = Array.isArray || function (xs) {\n  return Object.prototype.toString.call(xs) === '[object Array]';\n};\n\n},{}],96:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar stringifyPrimitive = function(v) {\n  switch (typeof v) {\n    case 'string':\n      return v;\n\n    case 'boolean':\n      return v ? 'true' : 'false';\n\n    case 'number':\n      return isFinite(v) ? v : '';\n\n    default:\n      return '';\n  }\n};\n\nmodule.exports = function(obj, sep, eq, name) {\n  sep = sep || '&';\n  eq = eq || '=';\n  if (obj === null) {\n    obj = undefined;\n  }\n\n  if (typeof obj === 'object') {\n    return map(objectKeys(obj), function(k) {\n      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;\n      if (isArray(obj[k])) {\n        return map(obj[k], function(v) {\n          return ks + encodeURIComponent(stringifyPrimitive(v));\n        }).join(sep);\n      } else {\n        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));\n      }\n    }).join(sep);\n\n  }\n\n  if (!name) return '';\n  return encodeURIComponent(stringifyPrimitive(name)) + eq +\n         encodeURIComponent(stringifyPrimitive(obj));\n};\n\nvar isArray = Array.isArray || function (xs) {\n  return Object.prototype.toString.call(xs) === '[object Array]';\n};\n\nfunction map (xs, f) {\n  if (xs.map) return xs.map(f);\n  var res = [];\n  for (var i = 0; i < xs.length; i++) {\n    res.push(f(xs[i], i));\n  }\n  return res;\n}\n\nvar objectKeys = Object.keys || function (obj) {\n  var res = [];\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);\n  }\n  return res;\n};\n\n},{}],97:[function(require,module,exports){\n'use strict';\n\nexports.decode = exports.parse = require('./decode');\nexports.encode = exports.stringify = require('./encode');\n\n},{\"./decode\":95,\"./encode\":96}],98:[function(require,module,exports){\nmodule.exports = require(\"./lib/_stream_duplex.js\")\n\n},{\"./lib/_stream_duplex.js\":99}],99:[function(require,module,exports){\n(function (process){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n\nmodule.exports = Duplex;\n\n/*<replacement>*/\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) keys.push(key);\n  return keys;\n}\n/*</replacement>*/\n\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nvar Readable = require('./_stream_readable');\nvar Writable = require('./_stream_writable');\n\nutil.inherits(Duplex, Readable);\n\nforEach(objectKeys(Writable.prototype), function(method) {\n  if (!Duplex.prototype[method])\n    Duplex.prototype[method] = Writable.prototype[method];\n});\n\nfunction Duplex(options) {\n  if (!(this instanceof Duplex))\n    return new Duplex(options);\n\n  Readable.call(this, options);\n  Writable.call(this, options);\n\n  if (options && options.readable === false)\n    this.readable = false;\n\n  if (options && options.writable === false)\n    this.writable = false;\n\n  this.allowHalfOpen = true;\n  if (options && options.allowHalfOpen === false)\n    this.allowHalfOpen = false;\n\n  this.once('end', onend);\n}\n\n// the no-half-open enforcer\nfunction onend() {\n  // if we allow half-open state, or if the writable side ended,\n  // then we're ok.\n  if (this.allowHalfOpen || this._writableState.ended)\n    return;\n\n  // no more data can be written.\n  // But allow more writes to happen in this tick.\n  process.nextTick(this.end.bind(this));\n}\n\nfunction forEach (xs, f) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    f(xs[i], i);\n  }\n}\n\n}).call(this,require('_process'))\n},{\"./_stream_readable\":101,\"./_stream_writable\":103,\"_process\":93,\"core-util-is\":104,\"inherits\":90}],100:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n\nmodule.exports = PassThrough;\n\nvar Transform = require('./_stream_transform');\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nutil.inherits(PassThrough, Transform);\n\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough))\n    return new PassThrough(options);\n\n  Transform.call(this, options);\n}\n\nPassThrough.prototype._transform = function(chunk, encoding, cb) {\n  cb(null, chunk);\n};\n\n},{\"./_stream_transform\":102,\"core-util-is\":104,\"inherits\":90}],101:[function(require,module,exports){\n(function (process){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nmodule.exports = Readable;\n\n/*<replacement>*/\nvar isArray = require('isarray');\n/*</replacement>*/\n\n\n/*<replacement>*/\nvar Buffer = require('buffer').Buffer;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n\nvar EE = require('events').EventEmitter;\n\n/*<replacement>*/\nif (!EE.listenerCount) EE.listenerCount = function(emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\nvar Stream = require('stream');\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nvar StringDecoder;\n\n\n/*<replacement>*/\nvar debug = require('util');\nif (debug && debug.debuglog) {\n  debug = debug.debuglog('stream');\n} else {\n  debug = function () {};\n}\n/*</replacement>*/\n\n\nutil.inherits(Readable, Stream);\n\nfunction ReadableState(options, stream) {\n  var Duplex = require('./_stream_duplex');\n\n  options = options || {};\n\n  // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n  var hwm = options.highWaterMark;\n  var defaultHwm = options.objectMode ? 16 : 16 * 1024;\n  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = ~~this.highWaterMark;\n\n  this.buffer = [];\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n\n\n  // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n  this.objectMode = !!options.objectMode;\n\n  if (stream instanceof Duplex)\n    this.objectMode = this.objectMode || !!options.readableObjectMode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // when piping, we only care about 'readable' events that happen\n  // after read()ing all the bytes and not getting any pushback.\n  this.ranOut = false;\n\n  // the number of writers that are awaiting a drain event in .pipe()s\n  this.awaitDrain = 0;\n\n  // if true, a maybeReadMore has been scheduled\n  this.readingMore = false;\n\n  this.decoder = null;\n  this.encoding = null;\n  if (options.encoding) {\n    if (!StringDecoder)\n      StringDecoder = require('string_decoder/').StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nfunction Readable(options) {\n  var Duplex = require('./_stream_duplex');\n\n  if (!(this instanceof Readable))\n    return new Readable(options);\n\n  this._readableState = new ReadableState(options, this);\n\n  // legacy\n  this.readable = true;\n\n  Stream.call(this);\n}\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function(chunk, encoding) {\n  var state = this._readableState;\n\n  if (util.isString(chunk) && !state.objectMode) {\n    encoding = encoding || state.defaultEncoding;\n    if (encoding !== state.encoding) {\n      chunk = new Buffer(chunk, encoding);\n      encoding = '';\n    }\n  }\n\n  return readableAddChunk(this, state, chunk, encoding, false);\n};\n\n// Unshift should *always* be something directly out of read()\nReadable.prototype.unshift = function(chunk) {\n  var state = this._readableState;\n  return readableAddChunk(this, state, chunk, '', true);\n};\n\nfunction readableAddChunk(stream, state, chunk, encoding, addToFront) {\n  var er = chunkInvalid(state, chunk);\n  if (er) {\n    stream.emit('error', er);\n  } else if (util.isNullOrUndefined(chunk)) {\n    state.reading = false;\n    if (!state.ended)\n      onEofChunk(stream, state);\n  } else if (state.objectMode || chunk && chunk.length > 0) {\n    if (state.ended && !addToFront) {\n      var e = new Error('stream.push() after EOF');\n      stream.emit('error', e);\n    } else if (state.endEmitted && addToFront) {\n      var e = new Error('stream.unshift() after end event');\n      stream.emit('error', e);\n    } else {\n      if (state.decoder && !addToFront && !encoding)\n        chunk = state.decoder.write(chunk);\n\n      if (!addToFront)\n        state.reading = false;\n\n      // if we want the data now, just emit it.\n      if (state.flowing && state.length === 0 && !state.sync) {\n        stream.emit('data', chunk);\n        stream.read(0);\n      } else {\n        // update the buffer info.\n        state.length += state.objectMode ? 1 : chunk.length;\n        if (addToFront)\n          state.buffer.unshift(chunk);\n        else\n          state.buffer.push(chunk);\n\n        if (state.needReadable)\n          emitReadable(stream);\n      }\n\n      maybeReadMore(stream, state);\n    }\n  } else if (!addToFront) {\n    state.reading = false;\n  }\n\n  return needMoreData(state);\n}\n\n\n\n// if it's past the high water mark, we can push in some more.\n// Also, if we have no data yet, we can stand some\n// more bytes.  This is to work around cases where hwm=0,\n// such as the repl.  Also, if the push() triggered a\n// readable event, and the user called read(largeNumber) such that\n// needReadable was set, then we ought to push more, so that another\n// 'readable' event will be triggered.\nfunction needMoreData(state) {\n  return !state.ended &&\n         (state.needReadable ||\n          state.length < state.highWaterMark ||\n          state.length === 0);\n}\n\n// backwards compatibility.\nReadable.prototype.setEncoding = function(enc) {\n  if (!StringDecoder)\n    StringDecoder = require('string_decoder/').StringDecoder;\n  this._readableState.decoder = new StringDecoder(enc);\n  this._readableState.encoding = enc;\n  return this;\n};\n\n// Don't raise the hwm > 128MB\nvar MAX_HWM = 0x800000;\nfunction roundUpToNextPowerOf2(n) {\n  if (n >= MAX_HWM) {\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2\n    n--;\n    for (var p = 1; p < 32; p <<= 1) n |= n >> p;\n    n++;\n  }\n  return n;\n}\n\nfunction howMuchToRead(n, state) {\n  if (state.length === 0 && state.ended)\n    return 0;\n\n  if (state.objectMode)\n    return n === 0 ? 0 : 1;\n\n  if (isNaN(n) || util.isNull(n)) {\n    // only flow one buffer at a time\n    if (state.flowing && state.buffer.length)\n      return state.buffer[0].length;\n    else\n      return state.length;\n  }\n\n  if (n <= 0)\n    return 0;\n\n  // If we're asking for more than the target buffer level,\n  // then raise the water mark.  Bump up to the next highest\n  // power of 2, to prevent increasing it excessively in tiny\n  // amounts.\n  if (n > state.highWaterMark)\n    state.highWaterMark = roundUpToNextPowerOf2(n);\n\n  // don't have that much.  return null, unless we've ended.\n  if (n > state.length) {\n    if (!state.ended) {\n      state.needReadable = true;\n      return 0;\n    } else\n      return state.length;\n  }\n\n  return n;\n}\n\n// you can override either this method, or the async _read(n) below.\nReadable.prototype.read = function(n) {\n  debug('read', n);\n  var state = this._readableState;\n  var nOrig = n;\n\n  if (!util.isNumber(n) || n > 0)\n    state.emittedReadable = false;\n\n  // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n  if (n === 0 &&\n      state.needReadable &&\n      (state.length >= state.highWaterMark || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended)\n      endReadable(this);\n    else\n      emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state);\n\n  // if we've ended, and we're now clear, then finish it up.\n  if (n === 0 && state.ended) {\n    if (state.length === 0)\n      endReadable(this);\n    return null;\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event, then we need to do some reading.\n  var doRead = state.needReadable;\n  debug('need readable', doRead);\n\n  // if we currently have less than the highWaterMark, then also read some\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  }\n\n  // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  }\n\n  if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true;\n    // if the length is currently zero, then we *need* a readable event.\n    if (state.length === 0)\n      state.needReadable = true;\n    // call internal read method\n    this._read(state.highWaterMark);\n    state.sync = false;\n  }\n\n  // If _read pushed data synchronously, then `reading` will be false,\n  // and we need to re-evaluate how much data we can return to the user.\n  if (doRead && !state.reading)\n    n = howMuchToRead(nOrig, state);\n\n  var ret;\n  if (n > 0)\n    ret = fromList(n, state);\n  else\n    ret = null;\n\n  if (util.isNull(ret)) {\n    state.needReadable = true;\n    n = 0;\n  }\n\n  state.length -= n;\n\n  // If we have nothing in the buffer, then we want to know\n  // as soon as we *do* get something into the buffer.\n  if (state.length === 0 && !state.ended)\n    state.needReadable = true;\n\n  // If we tried to read() past the EOF, then emit end on the next tick.\n  if (nOrig !== n && state.ended && state.length === 0)\n    endReadable(this);\n\n  if (!util.isNull(ret))\n    this.emit('data', ret);\n\n  return ret;\n};\n\nfunction chunkInvalid(state, chunk) {\n  var er = null;\n  if (!util.isBuffer(chunk) &&\n      !util.isString(chunk) &&\n      !util.isNullOrUndefined(chunk) &&\n      !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  return er;\n}\n\n\nfunction onEofChunk(stream, state) {\n  if (state.decoder && !state.ended) {\n    var chunk = state.decoder.end();\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n  state.ended = true;\n\n  // emit 'readable' now to make sure it gets picked up.\n  emitReadable(stream);\n}\n\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  state.needReadable = false;\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    if (state.sync)\n      process.nextTick(function() {\n        emitReadable_(stream);\n      });\n    else\n      emitReadable_(stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  debug('emit readable');\n  stream.emit('readable');\n  flow(stream);\n}\n\n\n// at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    process.nextTick(function() {\n      maybeReadMore_(stream, state);\n    });\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  var len = state.length;\n  while (!state.reading && !state.flowing && !state.ended &&\n         state.length < state.highWaterMark) {\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length)\n      // didn't get any data, stop spinning.\n      break;\n    else\n      len = state.length;\n  }\n  state.readingMore = false;\n}\n\n// abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function(n) {\n  this.emit('error', new Error('not implemented'));\n};\n\nReadable.prototype.pipe = function(dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&\n              dest !== process.stdout &&\n              dest !== process.stderr;\n\n  var endFn = doEnd ? onend : cleanup;\n  if (state.endEmitted)\n    process.nextTick(endFn);\n  else\n    src.once('end', endFn);\n\n  dest.on('unpipe', onunpipe);\n  function onunpipe(readable) {\n    debug('onunpipe');\n    if (readable === src) {\n      cleanup();\n    }\n  }\n\n  function onend() {\n    debug('onend');\n    dest.end();\n  }\n\n  // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n\n  function cleanup() {\n    debug('cleanup');\n    // cleanup event handlers once the pipe is broken\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', cleanup);\n    src.removeListener('data', ondata);\n\n    // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n    if (state.awaitDrain &&\n        (!dest._writableState || dest._writableState.needDrain))\n      ondrain();\n  }\n\n  src.on('data', ondata);\n  function ondata(chunk) {\n    debug('ondata');\n    var ret = dest.write(chunk);\n    if (false === ret) {\n      debug('false write response, pause',\n            src._readableState.awaitDrain);\n      src._readableState.awaitDrain++;\n      src.pause();\n    }\n  }\n\n  // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EE.listenerCount(dest, 'error') === 0)\n      dest.emit('error', er);\n  }\n  // This is a brutally ugly hack to make sure that our error handler\n  // is attached before any userland ones.  NEVER DO THIS.\n  if (!dest._events || !dest._events.error)\n    dest.on('error', onerror);\n  else if (isArray(dest._events.error))\n    dest._events.error.unshift(onerror);\n  else\n    dest._events.error = [onerror, dest._events.error];\n\n\n\n  // Both close and finish should trigger unpipe, but only once.\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n  dest.once('close', onclose);\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  }\n\n  // tell the dest that it's being piped to\n  dest.emit('pipe', src);\n\n  // start the flow if it hasn't been started already.\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function() {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain)\n      state.awaitDrain--;\n    if (state.awaitDrain === 0 && EE.listenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\n\n\nReadable.prototype.unpipe = function(dest) {\n  var state = this._readableState;\n\n  // if we're not piping anywhere, then do nothing.\n  if (state.pipesCount === 0)\n    return this;\n\n  // just one destination.  most common case.\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes)\n      return this;\n\n    if (!dest)\n      dest = state.pipes;\n\n    // got a match.\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest)\n      dest.emit('unpipe', this);\n    return this;\n  }\n\n  // slow case. multiple pipe destinations.\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n\n    for (var i = 0; i < len; i++)\n      dests[i].emit('unpipe', this);\n    return this;\n  }\n\n  // try to find the right one.\n  var i = indexOf(state.pipes, dest);\n  if (i === -1)\n    return this;\n\n  state.pipes.splice(i, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1)\n    state.pipes = state.pipes[0];\n\n  dest.emit('unpipe', this);\n\n  return this;\n};\n\n// set up data events if they are asked for\n// Ensure readable listeners eventually get something\nReadable.prototype.on = function(ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n\n  // If listening to data, and it has not explicitly been paused,\n  // then call resume to start the flow of data on the next tick.\n  if (ev === 'data' && false !== this._readableState.flowing) {\n    this.resume();\n  }\n\n  if (ev === 'readable' && this.readable) {\n    var state = this._readableState;\n    if (!state.readableListening) {\n      state.readableListening = true;\n      state.emittedReadable = false;\n      state.needReadable = true;\n      if (!state.reading) {\n        var self = this;\n        process.nextTick(function() {\n          debug('readable nexttick read 0');\n          self.read(0);\n        });\n      } else if (state.length) {\n        emitReadable(this, state);\n      }\n    }\n  }\n\n  return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function() {\n  var state = this._readableState;\n  if (!state.flowing) {\n    debug('resume');\n    state.flowing = true;\n    if (!state.reading) {\n      debug('resume read 0');\n      this.read(0);\n    }\n    resume(this, state);\n  }\n  return this;\n};\n\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    process.nextTick(function() {\n      resume_(stream, state);\n    });\n  }\n}\n\nfunction resume_(stream, state) {\n  state.resumeScheduled = false;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading)\n    stream.read(0);\n}\n\nReadable.prototype.pause = function() {\n  debug('call pause flowing=%j', this._readableState.flowing);\n  if (false !== this._readableState.flowing) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n  return this;\n};\n\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n  if (state.flowing) {\n    do {\n      var chunk = stream.read();\n    } while (null !== chunk && state.flowing);\n  }\n}\n\n// wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function(stream) {\n  var state = this._readableState;\n  var paused = false;\n\n  var self = this;\n  stream.on('end', function() {\n    debug('wrapped end');\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length)\n        self.push(chunk);\n    }\n\n    self.push(null);\n  });\n\n  stream.on('data', function(chunk) {\n    debug('wrapped data');\n    if (state.decoder)\n      chunk = state.decoder.write(chunk);\n    if (!chunk || !state.objectMode && !chunk.length)\n      return;\n\n    var ret = self.push(chunk);\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  });\n\n  // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n  for (var i in stream) {\n    if (util.isFunction(stream[i]) && util.isUndefined(this[i])) {\n      this[i] = function(method) { return function() {\n        return stream[method].apply(stream, arguments);\n      }}(i);\n    }\n  }\n\n  // proxy certain important events.\n  var events = ['error', 'close', 'destroy', 'pause', 'resume'];\n  forEach(events, function(ev) {\n    stream.on(ev, self.emit.bind(self, ev));\n  });\n\n  // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n  self._read = function(n) {\n    debug('wrapped _read', n);\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return self;\n};\n\n\n\n// exposed for testing purposes only.\nReadable._fromList = fromList;\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\nfunction fromList(n, state) {\n  var list = state.buffer;\n  var length = state.length;\n  var stringMode = !!state.decoder;\n  var objectMode = !!state.objectMode;\n  var ret;\n\n  // nothing in the list, definitely empty.\n  if (list.length === 0)\n    return null;\n\n  if (length === 0)\n    ret = null;\n  else if (objectMode)\n    ret = list.shift();\n  else if (!n || n >= length) {\n    // read it all, truncate the array.\n    if (stringMode)\n      ret = list.join('');\n    else\n      ret = Buffer.concat(list, length);\n    list.length = 0;\n  } else {\n    // read just some of it.\n    if (n < list[0].length) {\n      // just take a part of the first list item.\n      // slice is the same for buffers and strings.\n      var buf = list[0];\n      ret = buf.slice(0, n);\n      list[0] = buf.slice(n);\n    } else if (n === list[0].length) {\n      // first list is a perfect match\n      ret = list.shift();\n    } else {\n      // complex case.\n      // we have enough to cover it, but it spans past the first buffer.\n      if (stringMode)\n        ret = '';\n      else\n        ret = new Buffer(n);\n\n      var c = 0;\n      for (var i = 0, l = list.length; i < l && c < n; i++) {\n        var buf = list[0];\n        var cpy = Math.min(n - c, buf.length);\n\n        if (stringMode)\n          ret += buf.slice(0, cpy);\n        else\n          buf.copy(ret, c, 0, cpy);\n\n        if (cpy < buf.length)\n          list[0] = buf.slice(cpy);\n        else\n          list.shift();\n\n        c += cpy;\n      }\n    }\n  }\n\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n\n  // If we get here before consuming all the bytes, then that is a\n  // bug in node.  Should never happen.\n  if (state.length > 0)\n    throw new Error('endReadable called on non-empty stream');\n\n  if (!state.endEmitted) {\n    state.ended = true;\n    process.nextTick(function() {\n      // Check that we didn't get one last unshift.\n      if (!state.endEmitted && state.length === 0) {\n        state.endEmitted = true;\n        stream.readable = false;\n        stream.emit('end');\n      }\n    });\n  }\n}\n\nfunction forEach (xs, f) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    f(xs[i], i);\n  }\n}\n\nfunction indexOf (xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n  return -1;\n}\n\n}).call(this,require('_process'))\n},{\"./_stream_duplex\":99,\"_process\":93,\"buffer\":80,\"core-util-is\":104,\"events\":84,\"inherits\":90,\"isarray\":92,\"stream\":109,\"string_decoder/\":110,\"util\":79}],102:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\nmodule.exports = Transform;\n\nvar Duplex = require('./_stream_duplex');\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nutil.inherits(Transform, Duplex);\n\n\nfunction TransformState(options, stream) {\n  this.afterTransform = function(er, data) {\n    return afterTransform(stream, er, data);\n  };\n\n  this.needTransform = false;\n  this.transforming = false;\n  this.writecb = null;\n  this.writechunk = null;\n}\n\nfunction afterTransform(stream, er, data) {\n  var ts = stream._transformState;\n  ts.transforming = false;\n\n  var cb = ts.writecb;\n\n  if (!cb)\n    return stream.emit('error', new Error('no writecb in Transform class'));\n\n  ts.writechunk = null;\n  ts.writecb = null;\n\n  if (!util.isNullOrUndefined(data))\n    stream.push(data);\n\n  if (cb)\n    cb(er);\n\n  var rs = stream._readableState;\n  rs.reading = false;\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    stream._read(rs.highWaterMark);\n  }\n}\n\n\nfunction Transform(options) {\n  if (!(this instanceof Transform))\n    return new Transform(options);\n\n  Duplex.call(this, options);\n\n  this._transformState = new TransformState(options, this);\n\n  // when the writable side finishes, then flush out anything remaining.\n  var stream = this;\n\n  // start out asking for a readable event once data is transformed.\n  this._readableState.needReadable = true;\n\n  // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n  this._readableState.sync = false;\n\n  this.once('prefinish', function() {\n    if (util.isFunction(this._flush))\n      this._flush(function(er) {\n        done(stream, er);\n      });\n    else\n      done(stream);\n  });\n}\n\nTransform.prototype.push = function(chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n};\n\n// This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\nTransform.prototype._transform = function(chunk, encoding, cb) {\n  throw new Error('not implemented');\n};\n\nTransform.prototype._write = function(chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform ||\n        rs.needReadable ||\n        rs.length < rs.highWaterMark)\n      this._read(rs.highWaterMark);\n  }\n};\n\n// Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\nTransform.prototype._read = function(n) {\n  var ts = this._transformState;\n\n  if (!util.isNull(ts.writechunk) && ts.writecb && !ts.transforming) {\n    ts.transforming = true;\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\n\n\nfunction done(stream, er) {\n  if (er)\n    return stream.emit('error', er);\n\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n  var ws = stream._writableState;\n  var ts = stream._transformState;\n\n  if (ws.length)\n    throw new Error('calling transform done when ws.length != 0');\n\n  if (ts.transforming)\n    throw new Error('calling transform done when still transforming');\n\n  return stream.push(null);\n}\n\n},{\"./_stream_duplex\":99,\"core-util-is\":104,\"inherits\":90}],103:[function(require,module,exports){\n(function (process){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, cb), and it'll handle all\n// the drain event emission and buffering.\n\nmodule.exports = Writable;\n\n/*<replacement>*/\nvar Buffer = require('buffer').Buffer;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nvar Stream = require('stream');\n\nutil.inherits(Writable, Stream);\n\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n}\n\nfunction WritableState(options, stream) {\n  var Duplex = require('./_stream_duplex');\n\n  options = options || {};\n\n  // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n  var hwm = options.highWaterMark;\n  var defaultHwm = options.objectMode ? 16 : 16 * 1024;\n  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;\n\n  // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!options.objectMode;\n\n  if (stream instanceof Duplex)\n    this.objectMode = this.objectMode || !!options.writableObjectMode;\n\n  // cast to ints.\n  this.highWaterMark = ~~this.highWaterMark;\n\n  this.needDrain = false;\n  // at the start of calling end()\n  this.ending = false;\n  // when end() has been called, and returned\n  this.ended = false;\n  // when 'finish' is emitted\n  this.finished = false;\n\n  // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // a flag to see when we're in the middle of a write.\n  this.writing = false;\n\n  // when true all writes will be buffered until .uncork() call\n  this.corked = 0;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false;\n\n  // the callback that's passed to _write(chunk,cb)\n  this.onwrite = function(er) {\n    onwrite(stream, er);\n  };\n\n  // the callback that the user supplies to write(chunk,encoding,cb)\n  this.writecb = null;\n\n  // the amount that is being written when _write is called.\n  this.writelen = 0;\n\n  this.buffer = [];\n\n  // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n  this.pendingcb = 0;\n\n  // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n  this.prefinished = false;\n\n  // True if the error was already emitted and should not be thrown again\n  this.errorEmitted = false;\n}\n\nfunction Writable(options) {\n  var Duplex = require('./_stream_duplex');\n\n  // Writable ctor is applied to Duplexes, though they're not\n  // instanceof Writable, they're instanceof Readable.\n  if (!(this instanceof Writable) && !(this instanceof Duplex))\n    return new Writable(options);\n\n  this._writableState = new WritableState(options, this);\n\n  // legacy.\n  this.writable = true;\n\n  Stream.call(this);\n}\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function() {\n  this.emit('error', new Error('Cannot pipe. Not readable.'));\n};\n\n\nfunction writeAfterEnd(stream, state, cb) {\n  var er = new Error('write after end');\n  // TODO: defer error events consistently everywhere, not just the cb\n  stream.emit('error', er);\n  process.nextTick(function() {\n    cb(er);\n  });\n}\n\n// If we get something that is not a buffer, string, null, or undefined,\n// and we're not in objectMode, then that's an error.\n// Otherwise stream chunks are all considered to be of length=1, and the\n// watermarks determine how many objects to keep in the buffer, rather than\n// how many bytes or characters.\nfunction validChunk(stream, state, chunk, cb) {\n  var valid = true;\n  if (!util.isBuffer(chunk) &&\n      !util.isString(chunk) &&\n      !util.isNullOrUndefined(chunk) &&\n      !state.objectMode) {\n    var er = new TypeError('Invalid non-string/buffer chunk');\n    stream.emit('error', er);\n    process.nextTick(function() {\n      cb(er);\n    });\n    valid = false;\n  }\n  return valid;\n}\n\nWritable.prototype.write = function(chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n\n  if (util.isFunction(encoding)) {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (util.isBuffer(chunk))\n    encoding = 'buffer';\n  else if (!encoding)\n    encoding = state.defaultEncoding;\n\n  if (!util.isFunction(cb))\n    cb = function() {};\n\n  if (state.ended)\n    writeAfterEnd(this, state, cb);\n  else if (validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, chunk, encoding, cb);\n  }\n\n  return ret;\n};\n\nWritable.prototype.cork = function() {\n  var state = this._writableState;\n\n  state.corked++;\n};\n\nWritable.prototype.uncork = function() {\n  var state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n\n    if (!state.writing &&\n        !state.corked &&\n        !state.finished &&\n        !state.bufferProcessing &&\n        state.buffer.length)\n      clearBuffer(this, state);\n  }\n};\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode &&\n      state.decodeStrings !== false &&\n      util.isString(chunk)) {\n    chunk = new Buffer(chunk, encoding);\n  }\n  return chunk;\n}\n\n// if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, chunk, encoding, cb) {\n  chunk = decodeChunk(state, chunk, encoding);\n  if (util.isBuffer(chunk))\n    encoding = 'buffer';\n  var len = state.objectMode ? 1 : chunk.length;\n\n  state.length += len;\n\n  var ret = state.length < state.highWaterMark;\n  // we must ensure that previous needDrain will not be reset to false.\n  if (!ret)\n    state.needDrain = true;\n\n  if (state.writing || state.corked)\n    state.buffer.push(new WriteReq(chunk, encoding, cb));\n  else\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n\n  return ret;\n}\n\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (writev)\n    stream._writev(chunk, state.onwrite);\n  else\n    stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  if (sync)\n    process.nextTick(function() {\n      state.pendingcb--;\n      cb(er);\n    });\n  else {\n    state.pendingcb--;\n    cb(er);\n  }\n\n  stream._writableState.errorEmitted = true;\n  stream.emit('error', er);\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n\n  onwriteStateUpdate(state);\n\n  if (er)\n    onwriteError(stream, state, sync, er, cb);\n  else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(stream, state);\n\n    if (!finished &&\n        !state.corked &&\n        !state.bufferProcessing &&\n        state.buffer.length) {\n      clearBuffer(stream, state);\n    }\n\n    if (sync) {\n      process.nextTick(function() {\n        afterWrite(stream, state, finished, cb);\n      });\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished)\n    onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n}\n\n// Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n}\n\n\n// if there's something in the buffer waiting, then process it\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n\n  if (stream._writev && state.buffer.length > 1) {\n    // Fast case, write everything using _writev()\n    var cbs = [];\n    for (var c = 0; c < state.buffer.length; c++)\n      cbs.push(state.buffer[c].callback);\n\n    // count the one we are adding, as well.\n    // TODO(isaacs) clean this up\n    state.pendingcb++;\n    doWrite(stream, state, true, state.length, state.buffer, '', function(err) {\n      for (var i = 0; i < cbs.length; i++) {\n        state.pendingcb--;\n        cbs[i](err);\n      }\n    });\n\n    // Clear buffer\n    state.buffer = [];\n  } else {\n    // Slow case, write chunks one-by-one\n    for (var c = 0; c < state.buffer.length; c++) {\n      var entry = state.buffer[c];\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n\n      // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n      if (state.writing) {\n        c++;\n        break;\n      }\n    }\n\n    if (c < state.buffer.length)\n      state.buffer = state.buffer.slice(c);\n    else\n      state.buffer.length = 0;\n  }\n\n  state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function(chunk, encoding, cb) {\n  cb(new Error('not implemented'));\n\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function(chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (util.isFunction(chunk)) {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (util.isFunction(encoding)) {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (!util.isNullOrUndefined(chunk))\n    this.write(chunk, encoding);\n\n  // .end() fully uncorks\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  }\n\n  // ignore unnecessary end() calls.\n  if (!state.ending && !state.finished)\n    endWritable(this, state, cb);\n};\n\n\nfunction needFinish(stream, state) {\n  return (state.ending &&\n          state.length === 0 &&\n          !state.finished &&\n          !state.writing);\n}\n\nfunction prefinish(stream, state) {\n  if (!state.prefinished) {\n    state.prefinished = true;\n    stream.emit('prefinish');\n  }\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(stream, state);\n  if (need) {\n    if (state.pendingcb === 0) {\n      prefinish(stream, state);\n      state.finished = true;\n      stream.emit('finish');\n    } else\n      prefinish(stream, state);\n  }\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n  if (cb) {\n    if (state.finished)\n      process.nextTick(cb);\n    else\n      stream.once('finish', cb);\n  }\n  state.ended = true;\n}\n\n}).call(this,require('_process'))\n},{\"./_stream_duplex\":99,\"_process\":93,\"buffer\":80,\"core-util-is\":104,\"inherits\":90,\"stream\":109}],104:[function(require,module,exports){\n(function (Buffer){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nfunction isBuffer(arg) {\n  return Buffer.isBuffer(arg);\n}\nexports.isBuffer = isBuffer;\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n}).call(this,{\"isBuffer\":require(\"/Users/danmork/Projects/Lynx/web-browser-user-agent/node_modules/browserify/node_modules/insert-module-globals/node_modules/is-buffer/index.js\")})\n},{\"/Users/danmork/Projects/Lynx/web-browser-user-agent/node_modules/browserify/node_modules/insert-module-globals/node_modules/is-buffer/index.js\":91}],105:[function(require,module,exports){\nmodule.exports = require(\"./lib/_stream_passthrough.js\")\n\n},{\"./lib/_stream_passthrough.js\":100}],106:[function(require,module,exports){\nexports = module.exports = require('./lib/_stream_readable.js');\nexports.Stream = require('stream');\nexports.Readable = exports;\nexports.Writable = require('./lib/_stream_writable.js');\nexports.Duplex = require('./lib/_stream_duplex.js');\nexports.Transform = require('./lib/_stream_transform.js');\nexports.PassThrough = require('./lib/_stream_passthrough.js');\n\n},{\"./lib/_stream_duplex.js\":99,\"./lib/_stream_passthrough.js\":100,\"./lib/_stream_readable.js\":101,\"./lib/_stream_transform.js\":102,\"./lib/_stream_writable.js\":103,\"stream\":109}],107:[function(require,module,exports){\nmodule.exports = require(\"./lib/_stream_transform.js\")\n\n},{\"./lib/_stream_transform.js\":102}],108:[function(require,module,exports){\nmodule.exports = require(\"./lib/_stream_writable.js\")\n\n},{\"./lib/_stream_writable.js\":103}],109:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nmodule.exports = Stream;\n\nvar EE = require('events').EventEmitter;\nvar inherits = require('inherits');\n\ninherits(Stream, EE);\nStream.Readable = require('readable-stream/readable.js');\nStream.Writable = require('readable-stream/writable.js');\nStream.Duplex = require('readable-stream/duplex.js');\nStream.Transform = require('readable-stream/transform.js');\nStream.PassThrough = require('readable-stream/passthrough.js');\n\n// Backwards-compat with node 0.4.x\nStream.Stream = Stream;\n\n\n\n// old-style streams.  Note that the pipe method (the only relevant\n// part of this class) is overridden in the Readable class.\n\nfunction Stream() {\n  EE.call(this);\n}\n\nStream.prototype.pipe = function(dest, options) {\n  var source = this;\n\n  function ondata(chunk) {\n    if (dest.writable) {\n      if (false === dest.write(chunk) && source.pause) {\n        source.pause();\n      }\n    }\n  }\n\n  source.on('data', ondata);\n\n  function ondrain() {\n    if (source.readable && source.resume) {\n      source.resume();\n    }\n  }\n\n  dest.on('drain', ondrain);\n\n  // If the 'end' option is not supplied, dest.end() will be called when\n  // source gets the 'end' or 'close' events.  Only dest.end() once.\n  if (!dest._isStdio && (!options || options.end !== false)) {\n    source.on('end', onend);\n    source.on('close', onclose);\n  }\n\n  var didOnEnd = false;\n  function onend() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    dest.end();\n  }\n\n\n  function onclose() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    if (typeof dest.destroy === 'function') dest.destroy();\n  }\n\n  // don't leave dangling pipes when there are errors.\n  function onerror(er) {\n    cleanup();\n    if (EE.listenerCount(this, 'error') === 0) {\n      throw er; // Unhandled stream error in pipe.\n    }\n  }\n\n  source.on('error', onerror);\n  dest.on('error', onerror);\n\n  // remove all the event listeners that were added.\n  function cleanup() {\n    source.removeListener('data', ondata);\n    dest.removeListener('drain', ondrain);\n\n    source.removeListener('end', onend);\n    source.removeListener('close', onclose);\n\n    source.removeListener('error', onerror);\n    dest.removeListener('error', onerror);\n\n    source.removeListener('end', cleanup);\n    source.removeListener('close', cleanup);\n\n    dest.removeListener('close', cleanup);\n  }\n\n  source.on('end', cleanup);\n  source.on('close', cleanup);\n\n  dest.on('close', cleanup);\n\n  dest.emit('pipe', source);\n\n  // Allow for unix-like usage: A.pipe(B).pipe(C)\n  return dest;\n};\n\n},{\"events\":84,\"inherits\":90,\"readable-stream/duplex.js\":98,\"readable-stream/passthrough.js\":105,\"readable-stream/readable.js\":106,\"readable-stream/transform.js\":107,\"readable-stream/writable.js\":108}],110:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar Buffer = require('buffer').Buffer;\n\nvar isBufferEncoding = Buffer.isEncoding\n  || function(encoding) {\n       switch (encoding && encoding.toLowerCase()) {\n         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;\n         default: return false;\n       }\n     }\n\n\nfunction assertEncoding(encoding) {\n  if (encoding && !isBufferEncoding(encoding)) {\n    throw new Error('Unknown encoding: ' + encoding);\n  }\n}\n\n// StringDecoder provides an interface for efficiently splitting a series of\n// buffers into a series of JS strings without breaking apart multi-byte\n// characters. CESU-8 is handled as part of the UTF-8 encoding.\n//\n// @TODO Handling all encodings inside a single object makes it very difficult\n// to reason about this code, so it should be split up in the future.\n// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code\n// points as used by CESU-8.\nvar StringDecoder = exports.StringDecoder = function(encoding) {\n  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');\n  assertEncoding(encoding);\n  switch (this.encoding) {\n    case 'utf8':\n      // CESU-8 represents each of Surrogate Pair by 3-bytes\n      this.surrogateSize = 3;\n      break;\n    case 'ucs2':\n    case 'utf16le':\n      // UTF-16 represents each of Surrogate Pair by 2-bytes\n      this.surrogateSize = 2;\n      this.detectIncompleteChar = utf16DetectIncompleteChar;\n      break;\n    case 'base64':\n      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.\n      this.surrogateSize = 3;\n      this.detectIncompleteChar = base64DetectIncompleteChar;\n      break;\n    default:\n      this.write = passThroughWrite;\n      return;\n  }\n\n  // Enough space to store all bytes of a single character. UTF-8 needs 4\n  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).\n  this.charBuffer = new Buffer(6);\n  // Number of bytes received for the current incomplete multi-byte character.\n  this.charReceived = 0;\n  // Number of bytes expected for the current incomplete multi-byte character.\n  this.charLength = 0;\n};\n\n\n// write decodes the given buffer and returns it as JS string that is\n// guaranteed to not contain any partial multi-byte characters. Any partial\n// character found at the end of the buffer is buffered up, and will be\n// returned when calling write again with the remaining bytes.\n//\n// Note: Converting a Buffer containing an orphan surrogate to a String\n// currently works, but converting a String to a Buffer (via `new Buffer`, or\n// Buffer#write) will replace incomplete surrogates with the unicode\n// replacement character. See https://codereview.chromium.org/121173009/ .\nStringDecoder.prototype.write = function(buffer) {\n  var charStr = '';\n  // if our last write ended with an incomplete multibyte character\n  while (this.charLength) {\n    // determine how many remaining bytes this buffer has to offer for this char\n    var available = (buffer.length >= this.charLength - this.charReceived) ?\n        this.charLength - this.charReceived :\n        buffer.length;\n\n    // add the new bytes to the char buffer\n    buffer.copy(this.charBuffer, this.charReceived, 0, available);\n    this.charReceived += available;\n\n    if (this.charReceived < this.charLength) {\n      // still not enough chars in this buffer? wait for more ...\n      return '';\n    }\n\n    // remove bytes belonging to the current character from the buffer\n    buffer = buffer.slice(available, buffer.length);\n\n    // get the character that was split\n    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);\n\n    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character\n    var charCode = charStr.charCodeAt(charStr.length - 1);\n    if (charCode >= 0xD800 && charCode <= 0xDBFF) {\n      this.charLength += this.surrogateSize;\n      charStr = '';\n      continue;\n    }\n    this.charReceived = this.charLength = 0;\n\n    // if there are no more bytes in this buffer, just emit our char\n    if (buffer.length === 0) {\n      return charStr;\n    }\n    break;\n  }\n\n  // determine and set charLength / charReceived\n  this.detectIncompleteChar(buffer);\n\n  var end = buffer.length;\n  if (this.charLength) {\n    // buffer the incomplete character bytes we got\n    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);\n    end -= this.charReceived;\n  }\n\n  charStr += buffer.toString(this.encoding, 0, end);\n\n  var end = charStr.length - 1;\n  var charCode = charStr.charCodeAt(end);\n  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character\n  if (charCode >= 0xD800 && charCode <= 0xDBFF) {\n    var size = this.surrogateSize;\n    this.charLength += size;\n    this.charReceived += size;\n    this.charBuffer.copy(this.charBuffer, size, 0, size);\n    buffer.copy(this.charBuffer, 0, 0, size);\n    return charStr.substring(0, end);\n  }\n\n  // or just emit the charStr\n  return charStr;\n};\n\n// detectIncompleteChar determines if there is an incomplete UTF-8 character at\n// the end of the given buffer. If so, it sets this.charLength to the byte\n// length that character, and sets this.charReceived to the number of bytes\n// that are available for this character.\nStringDecoder.prototype.detectIncompleteChar = function(buffer) {\n  // determine how many bytes we have to check at the end of this buffer\n  var i = (buffer.length >= 3) ? 3 : buffer.length;\n\n  // Figure out if one of the last i bytes of our buffer announces an\n  // incomplete char.\n  for (; i > 0; i--) {\n    var c = buffer[buffer.length - i];\n\n    // See http://en.wikipedia.org/wiki/UTF-8#Description\n\n    // 110XXXXX\n    if (i == 1 && c >> 5 == 0x06) {\n      this.charLength = 2;\n      break;\n    }\n\n    // 1110XXXX\n    if (i <= 2 && c >> 4 == 0x0E) {\n      this.charLength = 3;\n      break;\n    }\n\n    // 11110XXX\n    if (i <= 3 && c >> 3 == 0x1E) {\n      this.charLength = 4;\n      break;\n    }\n  }\n  this.charReceived = i;\n};\n\nStringDecoder.prototype.end = function(buffer) {\n  var res = '';\n  if (buffer && buffer.length)\n    res = this.write(buffer);\n\n  if (this.charReceived) {\n    var cr = this.charReceived;\n    var buf = this.charBuffer;\n    var enc = this.encoding;\n    res += buf.slice(0, cr).toString(enc);\n  }\n\n  return res;\n};\n\nfunction passThroughWrite(buffer) {\n  return buffer.toString(this.encoding);\n}\n\nfunction utf16DetectIncompleteChar(buffer) {\n  this.charReceived = buffer.length % 2;\n  this.charLength = this.charReceived ? 2 : 0;\n}\n\nfunction base64DetectIncompleteChar(buffer) {\n  this.charReceived = buffer.length % 3;\n  this.charLength = this.charReceived ? 3 : 0;\n}\n\n},{\"buffer\":80}],111:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar punycode = require('punycode');\n\nexports.parse = urlParse;\nexports.resolve = urlResolve;\nexports.resolveObject = urlResolveObject;\nexports.format = urlFormat;\n\nexports.Url = Url;\n\nfunction Url() {\n  this.protocol = null;\n  this.slashes = null;\n  this.auth = null;\n  this.host = null;\n  this.port = null;\n  this.hostname = null;\n  this.hash = null;\n  this.search = null;\n  this.query = null;\n  this.pathname = null;\n  this.path = null;\n  this.href = null;\n}\n\n// Reference: RFC 3986, RFC 1808, RFC 2396\n\n// define these here so at least they only have to be\n// compiled once on the first module load.\nvar protocolPattern = /^([a-z0-9.+-]+:)/i,\n    portPattern = /:[0-9]*$/,\n\n    // RFC 2396: characters reserved for delimiting URLs.\n    // We actually just auto-escape these.\n    delims = ['<', '>', '\"', '`', ' ', '\\r', '\\n', '\\t'],\n\n    // RFC 2396: characters not allowed for various reasons.\n    unwise = ['{', '}', '|', '\\\\', '^', '`'].concat(delims),\n\n    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.\n    autoEscape = ['\\''].concat(unwise),\n    // Characters that are never ever allowed in a hostname.\n    // Note that any invalid chars are also handled, but these\n    // are the ones that are *expected* to be seen, so we fast-path\n    // them.\n    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),\n    hostEndingChars = ['/', '?', '#'],\n    hostnameMaxLen = 255,\n    hostnamePartPattern = /^[a-z0-9A-Z_-]{0,63}$/,\n    hostnamePartStart = /^([a-z0-9A-Z_-]{0,63})(.*)$/,\n    // protocols that can allow \"unsafe\" and \"unwise\" chars.\n    unsafeProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that never have a hostname.\n    hostlessProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that always contain a // bit.\n    slashedProtocol = {\n      'http': true,\n      'https': true,\n      'ftp': true,\n      'gopher': true,\n      'file': true,\n      'http:': true,\n      'https:': true,\n      'ftp:': true,\n      'gopher:': true,\n      'file:': true\n    },\n    querystring = require('querystring');\n\nfunction urlParse(url, parseQueryString, slashesDenoteHost) {\n  if (url && isObject(url) && url instanceof Url) return url;\n\n  var u = new Url;\n  u.parse(url, parseQueryString, slashesDenoteHost);\n  return u;\n}\n\nUrl.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {\n  if (!isString(url)) {\n    throw new TypeError(\"Parameter 'url' must be a string, not \" + typeof url);\n  }\n\n  var rest = url;\n\n  // trim before proceeding.\n  // This is to support parse stuff like \"  http://foo.com  \\n\"\n  rest = rest.trim();\n\n  var proto = protocolPattern.exec(rest);\n  if (proto) {\n    proto = proto[0];\n    var lowerProto = proto.toLowerCase();\n    this.protocol = lowerProto;\n    rest = rest.substr(proto.length);\n  }\n\n  // figure out if it's got a host\n  // user@server is *always* interpreted as a hostname, and url\n  // resolution will treat //foo/bar as host=foo,path=bar because that's\n  // how the browser resolves relative URLs.\n  if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)) {\n    var slashes = rest.substr(0, 2) === '//';\n    if (slashes && !(proto && hostlessProtocol[proto])) {\n      rest = rest.substr(2);\n      this.slashes = true;\n    }\n  }\n\n  if (!hostlessProtocol[proto] &&\n      (slashes || (proto && !slashedProtocol[proto]))) {\n\n    // there's a hostname.\n    // the first instance of /, ?, ;, or # ends the host.\n    //\n    // If there is an @ in the hostname, then non-host chars *are* allowed\n    // to the left of the last @ sign, unless some host-ending character\n    // comes *before* the @-sign.\n    // URLs are obnoxious.\n    //\n    // ex:\n    // http://a@b@c/ => user:a@b host:c\n    // http://a@b?@c => user:a host:c path:/?@c\n\n    // v0.12 TODO(isaacs): This is not quite how Chrome does things.\n    // Review our test case against browsers more comprehensively.\n\n    // find the first instance of any hostEndingChars\n    var hostEnd = -1;\n    for (var i = 0; i < hostEndingChars.length; i++) {\n      var hec = rest.indexOf(hostEndingChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n        hostEnd = hec;\n    }\n\n    // at this point, either we have an explicit point where the\n    // auth portion cannot go past, or the last @ char is the decider.\n    var auth, atSign;\n    if (hostEnd === -1) {\n      // atSign can be anywhere.\n      atSign = rest.lastIndexOf('@');\n    } else {\n      // atSign must be in auth portion.\n      // http://a@b/c@d => host:b auth:a path:/c@d\n      atSign = rest.lastIndexOf('@', hostEnd);\n    }\n\n    // Now we have a portion which is definitely the auth.\n    // Pull that off.\n    if (atSign !== -1) {\n      auth = rest.slice(0, atSign);\n      rest = rest.slice(atSign + 1);\n      this.auth = decodeURIComponent(auth);\n    }\n\n    // the host is the remaining to the left of the first non-host char\n    hostEnd = -1;\n    for (var i = 0; i < nonHostChars.length; i++) {\n      var hec = rest.indexOf(nonHostChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n        hostEnd = hec;\n    }\n    // if we still have not hit it, then the entire thing is a host.\n    if (hostEnd === -1)\n      hostEnd = rest.length;\n\n    this.host = rest.slice(0, hostEnd);\n    rest = rest.slice(hostEnd);\n\n    // pull out port.\n    this.parseHost();\n\n    // we've indicated that there is a hostname,\n    // so even if it's empty, it has to be present.\n    this.hostname = this.hostname || '';\n\n    // if hostname begins with [ and ends with ]\n    // assume that it's an IPv6 address.\n    var ipv6Hostname = this.hostname[0] === '[' &&\n        this.hostname[this.hostname.length - 1] === ']';\n\n    // validate a little.\n    if (!ipv6Hostname) {\n      var hostparts = this.hostname.split(/\\./);\n      for (var i = 0, l = hostparts.length; i < l; i++) {\n        var part = hostparts[i];\n        if (!part) continue;\n        if (!part.match(hostnamePartPattern)) {\n          var newpart = '';\n          for (var j = 0, k = part.length; j < k; j++) {\n            if (part.charCodeAt(j) > 127) {\n              // we replace non-ASCII char with a temporary placeholder\n              // we need this to make sure size of hostname is not\n              // broken by replacing non-ASCII by nothing\n              newpart += 'x';\n            } else {\n              newpart += part[j];\n            }\n          }\n          // we test again with ASCII char only\n          if (!newpart.match(hostnamePartPattern)) {\n            var validParts = hostparts.slice(0, i);\n            var notHost = hostparts.slice(i + 1);\n            var bit = part.match(hostnamePartStart);\n            if (bit) {\n              validParts.push(bit[1]);\n              notHost.unshift(bit[2]);\n            }\n            if (notHost.length) {\n              rest = '/' + notHost.join('.') + rest;\n            }\n            this.hostname = validParts.join('.');\n            break;\n          }\n        }\n      }\n    }\n\n    if (this.hostname.length > hostnameMaxLen) {\n      this.hostname = '';\n    } else {\n      // hostnames are always lower case.\n      this.hostname = this.hostname.toLowerCase();\n    }\n\n    if (!ipv6Hostname) {\n      // IDNA Support: Returns a puny coded representation of \"domain\".\n      // It only converts the part of the domain name that\n      // has non ASCII characters. I.e. it dosent matter if\n      // you call it with a domain that already is in ASCII.\n      var domainArray = this.hostname.split('.');\n      var newOut = [];\n      for (var i = 0; i < domainArray.length; ++i) {\n        var s = domainArray[i];\n        newOut.push(s.match(/[^A-Za-z0-9_-]/) ?\n            'xn--' + punycode.encode(s) : s);\n      }\n      this.hostname = newOut.join('.');\n    }\n\n    var p = this.port ? ':' + this.port : '';\n    var h = this.hostname || '';\n    this.host = h + p;\n    this.href += this.host;\n\n    // strip [ and ] from the hostname\n    // the host field still retains them, though\n    if (ipv6Hostname) {\n      this.hostname = this.hostname.substr(1, this.hostname.length - 2);\n      if (rest[0] !== '/') {\n        rest = '/' + rest;\n      }\n    }\n  }\n\n  // now rest is set to the post-host stuff.\n  // chop off any delim chars.\n  if (!unsafeProtocol[lowerProto]) {\n\n    // First, make 100% sure that any \"autoEscape\" chars get\n    // escaped, even if encodeURIComponent doesn't think they\n    // need to be.\n    for (var i = 0, l = autoEscape.length; i < l; i++) {\n      var ae = autoEscape[i];\n      var esc = encodeURIComponent(ae);\n      if (esc === ae) {\n        esc = escape(ae);\n      }\n      rest = rest.split(ae).join(esc);\n    }\n  }\n\n\n  // chop off from the tail first.\n  var hash = rest.indexOf('#');\n  if (hash !== -1) {\n    // got a fragment string.\n    this.hash = rest.substr(hash);\n    rest = rest.slice(0, hash);\n  }\n  var qm = rest.indexOf('?');\n  if (qm !== -1) {\n    this.search = rest.substr(qm);\n    this.query = rest.substr(qm + 1);\n    if (parseQueryString) {\n      this.query = querystring.parse(this.query);\n    }\n    rest = rest.slice(0, qm);\n  } else if (parseQueryString) {\n    // no query string, but parseQueryString still requested\n    this.search = '';\n    this.query = {};\n  }\n  if (rest) this.pathname = rest;\n  if (slashedProtocol[lowerProto] &&\n      this.hostname && !this.pathname) {\n    this.pathname = '/';\n  }\n\n  //to support http.request\n  if (this.pathname || this.search) {\n    var p = this.pathname || '';\n    var s = this.search || '';\n    this.path = p + s;\n  }\n\n  // finally, reconstruct the href based on what has been validated.\n  this.href = this.format();\n  return this;\n};\n\n// format a parsed object into a url string\nfunction urlFormat(obj) {\n  // ensure it's an object, and not a string url.\n  // If it's an obj, this is a no-op.\n  // this way, you can call url_format() on strings\n  // to clean up potentially wonky urls.\n  if (isString(obj)) obj = urlParse(obj);\n  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);\n  return obj.format();\n}\n\nUrl.prototype.format = function() {\n  var auth = this.auth || '';\n  if (auth) {\n    auth = encodeURIComponent(auth);\n    auth = auth.replace(/%3A/i, ':');\n    auth += '@';\n  }\n\n  var protocol = this.protocol || '',\n      pathname = this.pathname || '',\n      hash = this.hash || '',\n      host = false,\n      query = '';\n\n  if (this.host) {\n    host = auth + this.host;\n  } else if (this.hostname) {\n    host = auth + (this.hostname.indexOf(':') === -1 ?\n        this.hostname :\n        '[' + this.hostname + ']');\n    if (this.port) {\n      host += ':' + this.port;\n    }\n  }\n\n  if (this.query &&\n      isObject(this.query) &&\n      Object.keys(this.query).length) {\n    query = querystring.stringify(this.query);\n  }\n\n  var search = this.search || (query && ('?' + query)) || '';\n\n  if (protocol && protocol.substr(-1) !== ':') protocol += ':';\n\n  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.\n  // unless they had them to begin with.\n  if (this.slashes ||\n      (!protocol || slashedProtocol[protocol]) && host !== false) {\n    host = '//' + (host || '');\n    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;\n  } else if (!host) {\n    host = '';\n  }\n\n  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;\n  if (search && search.charAt(0) !== '?') search = '?' + search;\n\n  pathname = pathname.replace(/[?#]/g, function(match) {\n    return encodeURIComponent(match);\n  });\n  search = search.replace('#', '%23');\n\n  return protocol + host + pathname + search + hash;\n};\n\nfunction urlResolve(source, relative) {\n  return urlParse(source, false, true).resolve(relative);\n}\n\nUrl.prototype.resolve = function(relative) {\n  return this.resolveObject(urlParse(relative, false, true)).format();\n};\n\nfunction urlResolveObject(source, relative) {\n  if (!source) return relative;\n  return urlParse(source, false, true).resolveObject(relative);\n}\n\nUrl.prototype.resolveObject = function(relative) {\n  if (isString(relative)) {\n    var rel = new Url();\n    rel.parse(relative, false, true);\n    relative = rel;\n  }\n\n  var result = new Url();\n  Object.keys(this).forEach(function(k) {\n    result[k] = this[k];\n  }, this);\n\n  // hash is always overridden, no matter what.\n  // even href=\"\" will remove it.\n  result.hash = relative.hash;\n\n  // if the relative url is empty, then there's nothing left to do here.\n  if (relative.href === '') {\n    result.href = result.format();\n    return result;\n  }\n\n  // hrefs like //foo/bar always cut to the protocol.\n  if (relative.slashes && !relative.protocol) {\n    // take everything except the protocol from relative\n    Object.keys(relative).forEach(function(k) {\n      if (k !== 'protocol')\n        result[k] = relative[k];\n    });\n\n    //urlParse appends trailing / to urls like http://www.example.com\n    if (slashedProtocol[result.protocol] &&\n        result.hostname && !result.pathname) {\n      result.path = result.pathname = '/';\n    }\n\n    result.href = result.format();\n    return result;\n  }\n\n  if (relative.protocol && relative.protocol !== result.protocol) {\n    // if it's a known url protocol, then changing\n    // the protocol does weird things\n    // first, if it's not file:, then we MUST have a host,\n    // and if there was a path\n    // to begin with, then we MUST have a path.\n    // if it is file:, then the host is dropped,\n    // because that's known to be hostless.\n    // anything else is assumed to be absolute.\n    if (!slashedProtocol[relative.protocol]) {\n      Object.keys(relative).forEach(function(k) {\n        result[k] = relative[k];\n      });\n      result.href = result.format();\n      return result;\n    }\n\n    result.protocol = relative.protocol;\n    if (!relative.host && !hostlessProtocol[relative.protocol]) {\n      var relPath = (relative.pathname || '').split('/');\n      while (relPath.length && !(relative.host = relPath.shift()));\n      if (!relative.host) relative.host = '';\n      if (!relative.hostname) relative.hostname = '';\n      if (relPath[0] !== '') relPath.unshift('');\n      if (relPath.length < 2) relPath.unshift('');\n      result.pathname = relPath.join('/');\n    } else {\n      result.pathname = relative.pathname;\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    result.host = relative.host || '';\n    result.auth = relative.auth;\n    result.hostname = relative.hostname || relative.host;\n    result.port = relative.port;\n    // to support http.request\n    if (result.pathname || result.search) {\n      var p = result.pathname || '';\n      var s = result.search || '';\n      result.path = p + s;\n    }\n    result.slashes = result.slashes || relative.slashes;\n    result.href = result.format();\n    return result;\n  }\n\n  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),\n      isRelAbs = (\n          relative.host ||\n          relative.pathname && relative.pathname.charAt(0) === '/'\n      ),\n      mustEndAbs = (isRelAbs || isSourceAbs ||\n                    (result.host && relative.pathname)),\n      removeAllDots = mustEndAbs,\n      srcPath = result.pathname && result.pathname.split('/') || [],\n      relPath = relative.pathname && relative.pathname.split('/') || [],\n      psychotic = result.protocol && !slashedProtocol[result.protocol];\n\n  // if the url is a non-slashed url, then relative\n  // links like ../.. should be able\n  // to crawl up to the hostname, as well.  This is strange.\n  // result.protocol has already been set by now.\n  // Later on, put the first path part into the host field.\n  if (psychotic) {\n    result.hostname = '';\n    result.port = null;\n    if (result.host) {\n      if (srcPath[0] === '') srcPath[0] = result.host;\n      else srcPath.unshift(result.host);\n    }\n    result.host = '';\n    if (relative.protocol) {\n      relative.hostname = null;\n      relative.port = null;\n      if (relative.host) {\n        if (relPath[0] === '') relPath[0] = relative.host;\n        else relPath.unshift(relative.host);\n      }\n      relative.host = null;\n    }\n    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');\n  }\n\n  if (isRelAbs) {\n    // it's absolute.\n    result.host = (relative.host || relative.host === '') ?\n                  relative.host : result.host;\n    result.hostname = (relative.hostname || relative.hostname === '') ?\n                      relative.hostname : result.hostname;\n    result.search = relative.search;\n    result.query = relative.query;\n    srcPath = relPath;\n    // fall through to the dot-handling below.\n  } else if (relPath.length) {\n    // it's relative\n    // throw away the existing file, and take the new path instead.\n    if (!srcPath) srcPath = [];\n    srcPath.pop();\n    srcPath = srcPath.concat(relPath);\n    result.search = relative.search;\n    result.query = relative.query;\n  } else if (!isNullOrUndefined(relative.search)) {\n    // just pull out the search.\n    // like href='?foo'.\n    // Put this after the other two cases because it simplifies the booleans\n    if (psychotic) {\n      result.hostname = result.host = srcPath.shift();\n      //occationaly the auth can get stuck only in host\n      //this especialy happens in cases like\n      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n      var authInHost = result.host && result.host.indexOf('@') > 0 ?\n                       result.host.split('@') : false;\n      if (authInHost) {\n        result.auth = authInHost.shift();\n        result.host = result.hostname = authInHost.shift();\n      }\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    //to support http.request\n    if (!isNull(result.pathname) || !isNull(result.search)) {\n      result.path = (result.pathname ? result.pathname : '') +\n                    (result.search ? result.search : '');\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  if (!srcPath.length) {\n    // no path at all.  easy.\n    // we've already handled the other stuff above.\n    result.pathname = null;\n    //to support http.request\n    if (result.search) {\n      result.path = '/' + result.search;\n    } else {\n      result.path = null;\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  // if a url ENDs in . or .., then it must get a trailing slash.\n  // however, if it ends in anything else non-slashy,\n  // then it must NOT get a trailing slash.\n  var last = srcPath.slice(-1)[0];\n  var hasTrailingSlash = (\n      (result.host || relative.host) && (last === '.' || last === '..') ||\n      last === '');\n\n  // strip single dots, resolve double dots to parent dir\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = srcPath.length; i >= 0; i--) {\n    last = srcPath[i];\n    if (last == '.') {\n      srcPath.splice(i, 1);\n    } else if (last === '..') {\n      srcPath.splice(i, 1);\n      up++;\n    } else if (up) {\n      srcPath.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (!mustEndAbs && !removeAllDots) {\n    for (; up--; up) {\n      srcPath.unshift('..');\n    }\n  }\n\n  if (mustEndAbs && srcPath[0] !== '' &&\n      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {\n    srcPath.unshift('');\n  }\n\n  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {\n    srcPath.push('');\n  }\n\n  var isAbsolute = srcPath[0] === '' ||\n      (srcPath[0] && srcPath[0].charAt(0) === '/');\n\n  // put the host back\n  if (psychotic) {\n    result.hostname = result.host = isAbsolute ? '' :\n                                    srcPath.length ? srcPath.shift() : '';\n    //occationaly the auth can get stuck only in host\n    //this especialy happens in cases like\n    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n    var authInHost = result.host && result.host.indexOf('@') > 0 ?\n                     result.host.split('@') : false;\n    if (authInHost) {\n      result.auth = authInHost.shift();\n      result.host = result.hostname = authInHost.shift();\n    }\n  }\n\n  mustEndAbs = mustEndAbs || (result.host && srcPath.length);\n\n  if (mustEndAbs && !isAbsolute) {\n    srcPath.unshift('');\n  }\n\n  if (!srcPath.length) {\n    result.pathname = null;\n    result.path = null;\n  } else {\n    result.pathname = srcPath.join('/');\n  }\n\n  //to support request.http\n  if (!isNull(result.pathname) || !isNull(result.search)) {\n    result.path = (result.pathname ? result.pathname : '') +\n                  (result.search ? result.search : '');\n  }\n  result.auth = relative.auth || result.auth;\n  result.slashes = result.slashes || relative.slashes;\n  result.href = result.format();\n  return result;\n};\n\nUrl.prototype.parseHost = function() {\n  var host = this.host;\n  var port = portPattern.exec(host);\n  if (port) {\n    port = port[0];\n    if (port !== ':') {\n      this.port = port.substr(1);\n    }\n    host = host.substr(0, host.length - port.length);\n  }\n  if (host) this.hostname = host;\n};\n\nfunction isString(arg) {\n  return typeof arg === \"string\";\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isNull(arg) {\n  return arg === null;\n}\nfunction isNullOrUndefined(arg) {\n  return  arg == null;\n}\n\n},{\"punycode\":94,\"querystring\":97}],112:[function(require,module,exports){\nmodule.exports = function isBuffer(arg) {\n  return arg && typeof arg === 'object'\n    && typeof arg.copy === 'function'\n    && typeof arg.fill === 'function'\n    && typeof arg.readUInt8 === 'function';\n}\n},{}],113:[function(require,module,exports){\n(function (process,global){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nexports.deprecate = function(fn, msg) {\n  // Allow for deprecating things in the process of starting up.\n  if (isUndefined(global.process)) {\n    return function() {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  if (process.noDeprecation === true) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n};\n\n\nvar debugs = {};\nvar debugEnviron;\nexports.debuglog = function(set) {\n  if (isUndefined(debugEnviron))\n    debugEnviron = process.env.NODE_DEBUG || '';\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n  if (isError(value)\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = require('./support/isBuffer');\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\nexports.inherits = require('inherits');\n\nexports._extend = function(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\n}).call(this,require('_process'),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"./support/isBuffer\":112,\"_process\":93,\"inherits\":90}],114:[function(require,module,exports){\n\"use strict\";\n\nvar Node = require('./node');\nvar unescapeString = require('./common').unescapeString;\n\nvar CODE_INDENT = 4;\n\nvar C_NEWLINE = 10;\nvar C_GREATERTHAN = 62;\nvar C_SPACE = 32;\nvar C_OPEN_BRACKET = 91;\n\nvar InlineParser = require('./inlines');\n\nvar BLOCKTAGNAME = '(?:article|header|aside|hgroup|iframe|blockquote|hr|body|li|map|button|object|canvas|ol|caption|output|col|p|colgroup|pre|dd|progress|div|section|dl|table|td|dt|tbody|embed|textarea|fieldset|tfoot|figcaption|th|figure|thead|footer|footer|tr|form|ul|h1|h2|h3|h4|h5|h6|video|script|style)';\n\nvar HTMLBLOCKOPEN = \"<(?:\" + BLOCKTAGNAME + \"(?:[\\\\s/>]|$)\" + \"|\" +\n        \"/\" + BLOCKTAGNAME + \"(?:[\\\\s>]|$)\" + \"|\" + \"[?!])\";\n\nvar reHtmlBlockOpen = new RegExp('^' + HTMLBLOCKOPEN, 'i');\n\nvar reHrule = /^(?:(?:\\* *){3,}|(?:_ *){3,}|(?:- *){3,}) *$/;\n\nvar reMaybeSpecial = /^[#`~*+_=<>0-9-]/;\n\nvar reNonSpace = /[^ \\t\\f\\v\\r\\n]/;\n\nvar reBulletListMarker = /^[*+-]( +|$)/;\n\nvar reOrderedListMarker = /^(\\d+)([.)])( +|$)/;\n\nvar reATXHeaderMarker = /^#{1,6}(?: +|$)/;\n\nvar reCodeFence = /^`{3,}(?!.*`)|^~{3,}(?!.*~)/;\n\nvar reClosingCodeFence = /^(?:`{3,}|~{3,})(?= *$)/;\n\nvar reSetextHeaderLine = /^(?:=+|-+) *$/;\n\nvar reLineEnding = /\\r\\n|\\n|\\r/;\n\n// Returns true if string contains only space characters.\nvar isBlank = function(s) {\n    return !(reNonSpace.test(s));\n};\n\nvar tabSpaces = ['    ', '   ', '  ', ' '];\n\n// Convert tabs to spaces on each line using a 4-space tab stop.\nvar detabLine = function(text) {\n    var start = 0;\n    var offset;\n    var lastStop = 0;\n\n    while ((offset = text.indexOf('\\t', start)) !== -1) {\n        var numspaces = (offset - lastStop) % 4;\n        var spaces = tabSpaces[numspaces];\n        text = text.slice(0, offset) + spaces + text.slice(offset + 1);\n        lastStop = offset + numspaces;\n        start = lastStop;\n    }\n\n    return text;\n};\n\nvar peek = function(ln, pos) {\n    if (pos < ln.length) {\n        return ln.charCodeAt(pos);\n    } else {\n        return -1;\n    }\n};\n\n// DOC PARSER\n\n// These are methods of a Parser object, defined below.\n\n// Returns true if block ends with a blank line, descending if needed\n// into lists and sublists.\nvar endsWithBlankLine = function(block) {\n    while (block) {\n        if (block._lastLineBlank) {\n            return true;\n        }\n        var t = block.type;\n        if (t === 'List' || t === 'Item') {\n            block = block._lastChild;\n        } else {\n            break;\n        }\n    }\n    return false;\n};\n\n// Break out of all containing lists, resetting the tip of the\n// document to the parent of the highest list, and finalizing\n// all the lists.  (This is used to implement the \"two blank lines\n// break of of all lists\" feature.)\nvar breakOutOfLists = function(block) {\n    var b = block;\n    var last_list = null;\n    do {\n        if (b.type === 'List') {\n            last_list = b;\n        }\n        b = b._parent;\n    } while (b);\n\n    if (last_list) {\n        while (block !== last_list) {\n            this.finalize(block, this.lineNumber);\n            block = block._parent;\n        }\n        this.finalize(last_list, this.lineNumber);\n        this.tip = last_list._parent;\n    }\n};\n\n// Add a line to the block at the tip.  We assume the tip\n// can accept lines -- that check should be done before calling this.\nvar addLine = function() {\n    this.tip._string_content += this.currentLine.slice(this.offset) + '\\n';\n};\n\n// Add block of type tag as a child of the tip.  If the tip can't\n// accept children, close and finalize it and try its parent,\n// and so on til we find a block that can accept children.\nvar addChild = function(tag, offset) {\n    while (!this.blocks[this.tip.type].canContain(tag)) {\n        this.finalize(this.tip, this.lineNumber - 1);\n    }\n\n    var column_number = offset + 1; // offset 0 = column 1\n    var newBlock = new Node(tag, [[this.lineNumber, column_number], [0, 0]]);\n    newBlock._string_content = '';\n    this.tip.appendChild(newBlock);\n    this.tip = newBlock;\n    return newBlock;\n};\n\n// Parse a list marker and return data on the marker (type,\n// start, delimiter, bullet character, padding) or null.\nvar parseListMarker = function(ln, offset, indent) {\n    var rest = ln.slice(offset);\n    var match;\n    var spaces_after_marker;\n    var data = { type: null,\n                 tight: true,  // lists are tight by default\n                 bulletChar: null,\n                 start: null,\n                 delimiter: null,\n                 padding: null,\n                 markerOffset: indent };\n    if ((match = rest.match(reBulletListMarker))) {\n        spaces_after_marker = match[1].length;\n        data.type = 'Bullet';\n        data.bulletChar = match[0][0];\n\n    } else if ((match = rest.match(reOrderedListMarker))) {\n        spaces_after_marker = match[3].length;\n        data.type = 'Ordered';\n        data.start = parseInt(match[1]);\n        data.delimiter = match[2];\n    } else {\n        return null;\n    }\n    var blank_item = match[0].length === rest.length;\n    if (spaces_after_marker >= 5 ||\n        spaces_after_marker < 1 ||\n        blank_item) {\n        data.padding = match[0].length - spaces_after_marker + 1;\n    } else {\n        data.padding = match[0].length;\n    }\n    return data;\n};\n\n// Returns true if the two list items are of the same type,\n// with the same delimiter and bullet character.  This is used\n// in agglomerating list items into lists.\nvar listsMatch = function(list_data, item_data) {\n    return (list_data.type === item_data.type &&\n            list_data.delimiter === item_data.delimiter &&\n            list_data.bulletChar === item_data.bulletChar);\n};\n\n// Finalize and close any unmatched blocks. Returns true.\nvar closeUnmatchedBlocks = function() {\n    if (!this.allClosed) {\n        // finalize any blocks not matched\n        while (this.oldtip !== this.lastMatchedContainer) {\n            var parent = this.oldtip._parent;\n            this.finalize(this.oldtip, this.lineNumber - 1);\n            this.oldtip = parent;\n        }\n        this.allClosed = true;\n    }\n};\n\n// 'finalize' is run when the block is closed.\n// 'continue' is run to check whether the block is continuing\n// at a certain line and offset (e.g. whether a block quote\n// contains a `>`.  It returns 0 for matched, 1 for not matched,\n// and 2 for \"we've dealt with this line completely, go to next.\"\nvar blocks = {\n    Document: {\n        continue: function() { return 0; },\n        finalize: function() { return; },\n        canContain: function(t) { return (t !== 'Item'); },\n        acceptsLines: false\n    },\n    List: {\n        continue: function() { return 0; },\n        finalize: function(parser, block) {\n            var item = block._firstChild;\n            while (item) {\n                // check for non-final list item ending with blank line:\n                if (endsWithBlankLine(item) && item._next) {\n                    block._listData.tight = false;\n                    break;\n                }\n                // recurse into children of list item, to see if there are\n                // spaces between any of them:\n                var subitem = item._firstChild;\n                while (subitem) {\n                    if (endsWithBlankLine(subitem) &&\n                        (item._next || subitem._next)) {\n                        block._listData.tight = false;\n                        break;\n                    }\n                    subitem = subitem._next;\n                }\n                item = item._next;\n            }\n        },\n        canContain: function(t) { return (t === 'Item'); },\n        acceptsLines: false\n    },\n    BlockQuote: {\n        continue: function(parser) {\n            var ln = parser.currentLine;\n            if (!parser.indented &&\n                peek(ln, parser.nextNonspace) === C_GREATERTHAN) {\n                parser.offset = parser.nextNonspace + 1;\n                if (peek(ln, parser.offset) === C_SPACE) {\n                    parser.offset++;\n                }\n            } else {\n                return 1;\n            }\n            return 0;\n        },\n        finalize: function() { return; },\n        canContain: function(t) { return (t !== 'Item'); },\n        acceptsLines: false\n    },\n    Item: {\n        continue: function(parser, container) {\n            if (parser.blank) {\n                parser.offset = parser.nextNonspace;\n            } else if (parser.indent >=\n                       container._listData.markerOffset +\n                       container._listData.padding) {\n                parser.offset += container._listData.markerOffset +\n                    container._listData.padding;\n            } else {\n                return 1;\n            }\n            return 0;\n        },\n        finalize: function() { return; },\n        canContain: function(t) { return (t !== 'Item'); },\n        acceptsLines: false\n    },\n    Header: {\n        continue: function() {\n            // a header can never container > 1 line, so fail to match:\n            return 1;\n        },\n        finalize: function() { return; },\n        canContain: function() { return false; },\n        acceptsLines: false\n    },\n    HorizontalRule: {\n        continue: function() {\n            // an hrule can never container > 1 line, so fail to match:\n            return 1;\n        },\n        finalize: function() { return; },\n        canContain: function() { return false; },\n        acceptsLines: false\n    },\n    CodeBlock: {\n        continue: function(parser, container) {\n            var ln = parser.currentLine;\n            var indent = parser.indent;\n            if (container._isFenced) { // fenced\n                var match = (indent <= 3 &&\n                    ln.charAt(parser.nextNonspace) === container._fenceChar &&\n                    ln.slice(parser.nextNonspace).match(reClosingCodeFence));\n                if (match && match[0].length >= container._fenceLength) {\n                    // closing fence - we're at end of line, so we can return\n                    parser.finalize(container, parser.lineNumber);\n                    return 2;\n                } else {\n                    // skip optional spaces of fence offset\n                    var i = container._fenceOffset;\n                    while (i > 0 && peek(ln, parser.offset) === C_SPACE) {\n                        parser.offset++;\n                        i--;\n                    }\n                }\n            } else { // indented\n                if (indent >= CODE_INDENT) {\n                    parser.offset += CODE_INDENT;\n                } else if (parser.blank) {\n                    parser.offset = parser.nextNonspace;\n                } else {\n                    return 1;\n                }\n            }\n            return 0;\n        },\n        finalize: function(parser, block) {\n            if (block._isFenced) { // fenced\n                // first line becomes info string\n                var content = block._string_content;\n                var newlinePos = content.indexOf('\\n');\n                var firstLine = content.slice(0, newlinePos);\n                var rest = content.slice(newlinePos + 1);\n                block.info = unescapeString(firstLine.trim());\n                block._literal = rest;\n            } else { // indented\n                block._literal = block._string_content.replace(/(\\n *)+$/, '\\n');\n            }\n            block._string_content = null; // allow GC\n        },\n        canContain: function() { return false; },\n        acceptsLines: true\n    },\n    HtmlBlock: {\n        continue: function(parser) {\n            return (parser.blank ? 1 : 0);\n        },\n        finalize: function(parser, block) {\n            block._literal = block._string_content.replace(/(\\n *)+$/, '');\n            block._string_content = null; // allow GC\n        },\n        canContain: function() { return false; },\n        acceptsLines: true\n    },\n    Paragraph: {\n        continue: function(parser) {\n            return (parser.blank ? 1 : 0);\n        },\n        finalize: function(parser, block) {\n            var pos;\n            var hasReferenceDefs = false;\n\n            // try parsing the beginning as link reference definitions:\n            while (peek(block._string_content, 0) === C_OPEN_BRACKET &&\n                   (pos =\n                    parser.inlineParser.parseReference(block._string_content,\n                                                       parser.refmap))) {\n                block._string_content = block._string_content.slice(pos);\n                hasReferenceDefs = true;\n            }\n            if (hasReferenceDefs && isBlank(block._string_content)) {\n                block.unlink();\n            }\n        },\n        canContain: function() { return false; },\n        acceptsLines: true\n    }\n};\n\n// block start functions.  Return values:\n// 0 = no match\n// 1 = matched container, keep going\n// 2 = matched leaf, no more block starts\nvar blockStarts = [\n    // block quote\n    function(parser) {\n        if (!parser.indented &&\n            peek(parser.currentLine, parser.nextNonspace) === C_GREATERTHAN) {\n            parser.offset = parser.nextNonspace + 1;\n            // optional following space\n            if (peek(parser.currentLine, parser.offset) === C_SPACE) {\n                parser.offset++;\n            }\n            parser.closeUnmatchedBlocks();\n            parser.addChild('BlockQuote', parser.nextNonspace);\n            return 1;\n        } else {\n            return 0;\n        }\n    },\n\n    // ATX header\n    function(parser) {\n        var match;\n        if (!parser.indented &&\n            (match = parser.currentLine.slice(parser.nextNonspace).match(reATXHeaderMarker))) {\n            parser.offset = parser.nextNonspace + match[0].length;\n            parser.closeUnmatchedBlocks();\n            var container = parser.addChild('Header', parser.nextNonspace);\n            container.level = match[0].trim().length; // number of #s\n            // remove trailing ###s:\n            container._string_content =\n                parser.currentLine.slice(parser.offset).replace(/^ *#+ *$/, '').replace(/ +#+ *$/, '');\n            parser.offset = parser.currentLine.length;\n            return 2;\n        } else {\n            return 0;\n        }\n    },\n\n    // Fenced code block\n    function(parser) {\n        var match;\n        if (!parser.indented &&\n            (match = parser.currentLine.slice(parser.nextNonspace).match(reCodeFence))) {\n            var fenceLength = match[0].length;\n            parser.closeUnmatchedBlocks();\n            var container = parser.addChild('CodeBlock', parser.nextNonspace);\n            container._isFenced = true;\n            container._fenceLength = fenceLength;\n            container._fenceChar = match[0][0];\n            container._fenceOffset = parser.indent;\n            parser.offset = parser.nextNonspace + fenceLength;\n            return 2;\n        } else {\n            return 0;\n        }\n    },\n\n    // HTML block\n    function(parser) {\n        if (!parser.indented &&\n            reHtmlBlockOpen.test(parser.currentLine.slice(parser.nextNonspace))) {\n            parser.closeUnmatchedBlocks();\n            parser.addChild('HtmlBlock', parser.offset);\n            // don't adjust parser.offset; spaces are part of block\n            return 2;\n        } else {\n            return 0;\n        }\n    },\n\n    // Setext header\n    function(parser, container) {\n        var match;\n        if (!parser.indented &&\n            container.type === 'Paragraph' &&\n                   (container._string_content.indexOf('\\n') ===\n                      container._string_content.length - 1) &&\n                   ((match = parser.currentLine.slice(parser.nextNonspace).match(reSetextHeaderLine)))) {\n            parser.closeUnmatchedBlocks();\n            var header = new Node('Header', container.sourcepos);\n            header.level = match[0][0] === '=' ? 1 : 2;\n            header._string_content = container._string_content;\n            container.insertAfter(header);\n            container.unlink();\n            parser.tip = header;\n            parser.offset = parser.currentLine.length;\n            return 2;\n        } else {\n            return 0;\n        }\n    },\n\n    // hrule\n    function(parser) {\n        if (!parser.indented &&\n            reHrule.test(parser.currentLine.slice(parser.nextNonspace))) {\n            parser.closeUnmatchedBlocks();\n            parser.addChild('HorizontalRule', parser.nextNonspace);\n            parser.offset = parser.currentLine.length;\n            return 2;\n        } else {\n            return 0;\n        }\n    },\n\n    // list item\n    function(parser, container) {\n        var data;\n        if ((data = parseListMarker(parser.currentLine,\n                                    parser.nextNonspace, parser.indent))) {\n            parser.closeUnmatchedBlocks();\n            if (parser.indented && parser.tip.type !== 'List') {\n                return 0;\n            }\n            parser.offset = parser.nextNonspace + data.padding;\n\n            // add the list if needed\n            if (parser.tip.type !== 'List' ||\n                !(listsMatch(container._listData, data))) {\n                container = parser.addChild('List', parser.nextNonspace);\n                container._listData = data;\n            }\n\n            // add the list item\n            container = parser.addChild('Item', parser.nextNonspace);\n            container._listData = data;\n            return 1;\n        } else {\n            return 0;\n        }\n    },\n\n    // indented code block\n    function(parser) {\n        if (parser.indented &&\n            parser.tip.type !== 'Paragraph' &&\n            !parser.blank) {\n            // indented code\n            parser.offset += CODE_INDENT;\n            parser.closeUnmatchedBlocks();\n            parser.addChild('CodeBlock', parser.offset);\n            return 2;\n        } else {\n            return 0;\n        }\n     }\n\n];\n\nvar findNextNonspace = function() {\n    var currentLine = this.currentLine;\n    var match = currentLine.slice(this.offset).match(reNonSpace);\n    if (match === null) {\n        this.nextNonspace = currentLine.length;\n        this.blank = true;\n    } else {\n        this.nextNonspace = this.offset + match.index;\n        this.blank = false;\n    }\n    this.indent = this.nextNonspace - this.offset;\n    this.indented = this.indent >= CODE_INDENT;\n};\n\n// Analyze a line of text and update the document appropriately.\n// We parse markdown text by calling this on each line of input,\n// then finalizing the document.\nvar incorporateLine = function(ln) {\n    var all_matched = true;\n    var t;\n\n    var container = this.doc;\n    this.oldtip = this.tip;\n    this.offset = 0;\n    this.lineNumber += 1;\n\n    // replace NUL characters for security\n    if (ln.indexOf('\\u0000') !== -1) {\n        ln = ln.replace(/\\0/g, '\\uFFFD');\n    }\n\n    // Convert tabs to spaces:\n    ln = detabLine(ln);\n    this.currentLine = ln;\n\n    // For each containing block, try to parse the associated line start.\n    // Bail out on failure: container will point to the last matching block.\n    // Set all_matched to false if not all containers match.\n    var lastChild;\n    while ((lastChild = container._lastChild) && lastChild._open) {\n        container = lastChild;\n\n        this.findNextNonspace();\n\n        switch (this.blocks[container.type].continue(this, container)) {\n        case 0: // we've matched, keep going\n            break;\n        case 1: // we've failed to match a block\n            all_matched = false;\n            break;\n        case 2: // we've hit end of line for fenced code close and can return\n            this.lastLineLength = ln.length;\n            return;\n        default:\n            throw 'continue returned illegal value, must be 0, 1, or 2';\n        }\n        if (!all_matched) {\n            container = container._parent; // back up to last matching block\n            break;\n        }\n    }\n\n    this.allClosed = (container === this.oldtip);\n    this.lastMatchedContainer = container;\n\n    // Check to see if we've hit 2nd blank line; if so break out of list:\n    if (this.blank && container._lastLineBlank) {\n        this.breakOutOfLists(container);\n    }\n\n    var matchedLeaf = container.type !== 'Paragraph' &&\n            blocks[container.type].acceptsLines;\n    var starts = this.blockStarts;\n    var startsLen = starts.length;\n    // Unless last matched container is a code block, try new container starts,\n    // adding children to the last matched container:\n    while (!matchedLeaf) {\n\n        this.findNextNonspace();\n\n        // this is a little performance optimization:\n        if (!this.indented &&\n            !reMaybeSpecial.test(ln.slice(this.nextNonspace))) {\n            this.offset = this.nextNonspace;\n            break;\n        }\n\n        var i = 0;\n        while (i < startsLen) {\n            var res = starts[i](this, container);\n            if (res === 1) {\n                container = this.tip;\n                break;\n            } else if (res === 2) {\n                container = this.tip;\n                matchedLeaf = true;\n                break;\n            } else {\n                i++;\n            }\n        }\n\n        if (i === startsLen) { // nothing matched\n            this.offset = this.nextNonspace;\n            break;\n        }\n    }\n\n    // What remains at the offset is a text line.  Add the text to the\n    // appropriate container.\n\n   // First check for a lazy paragraph continuation:\n    if (!this.allClosed && !this.blank &&\n        this.tip.type === 'Paragraph') {\n        // lazy paragraph continuation\n        this.addLine();\n\n    } else { // not a lazy continuation\n\n        // finalize any blocks not matched\n        this.closeUnmatchedBlocks();\n        if (this.blank && container.lastChild) {\n            container.lastChild._lastLineBlank = true;\n        }\n\n        t = container.type;\n\n        // Block quote lines are never blank as they start with >\n        // and we don't count blanks in fenced code for purposes of tight/loose\n        // lists or breaking out of lists.  We also don't set _lastLineBlank\n        // on an empty list item, or if we just closed a fenced block.\n        var lastLineBlank = this.blank &&\n            !(t === 'BlockQuote' ||\n              (t === 'CodeBlock' && container._isFenced) ||\n              (t === 'Item' &&\n               !container._firstChild &&\n               container.sourcepos[0][0] === this.lineNumber));\n\n        // propagate lastLineBlank up through parents:\n        var cont = container;\n        while (cont) {\n            cont._lastLineBlank = lastLineBlank;\n            cont = cont._parent;\n        }\n\n        if (this.blocks[t].acceptsLines) {\n            this.addLine();\n        } else if (this.offset < ln.length && !this.blank) {\n            // create paragraph container for line\n            container = this.addChild('Paragraph', this.offset);\n            this.offset = this.nextNonspace;\n            this.addLine();\n        }\n    }\n    this.lastLineLength = ln.length;\n};\n\n// Finalize a block.  Close it and do any necessary postprocessing,\n// e.g. creating string_content from strings, setting the 'tight'\n// or 'loose' status of a list, and parsing the beginnings\n// of paragraphs for reference definitions.  Reset the tip to the\n// parent of the closed block.\nvar finalize = function(block, lineNumber) {\n    var above = block._parent;\n    block._open = false;\n    block.sourcepos[1] = [lineNumber, this.lastLineLength];\n\n    this.blocks[block.type].finalize(this, block);\n\n    this.tip = above;\n};\n\n// Walk through a block & children recursively, parsing string content\n// into inline content where appropriate.\nvar processInlines = function(block) {\n    var node, event, t;\n    var walker = block.walker();\n    this.inlineParser.refmap = this.refmap;\n    while ((event = walker.next())) {\n        node = event.node;\n        t = node.type;\n        if (!event.entering && (t === 'Paragraph' || t === 'Header')) {\n            this.inlineParser.parse(node);\n        }\n    }\n};\n\nvar Document = function() {\n    var doc = new Node('Document', [[1, 1], [0, 0]]);\n    return doc;\n};\n\n// The main parsing function.  Returns a parsed document AST.\nvar parse = function(input) {\n    this.doc = new Document();\n    this.tip = this.doc;\n    this.refmap = {};\n    this.lineNumber = 0;\n    this.lastLineLength = 0;\n    this.offset = 0;\n    this.lastMatchedContainer = this.doc;\n    this.currentLine = \"\";\n    if (this.options.time) { console.time(\"preparing input\"); }\n    var lines = input.split(reLineEnding);\n    var len = lines.length;\n    if (input.charCodeAt(input.length - 1) === C_NEWLINE) {\n        // ignore last blank line created by final newline\n        len -= 1;\n    }\n    if (this.options.time) { console.timeEnd(\"preparing input\"); }\n    if (this.options.time) { console.time(\"block parsing\"); }\n    for (var i = 0; i < len; i++) {\n        this.incorporateLine(lines[i]);\n    }\n    while (this.tip) {\n        this.finalize(this.tip, len);\n    }\n    if (this.options.time) { console.timeEnd(\"block parsing\"); }\n    if (this.options.time) { console.time(\"inline parsing\"); }\n    this.processInlines(this.doc);\n    if (this.options.time) { console.timeEnd(\"inline parsing\"); }\n    return this.doc;\n};\n\n\n// The Parser object.\nfunction Parser(options){\n    return {\n        doc: new Document(),\n        blocks: blocks,\n        blockStarts: blockStarts,\n        tip: this.doc,\n        oldtip: this.doc,\n        currentLine: \"\",\n        lineNumber: 0,\n        offset: 0,\n        nextNonspace: 0,\n        indent: 0,\n        indented: false,\n        blank: false,\n        allClosed: true,\n        lastMatchedContainer: this.doc,\n        refmap: {},\n        lastLineLength: 0,\n        inlineParser: new InlineParser(options),\n        findNextNonspace: findNextNonspace,\n        breakOutOfLists: breakOutOfLists,\n        addLine: addLine,\n        addChild: addChild,\n        incorporateLine: incorporateLine,\n        finalize: finalize,\n        processInlines: processInlines,\n        closeUnmatchedBlocks: closeUnmatchedBlocks,\n        parse: parse,\n        options: options || {}\n    };\n}\n\nmodule.exports = Parser;\n\n},{\"./common\":115,\"./inlines\":122,\"./node\":123}],115:[function(require,module,exports){\n\"use strict\";\n\nvar encode = require('./encode');\nvar decode = require('./decode');\n\nvar C_BACKSLASH = 92;\n\nvar entityToChar = require('./html5-entities.js').entityToChar;\n\nvar ENTITY = \"&(?:#x[a-f0-9]{1,8}|#[0-9]{1,8}|[a-z][a-z0-9]{1,31});\";\n\nvar reBackslashOrAmp = /[\\\\&]/;\n\nvar ESCAPABLE = '[!\"#$%&\\'()*+,./:;<=>?@[\\\\\\\\\\\\]^_`{|}~-]';\n\nvar reEntityOrEscapedChar = new RegExp('\\\\\\\\' + ESCAPABLE + '|' + ENTITY, 'gi');\n\nvar XMLSPECIAL = '[&<>\"]';\n\nvar reXmlSpecial = new RegExp(XMLSPECIAL, 'g');\n\nvar reXmlSpecialOrEntity = new RegExp(ENTITY + '|' + XMLSPECIAL, 'gi');\n\nvar unescapeChar = function(s) {\n    if (s.charCodeAt(0) === C_BACKSLASH) {\n        return s.charAt(1);\n    } else {\n        return entityToChar(s);\n    }\n};\n\n// Replace entities and backslash escapes with literal characters.\nvar unescapeString = function(s) {\n    if (reBackslashOrAmp.test(s)) {\n        return s.replace(reEntityOrEscapedChar, unescapeChar);\n    } else {\n        return s;\n    }\n};\n\nvar normalizeURI = function(uri) {\n    try {\n        return encode(decode(uri));\n    }\n    catch(err) {\n        return uri;\n    }\n};\n\nvar replaceUnsafeChar = function(s) {\n    switch (s) {\n    case '&':\n        return '&amp;';\n    case '<':\n        return '&lt;';\n    case '>':\n        return '&gt;';\n    case '\"':\n        return '&quot;';\n    default:\n        return s;\n    }\n};\n\nvar escapeXml = function(s, preserve_entities) {\n    if (reXmlSpecial.test(s)) {\n        if (preserve_entities) {\n            return s.replace(reXmlSpecialOrEntity, replaceUnsafeChar);\n        } else {\n            return s.replace(reXmlSpecial, replaceUnsafeChar);\n        }\n    } else {\n        return s;\n    }\n};\n\nmodule.exports = { unescapeString: unescapeString,\n                   normalizeURI: normalizeURI,\n                   escapeXml: escapeXml,\n                   ENTITY: ENTITY,\n                   ESCAPABLE: ESCAPABLE\n                 };\n\n},{\"./decode\":116,\"./encode\":117,\"./html5-entities.js\":120}],116:[function(require,module,exports){\n// from https://github.com/markdown-it/mdurl\n// Copyright (c) 2015 Vitaly Puzrin, Alex Kocharin, MIT license.\n\n'use strict';\n\n\n/* eslint-disable no-bitwise */\n\nvar decodeCache = {};\n\nfunction getDecodeCache(exclude) {\n  var i, ch, cache = decodeCache[exclude];\n  if (cache) { return cache; }\n\n  cache = decodeCache[exclude] = [];\n\n  for (i = 0; i < 128; i++) {\n    ch = String.fromCharCode(i);\n    cache.push(ch);\n  }\n\n  for (i = 0; i < exclude.length; i++) {\n    ch = exclude.charCodeAt(i);\n    cache[ch] = '%' + ('0' + ch.toString(16).toUpperCase()).slice(-2);\n  }\n\n  return cache;\n}\n\n\n// Decode percent-encoded string.\n//\nfunction decode(string, exclude) {\n  var cache;\n\n  if (typeof exclude !== 'string') {\n    exclude = decode.defaultChars;\n  }\n\n  cache = getDecodeCache(exclude);\n\n  return string.replace(/(%[a-f0-9]{2})+/gi, function(seq) {\n    var i, l, b1, b2, b3, b4, char,\n        result = '';\n\n    for (i = 0, l = seq.length; i < l; i += 3) {\n      b1 = parseInt(seq.slice(i + 1, i + 3), 16);\n\n      if (b1 < 0x80) {\n        result += cache[b1];\n        continue;\n      }\n\n      if ((b1 & 0xE0) === 0xC0 && (i + 3 < l)) {\n        // 110xxxxx 10xxxxxx\n        b2 = parseInt(seq.slice(i + 4, i + 6), 16);\n\n        if ((b2 & 0xC0) === 0x80) {\n          char = ((b1 << 6) & 0x7C0) | (b2 & 0x3F);\n\n          if (char < 0x80) {\n            result += '\\ufffd\\ufffd';\n          } else {\n            result += String.fromCharCode(char);\n          }\n\n          i += 3;\n          continue;\n        }\n      }\n\n      if ((b1 & 0xF0) === 0xE0 && (i + 6 < l)) {\n        // 1110xxxx 10xxxxxx 10xxxxxx\n        b2 = parseInt(seq.slice(i + 4, i + 6), 16);\n        b3 = parseInt(seq.slice(i + 7, i + 9), 16);\n\n        if ((b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80) {\n          char = ((b1 << 12) & 0xF000) | ((b2 << 6) & 0xFC0) | (b3 & 0x3F);\n\n          if (char < 0x800 || (char >= 0xD800 && char <= 0xDFFF)) {\n            result += '\\ufffd\\ufffd\\ufffd';\n          } else {\n            result += String.fromCharCode(char);\n          }\n\n          i += 6;\n          continue;\n        }\n      }\n\n      if ((b1 & 0xF8) === 0xF0 && (i + 9 < l)) {\n        // 111110xx 10xxxxxx 10xxxxxx 10xxxxxx\n        b2 = parseInt(seq.slice(i + 4, i + 6), 16);\n        b3 = parseInt(seq.slice(i + 7, i + 9), 16);\n        b4 = parseInt(seq.slice(i + 10, i + 12), 16);\n\n        if ((b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80 && (b4 & 0xC0) === 0x80) {\n          char = ((b1 << 18) & 0x1C0000) | ((b2 << 12) & 0x3F000) | ((b3 << 6) & 0xFC0) | (b4 & 0x3F);\n\n          if (char < 0x10000 || char > 0x10FFFF) {\n            result += '\\ufffd\\ufffd\\ufffd\\ufffd';\n          } else {\n            char -= 0x10000;\n            result += String.fromCharCode(0xD800 + (char >> 10), 0xDC00 + (char & 0x3FF));\n          }\n\n          i += 9;\n          continue;\n        }\n      }\n\n      result += '\\ufffd';\n    }\n\n    return result;\n  });\n}\n\n\ndecode.defaultChars = ';/?:@&=+$,#';\ndecode.componentChars = '';\n\n\nmodule.exports = decode;\n\n},{}],117:[function(require,module,exports){\n// from https://github.com/markdown-it/mdurl\n// Copyright (c) 2015 Vitaly Puzrin, Alex Kocharin, MIT license.\n\n'use strict';\n\n\nvar encodeCache = {};\n\n\n// Create a lookup array where anything but characters in `chars` string\n// and alphanumeric chars is percent-encoded.\n//\nfunction getEncodeCache(exclude) {\n  var i, ch, cache = encodeCache[exclude];\n  if (cache) { return cache; }\n\n  cache = encodeCache[exclude] = [];\n\n  for (i = 0; i < 128; i++) {\n    ch = String.fromCharCode(i);\n\n    if (/^[0-9a-z]$/i.test(ch)) {\n      // always allow unencoded alphanumeric characters\n      cache.push(ch);\n    } else {\n      cache.push('%' + ('0' + i.toString(16).toUpperCase()).slice(-2));\n    }\n  }\n\n  for (i = 0; i < exclude.length; i++) {\n    cache[exclude.charCodeAt(i)] = exclude[i];\n  }\n\n  return cache;\n}\n\n\n// Encode unsafe characters with percent-encoding, skipping already\n// encoded sequences.\n//\n//  - string       - string to encode\n//  - exclude      - list of characters to ignore (in addition to a-zA-Z0-9)\n//  - keepEscaped  - don't encode '%' in a correct escape sequence (default: true)\n//\nfunction encode(string, exclude, keepEscaped) {\n  var i, l, code, nextCode, cache,\n      result = '';\n\n  if (typeof exclude !== 'string') {\n    // encode(string, keepEscaped)\n    keepEscaped = exclude;\n    exclude = encode.defaultChars;\n  }\n\n  if (typeof keepEscaped === 'undefined') {\n    keepEscaped = true;\n  }\n\n  cache = getEncodeCache(exclude);\n\n  for (i = 0, l = string.length; i < l; i++) {\n    code = string.charCodeAt(i);\n\n    if (keepEscaped && code === 0x25 && i + 2 < l) {\n      if (/^[0-9a-f]{2}$/i.test(string.slice(i + 1, i + 3))) {\n        result += string.slice(i, i + 3);\n        i += 2;\n        continue;\n      }\n    }\n\n    if (code < 128) {\n      result += cache[code];\n      continue;\n    }\n\n    if (code >= 0xD800 && code <= 0xDFFF) {\n      if (code >= 0xD800 && code <= 0xDBFF && i + 1 < l) {\n        nextCode = string.charCodeAt(i + 1);\n        if (nextCode >= 0xDC00 && nextCode <= 0xDFFF) {\n          result += encodeURIComponent(string[i] + string[i + 1]);\n          i++;\n          continue;\n        }\n      }\n      result += '%EF%BF%BD';\n      continue;\n    }\n\n    result += encodeURIComponent(string[i]);\n  }\n\n  return result;\n}\n\nencode.defaultChars = \";/?:@&=+$,-_.!~*'()#\";\nencode.componentChars = \"-_.!~*'()\";\n\n\nmodule.exports = encode;\n\n},{}],118:[function(require,module,exports){\n\"use strict\";\n\n// derived from https://github.com/mathiasbynens/String.fromCodePoint\n/*! http://mths.be/fromcodepoint v0.2.1 by @mathias */\nif (String.fromCodePoint) {\n    module.exports = function (_) {\n        try {\n            return String.fromCodePoint(_);\n        } catch (e) {\n            if (e instanceof RangeError) {\n                return String.fromCharCode(0xFFFD);\n            }\n            throw e;\n        }\n    };\n\n} else {\n\n  var stringFromCharCode = String.fromCharCode;\n  var floor = Math.floor;\n  var fromCodePoint = function() {\n      var MAX_SIZE = 0x4000;\n      var codeUnits = [];\n      var highSurrogate;\n      var lowSurrogate;\n      var index = -1;\n      var length = arguments.length;\n      if (!length) {\n          return '';\n      }\n      var result = '';\n      while (++index < length) {\n          var codePoint = Number(arguments[index]);\n          if (\n              !isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`\n                  codePoint < 0 || // not a valid Unicode code point\n                  codePoint > 0x10FFFF || // not a valid Unicode code point\n                  floor(codePoint) !== codePoint // not an integer\n          ) {\n              return String.fromCharCode(0xFFFD);\n          }\n          if (codePoint <= 0xFFFF) { // BMP code point\n              codeUnits.push(codePoint);\n          } else { // Astral code point; split in surrogate halves\n              // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n              codePoint -= 0x10000;\n              highSurrogate = (codePoint >> 10) + 0xD800;\n              lowSurrogate = (codePoint % 0x400) + 0xDC00;\n              codeUnits.push(highSurrogate, lowSurrogate);\n          }\n          if (index + 1 === length || codeUnits.length > MAX_SIZE) {\n              result += stringFromCharCode.apply(null, codeUnits);\n              codeUnits.length = 0;\n          }\n      }\n      return result;\n  };\n  module.exports = fromCodePoint;\n}\n\n},{}],119:[function(require,module,exports){\n\"use strict\";\n\nvar escapeXml = require('./common').escapeXml;\n\n// Helper function to produce an HTML tag.\nvar tag = function(name, attrs, selfclosing) {\n    var result = '<' + name;\n    if (attrs && attrs.length > 0) {\n        var i = 0;\n        var attrib;\n        while ((attrib = attrs[i]) !== undefined) {\n            result += ' ' + attrib[0] + '=\"' + attrib[1] + '\"';\n            i++;\n        }\n    }\n    if (selfclosing) {\n        result += ' /';\n    }\n\n    result += '>';\n    return result;\n};\n\nvar reHtmlTag = /\\<[^>]*\\>/;\n\nvar renderNodes = function(block) {\n\n    var attrs;\n    var info_words;\n    var tagname;\n    var walker = block.walker();\n    var event, node, entering;\n    var buffer = \"\";\n    var lastOut = \"\\n\";\n    var disableTags = 0;\n    var grandparent;\n    var out = function(s) {\n        if (disableTags > 0) {\n            buffer += s.replace(reHtmlTag, '');\n        } else {\n            buffer += s;\n        }\n        lastOut = s;\n    };\n    var esc = this.escape;\n    var cr = function() {\n        if (lastOut !== '\\n') {\n            buffer += '\\n';\n            lastOut = '\\n';\n        }\n    };\n\n    var options = this.options;\n\n    if (options.time) { console.time(\"rendering\"); }\n\n    while ((event = walker.next())) {\n        entering = event.entering;\n        node = event.node;\n\n        attrs = [];\n        if (options.sourcepos) {\n            var pos = node.sourcepos;\n            if (pos) {\n                attrs.push(['data-sourcepos', String(pos[0][0]) + ':' +\n                            String(pos[0][1]) + '-' + String(pos[1][0]) + ':' +\n                            String(pos[1][1])]);\n            }\n        }\n\n        switch (node.type) {\n        case 'Text':\n            out(esc(node.literal, false));\n            break;\n\n        case 'Softbreak':\n            out(this.softbreak);\n            break;\n\n        case 'Hardbreak':\n            out(tag('br', [], true));\n            cr();\n            break;\n\n        case 'Emph':\n            out(tag(entering ? 'em' : '/em'));\n            break;\n\n        case 'Strong':\n            out(tag(entering ? 'strong' : '/strong'));\n            break;\n\n        case 'Html':\n            out(node.literal);\n            break;\n\n        case 'Link':\n            if (entering) {\n                attrs.push(['href', esc(node.destination, true)]);\n                if (node.title) {\n                    attrs.push(['title', esc(node.title, true)]);\n                }\n                out(tag('a', attrs));\n            } else {\n                out(tag('/a'));\n            }\n            break;\n\n        case 'Image':\n            if (entering) {\n                if (disableTags === 0) {\n                    out('<img src=\"' + esc(node.destination, true) +\n                        '\" alt=\"');\n                }\n                disableTags += 1;\n            } else {\n                disableTags -= 1;\n                if (disableTags === 0) {\n                    if (node.title) {\n                        out('\" title=\"' + esc(node.title, true));\n                    }\n                    out('\" />');\n                }\n            }\n            break;\n\n        case 'Code':\n            out(tag('code') + esc(node.literal, false) + tag('/code'));\n            break;\n\n        case 'Document':\n            break;\n\n        case 'Paragraph':\n            grandparent = node.parent.parent;\n            if (grandparent !== null &&\n                grandparent.type === 'List') {\n                if (grandparent.listTight) {\n                    break;\n                }\n            }\n            if (entering) {\n                cr();\n                out(tag('p', attrs));\n            } else {\n                out(tag('/p'));\n                cr();\n            }\n            break;\n\n        case 'BlockQuote':\n            if (entering) {\n                cr();\n                out(tag('blockquote', attrs));\n                cr();\n            } else {\n                cr();\n                out(tag('/blockquote'));\n                cr();\n            }\n            break;\n\n        case 'Item':\n            if (entering) {\n                out(tag('li', attrs));\n            } else {\n                out(tag('/li'));\n                cr();\n            }\n            break;\n\n        case 'List':\n            tagname = node.listType === 'Bullet' ? 'ul' : 'ol';\n            if (entering) {\n                var start = node.listStart;\n                if (start !== null && start !== 1) {\n                    attrs.push(['start', start.toString()]);\n                }\n                cr();\n                out(tag(tagname, attrs));\n                cr();\n            } else {\n                cr();\n                out(tag('/' + tagname));\n                cr();\n            }\n            break;\n\n        case 'Header':\n            tagname = 'h' + node.level;\n            if (entering) {\n                cr();\n                out(tag(tagname, attrs));\n            } else {\n                out(tag('/' + tagname));\n                cr();\n            }\n            break;\n\n        case 'CodeBlock':\n            info_words = node.info ? node.info.split(/ +/) : [];\n            if (info_words.length > 0 && info_words[0].length > 0) {\n                attrs.push(['class', 'language-' + esc(info_words[0], true)]);\n            }\n            cr();\n            out(tag('pre') + tag('code', attrs));\n            out(esc(node.literal, false));\n            out(tag('/code') + tag('/pre'));\n            cr();\n            break;\n\n        case 'HtmlBlock':\n            cr();\n            out(node.literal);\n            cr();\n            break;\n\n        case 'HorizontalRule':\n            cr();\n            out(tag('hr', attrs, true));\n            cr();\n            break;\n\n        default:\n            throw \"Unknown node type \" + node.type;\n        }\n\n    }\n    if (options.time) { console.timeEnd(\"rendering\"); }\n    return buffer;\n};\n\n// The HtmlRenderer object.\nfunction HtmlRenderer(options){\n    return {\n        // default options:\n        softbreak: '\\n', // by default, soft breaks are rendered as newlines in HTML\n        // set to \"<br />\" to make them hard breaks\n        // set to \" \" if you want to ignore line wrapping in source\n        escape: escapeXml,\n        options: options || {},\n        render: renderNodes\n    };\n}\n\nmodule.exports = HtmlRenderer;\n\n},{\"./common\":115}],120:[function(require,module,exports){\n\"use strict\";\n\nvar fromCodePoint = require('./from-code-point');\n\nvar entities = {\n  AAacute: 193,\n  aacute: 225,\n  Abreve: 258,\n  abreve: 259,\n  ac: 8766,\n  acd: 8767,\n  acE: 8766,\n  Acirc: 194,\n  acirc: 226,\n  acute: 180,\n  Acy: 1040,\n  acy: 1072,\n  AElig: 198,\n  aelig: 230,\n  af: 8289,\n  Afr: 55349,\n  afr: 55349,\n  Agrave: 192,\n  agrave: 224,\n  alefsym: 8501,\n  aleph: 8501,\n  Alpha: 913,\n  alpha: 945,\n  Amacr: 256,\n  amacr: 257,\n  amalg: 10815,\n  amp: 38,\n  AMP: 38,\n  andand: 10837,\n  And: 10835,\n  and: 8743,\n  andd: 10844,\n  andslope: 10840,\n  andv: 10842,\n  ang: 8736,\n  ange: 10660,\n  angle: 8736,\n  angmsdaa: 10664,\n  angmsdab: 10665,\n  angmsdac: 10666,\n  angmsdad: 10667,\n  angmsdae: 10668,\n  angmsdaf: 10669,\n  angmsdag: 10670,\n  angmsdah: 10671,\n  angmsd: 8737,\n  angrt: 8735,\n  angrtvb: 8894,\n  angrtvbd: 10653,\n  angsph: 8738,\n  angst: 197,\n  angzarr: 9084,\n  Aogon: 260,\n  aogon: 261,\n  Aopf: 55349,\n  aopf: 55349,\n  apacir: 10863,\n  ap: 8776,\n  apE: 10864,\n  ape: 8778,\n  apid: 8779,\n  apos: 39,\n  ApplyFunction: 8289,\n  approx: 8776,\n  approxeq: 8778,\n  Aring: 197,\n  aring: 229,\n  Ascr: 55349,\n  ascr: 55349,\n  Assign: 8788,\n  ast: 42,\n  asymp: 8776,\n  asympeq: 8781,\n  Atilde: 195,\n  atilde: 227,\n  Auml: 196,\n  auml: 228,\n  awconint: 8755,\n  awint: 10769,\n  backcong: 8780,\n  backepsilon: 1014,\n  backprime: 8245,\n  backsim: 8765,\n  backsimeq: 8909,\n  Backslash: 8726,\n  Barv: 10983,\n  barvee: 8893,\n  barwed: 8965,\n  Barwed: 8966,\n  barwedge: 8965,\n  bbrk: 9141,\n  bbrktbrk: 9142,\n  bcong: 8780,\n  Bcy: 1041,\n  bcy: 1073,\n  bdquo: 8222,\n  becaus: 8757,\n  because: 8757,\n  Because: 8757,\n  bemptyv: 10672,\n  bepsi: 1014,\n  bernou: 8492,\n  Bernoullis: 8492,\n  Beta: 914,\n  beta: 946,\n  beth: 8502,\n  between: 8812,\n  Bfr: 55349,\n  bfr: 55349,\n  bigcap: 8898,\n  bigcirc: 9711,\n  bigcup: 8899,\n  bigodot: 10752,\n  bigoplus: 10753,\n  bigotimes: 10754,\n  bigsqcup: 10758,\n  bigstar: 9733,\n  bigtriangledown: 9661,\n  bigtriangleup: 9651,\n  biguplus: 10756,\n  bigvee: 8897,\n  bigwedge: 8896,\n  bkarow: 10509,\n  blacklozenge: 10731,\n  blacksquare: 9642,\n  blacktriangle: 9652,\n  blacktriangledown: 9662,\n  blacktriangleleft: 9666,\n  blacktriangleright: 9656,\n  blank: 9251,\n  blk12: 9618,\n  blk14: 9617,\n  blk34: 9619,\n  block: 9608,\n  bne: 61,\n  bnequiv: 8801,\n  bNot: 10989,\n  bnot: 8976,\n  Bopf: 55349,\n  bopf: 55349,\n  bot: 8869,\n  bottom: 8869,\n  bowtie: 8904,\n  boxbox: 10697,\n  boxdl: 9488,\n  boxdL: 9557,\n  boxDl: 9558,\n  boxDL: 9559,\n  boxdr: 9484,\n  boxdR: 9554,\n  boxDr: 9555,\n  boxDR: 9556,\n  boxh: 9472,\n  boxH: 9552,\n  boxhd: 9516,\n  boxHd: 9572,\n  boxhD: 9573,\n  boxHD: 9574,\n  boxhu: 9524,\n  boxHu: 9575,\n  boxhU: 9576,\n  boxHU: 9577,\n  boxminus: 8863,\n  boxplus: 8862,\n  boxtimes: 8864,\n  boxul: 9496,\n  boxuL: 9563,\n  boxUl: 9564,\n  boxUL: 9565,\n  boxur: 9492,\n  boxuR: 9560,\n  boxUr: 9561,\n  boxUR: 9562,\n  boxv: 9474,\n  boxV: 9553,\n  boxvh: 9532,\n  boxvH: 9578,\n  boxVh: 9579,\n  boxVH: 9580,\n  boxvl: 9508,\n  boxvL: 9569,\n  boxVl: 9570,\n  boxVL: 9571,\n  boxvr: 9500,\n  boxvR: 9566,\n  boxVr: 9567,\n  boxVR: 9568,\n  bprime: 8245,\n  breve: 728,\n  Breve: 728,\n  brvbar: 166,\n  bscr: 55349,\n  Bscr: 8492,\n  bsemi: 8271,\n  bsim: 8765,\n  bsime: 8909,\n  bsolb: 10693,\n  bsol: 92,\n  bsolhsub: 10184,\n  bull: 8226,\n  bullet: 8226,\n  bump: 8782,\n  bumpE: 10926,\n  bumpe: 8783,\n  Bumpeq: 8782,\n  bumpeq: 8783,\n  Cacute: 262,\n  cacute: 263,\n  capand: 10820,\n  capbrcup: 10825,\n  capcap: 10827,\n  cap: 8745,\n  Cap: 8914,\n  capcup: 10823,\n  capdot: 10816,\n  CapitalDifferentialD: 8517,\n  caps: 8745,\n  caret: 8257,\n  caron: 711,\n  Cayleys: 8493,\n  ccaps: 10829,\n  Ccaron: 268,\n  ccaron: 269,\n  Ccedil: 199,\n  ccedil: 231,\n  Ccirc: 264,\n  ccirc: 265,\n  Cconint: 8752,\n  ccups: 10828,\n  ccupssm: 10832,\n  Cdot: 266,\n  cdot: 267,\n  cedil: 184,\n  Cedilla: 184,\n  cemptyv: 10674,\n  cent: 162,\n  centerdot: 183,\n  CenterDot: 183,\n  cfr: 55349,\n  Cfr: 8493,\n  CHcy: 1063,\n  chcy: 1095,\n  check: 10003,\n  checkmark: 10003,\n  Chi: 935,\n  chi: 967,\n  circ: 710,\n  circeq: 8791,\n  circlearrowleft: 8634,\n  circlearrowright: 8635,\n  circledast: 8859,\n  circledcirc: 8858,\n  circleddash: 8861,\n  CircleDot: 8857,\n  circledR: 174,\n  circledS: 9416,\n  CircleMinus: 8854,\n  CirclePlus: 8853,\n  CircleTimes: 8855,\n  cir: 9675,\n  cirE: 10691,\n  cire: 8791,\n  cirfnint: 10768,\n  cirmid: 10991,\n  cirscir: 10690,\n  ClockwiseContourIntegral: 8754,\n  CloseCurlyDoubleQuote: 8221,\n  CloseCurlyQuote: 8217,\n  clubs: 9827,\n  clubsuit: 9827,\n  colon: 58,\n  Colon: 8759,\n  Colone: 10868,\n  colone: 8788,\n  coloneq: 8788,\n  comma: 44,\n  commat: 64,\n  comp: 8705,\n  compfn: 8728,\n  complement: 8705,\n  complexes: 8450,\n  cong: 8773,\n  congdot: 10861,\n  Congruent: 8801,\n  conint: 8750,\n  Conint: 8751,\n  ContourIntegral: 8750,\n  copf: 55349,\n  Copf: 8450,\n  coprod: 8720,\n  Coproduct: 8720,\n  copy: 169,\n  COPY: 169,\n  copysr: 8471,\n  CounterClockwiseContourIntegral: 8755,\n  crarr: 8629,\n  cross: 10007,\n  Cross: 10799,\n  Cscr: 55349,\n  cscr: 55349,\n  csub: 10959,\n  csube: 10961,\n  csup: 10960,\n  csupe: 10962,\n  ctdot: 8943,\n  cudarrl: 10552,\n  cudarrr: 10549,\n  cuepr: 8926,\n  cuesc: 8927,\n  cularr: 8630,\n  cularrp: 10557,\n  cupbrcap: 10824,\n  cupcap: 10822,\n  CupCap: 8781,\n  cup: 8746,\n  Cup: 8915,\n  cupcup: 10826,\n  cupdot: 8845,\n  cupor: 10821,\n  cups: 8746,\n  curarr: 8631,\n  curarrm: 10556,\n  curlyeqprec: 8926,\n  curlyeqsucc: 8927,\n  curlyvee: 8910,\n  curlywedge: 8911,\n  curren: 164,\n  curvearrowleft: 8630,\n  curvearrowright: 8631,\n  cuvee: 8910,\n  cuwed: 8911,\n  cwconint: 8754,\n  cwint: 8753,\n  cylcty: 9005,\n  dagger: 8224,\n  Dagger: 8225,\n  daleth: 8504,\n  darr: 8595,\n  Darr: 8609,\n  dArr: 8659,\n  dash: 8208,\n  Dashv: 10980,\n  dashv: 8867,\n  dbkarow: 10511,\n  dblac: 733,\n  Dcaron: 270,\n  dcaron: 271,\n  Dcy: 1044,\n  dcy: 1076,\n  ddagger: 8225,\n  ddarr: 8650,\n  DD: 8517,\n  dd: 8518,\n  DDotrahd: 10513,\n  ddotseq: 10871,\n  deg: 176,\n  Del: 8711,\n  Delta: 916,\n  delta: 948,\n  demptyv: 10673,\n  dfisht: 10623,\n  Dfr: 55349,\n  dfr: 55349,\n  dHar: 10597,\n  dharl: 8643,\n  dharr: 8642,\n  DiacriticalAcute: 180,\n  DiacriticalDot: 729,\n  DiacriticalDoubleAcute: 733,\n  DiacriticalGrave: 96,\n  DiacriticalTilde: 732,\n  diam: 8900,\n  diamond: 8900,\n  Diamond: 8900,\n  diamondsuit: 9830,\n  diams: 9830,\n  die: 168,\n  DifferentialD: 8518,\n  digamma: 989,\n  disin: 8946,\n  div: 247,\n  divide: 247,\n  divideontimes: 8903,\n  divonx: 8903,\n  DJcy: 1026,\n  djcy: 1106,\n  dlcorn: 8990,\n  dlcrop: 8973,\n  dollar: 36,\n  Dopf: 55349,\n  dopf: 55349,\n  Dot: 168,\n  dot: 729,\n  DotDot: 8412,\n  doteq: 8784,\n  doteqdot: 8785,\n  DotEqual: 8784,\n  dotminus: 8760,\n  dotplus: 8724,\n  dotsquare: 8865,\n  doublebarwedge: 8966,\n  DoubleContourIntegral: 8751,\n  DoubleDot: 168,\n  DoubleDownArrow: 8659,\n  DoubleLeftArrow: 8656,\n  DoubleLeftRightArrow: 8660,\n  DoubleLeftTee: 10980,\n  DoubleLongLeftArrow: 10232,\n  DoubleLongLeftRightArrow: 10234,\n  DoubleLongRightArrow: 10233,\n  DoubleRightArrow: 8658,\n  DoubleRightTee: 8872,\n  DoubleUpArrow: 8657,\n  DoubleUpDownArrow: 8661,\n  DoubleVerticalBar: 8741,\n  DownArrowBar: 10515,\n  downarrow: 8595,\n  DownArrow: 8595,\n  Downarrow: 8659,\n  DownArrowUpArrow: 8693,\n  DownBreve: 785,\n  downdownarrows: 8650,\n  downharpoonleft: 8643,\n  downharpoonright: 8642,\n  DownLeftRightVector: 10576,\n  DownLeftTeeVector: 10590,\n  DownLeftVectorBar: 10582,\n  DownLeftVector: 8637,\n  DownRightTeeVector: 10591,\n  DownRightVectorBar: 10583,\n  DownRightVector: 8641,\n  DownTeeArrow: 8615,\n  DownTee: 8868,\n  drbkarow: 10512,\n  drcorn: 8991,\n  drcrop: 8972,\n  Dscr: 55349,\n  dscr: 55349,\n  DScy: 1029,\n  dscy: 1109,\n  dsol: 10742,\n  Dstrok: 272,\n  dstrok: 273,\n  dtdot: 8945,\n  dtri: 9663,\n  dtrif: 9662,\n  duarr: 8693,\n  duhar: 10607,\n  dwangle: 10662,\n  DZcy: 1039,\n  dzcy: 1119,\n  dzigrarr: 10239,\n  Eacute: 201,\n  eacute: 233,\n  easter: 10862,\n  Ecaron: 282,\n  ecaron: 283,\n  Ecirc: 202,\n  ecirc: 234,\n  ecir: 8790,\n  ecolon: 8789,\n  Ecy: 1069,\n  ecy: 1101,\n  eDDot: 10871,\n  Edot: 278,\n  edot: 279,\n  eDot: 8785,\n  ee: 8519,\n  efDot: 8786,\n  Efr: 55349,\n  efr: 55349,\n  eg: 10906,\n  Egrave: 200,\n  egrave: 232,\n  egs: 10902,\n  egsdot: 10904,\n  el: 10905,\n  Element: 8712,\n  elinters: 9191,\n  ell: 8467,\n  els: 10901,\n  elsdot: 10903,\n  Emacr: 274,\n  emacr: 275,\n  empty: 8709,\n  emptyset: 8709,\n  EmptySmallSquare: 9723,\n  emptyv: 8709,\n  EmptyVerySmallSquare: 9643,\n  emsp13: 8196,\n  emsp14: 8197,\n  emsp: 8195,\n  ENG: 330,\n  eng: 331,\n  ensp: 8194,\n  Eogon: 280,\n  eogon: 281,\n  Eopf: 55349,\n  eopf: 55349,\n  epar: 8917,\n  eparsl: 10723,\n  eplus: 10865,\n  epsi: 949,\n  Epsilon: 917,\n  epsilon: 949,\n  epsiv: 1013,\n  eqcirc: 8790,\n  eqcolon: 8789,\n  eqsim: 8770,\n  eqslantgtr: 10902,\n  eqslantless: 10901,\n  Equal: 10869,\n  equals: 61,\n  EqualTilde: 8770,\n  equest: 8799,\n  Equilibrium: 8652,\n  equiv: 8801,\n  equivDD: 10872,\n  eqvparsl: 10725,\n  erarr: 10609,\n  erDot: 8787,\n  escr: 8495,\n  Escr: 8496,\n  esdot: 8784,\n  Esim: 10867,\n  esim: 8770,\n  Eta: 919,\n  eta: 951,\n  ETH: 208,\n  eth: 240,\n  Euml: 203,\n  euml: 235,\n  euro: 8364,\n  excl: 33,\n  exist: 8707,\n  Exists: 8707,\n  expectation: 8496,\n  exponentiale: 8519,\n  ExponentialE: 8519,\n  fallingdotseq: 8786,\n  Fcy: 1060,\n  fcy: 1092,\n  female: 9792,\n  ffilig: 64259,\n  fflig: 64256,\n  ffllig: 64260,\n  Ffr: 55349,\n  ffr: 55349,\n  filig: 64257,\n  FilledSmallSquare: 9724,\n  FilledVerySmallSquare: 9642,\n  fjlig: 102,\n  flat: 9837,\n  fllig: 64258,\n  fltns: 9649,\n  fnof: 402,\n  Fopf: 55349,\n  fopf: 55349,\n  forall: 8704,\n  ForAll: 8704,\n  fork: 8916,\n  forkv: 10969,\n  Fouriertrf: 8497,\n  fpartint: 10765,\n  frac12: 189,\n  frac13: 8531,\n  frac14: 188,\n  frac15: 8533,\n  frac16: 8537,\n  frac18: 8539,\n  frac23: 8532,\n  frac25: 8534,\n  frac34: 190,\n  frac35: 8535,\n  frac38: 8540,\n  frac45: 8536,\n  frac56: 8538,\n  frac58: 8541,\n  frac78: 8542,\n  frasl: 8260,\n  frown: 8994,\n  fscr: 55349,\n  Fscr: 8497,\n  gacute: 501,\n  Gamma: 915,\n  gamma: 947,\n  Gammad: 988,\n  gammad: 989,\n  gap: 10886,\n  Gbreve: 286,\n  gbreve: 287,\n  Gcedil: 290,\n  Gcirc: 284,\n  gcirc: 285,\n  Gcy: 1043,\n  gcy: 1075,\n  Gdot: 288,\n  gdot: 289,\n  ge: 8805,\n  gE: 8807,\n  gEl: 10892,\n  gel: 8923,\n  geq: 8805,\n  geqq: 8807,\n  geqslant: 10878,\n  gescc: 10921,\n  ges: 10878,\n  gesdot: 10880,\n  gesdoto: 10882,\n  gesdotol: 10884,\n  gesl: 8923,\n  gesles: 10900,\n  Gfr: 55349,\n  gfr: 55349,\n  gg: 8811,\n  Gg: 8921,\n  ggg: 8921,\n  gimel: 8503,\n  GJcy: 1027,\n  gjcy: 1107,\n  gla: 10917,\n  gl: 8823,\n  glE: 10898,\n  glj: 10916,\n  gnap: 10890,\n  gnapprox: 10890,\n  gne: 10888,\n  gnE: 8809,\n  gneq: 10888,\n  gneqq: 8809,\n  gnsim: 8935,\n  Gopf: 55349,\n  gopf: 55349,\n  grave: 96,\n  GreaterEqual: 8805,\n  GreaterEqualLess: 8923,\n  GreaterFullEqual: 8807,\n  GreaterGreater: 10914,\n  GreaterLess: 8823,\n  GreaterSlantEqual: 10878,\n  GreaterTilde: 8819,\n  Gscr: 55349,\n  gscr: 8458,\n  gsim: 8819,\n  gsime: 10894,\n  gsiml: 10896,\n  gtcc: 10919,\n  gtcir: 10874,\n  gt: 62,\n  GT: 62,\n  Gt: 8811,\n  gtdot: 8919,\n  gtlPar: 10645,\n  gtquest: 10876,\n  gtrapprox: 10886,\n  gtrarr: 10616,\n  gtrdot: 8919,\n  gtreqless: 8923,\n  gtreqqless: 10892,\n  gtrless: 8823,\n  gtrsim: 8819,\n  gvertneqq: 8809,\n  gvnE: 8809,\n  Hacek: 711,\n  hairsp: 8202,\n  half: 189,\n  hamilt: 8459,\n  HARDcy: 1066,\n  hardcy: 1098,\n  harrcir: 10568,\n  harr: 8596,\n  hArr: 8660,\n  harrw: 8621,\n  Hat: 94,\n  hbar: 8463,\n  Hcirc: 292,\n  hcirc: 293,\n  hearts: 9829,\n  heartsuit: 9829,\n  hellip: 8230,\n  hercon: 8889,\n  hfr: 55349,\n  Hfr: 8460,\n  HilbertSpace: 8459,\n  hksearow: 10533,\n  hkswarow: 10534,\n  hoarr: 8703,\n  homtht: 8763,\n  hookleftarrow: 8617,\n  hookrightarrow: 8618,\n  hopf: 55349,\n  Hopf: 8461,\n  horbar: 8213,\n  HorizontalLine: 9472,\n  hscr: 55349,\n  Hscr: 8459,\n  hslash: 8463,\n  Hstrok: 294,\n  hstrok: 295,\n  HumpDownHump: 8782,\n  HumpEqual: 8783,\n  hybull: 8259,\n  hyphen: 8208,\n  Iacute: 205,\n  iacute: 237,\n  ic: 8291,\n  Icirc: 206,\n  icirc: 238,\n  Icy: 1048,\n  icy: 1080,\n  Idot: 304,\n  IEcy: 1045,\n  iecy: 1077,\n  iexcl: 161,\n  iff: 8660,\n  ifr: 55349,\n  Ifr: 8465,\n  Igrave: 204,\n  igrave: 236,\n  ii: 8520,\n  iiiint: 10764,\n  iiint: 8749,\n  iinfin: 10716,\n  iiota: 8489,\n  IJlig: 306,\n  ijlig: 307,\n  Imacr: 298,\n  imacr: 299,\n  image: 8465,\n  ImaginaryI: 8520,\n  imagline: 8464,\n  imagpart: 8465,\n  imath: 305,\n  Im: 8465,\n  imof: 8887,\n  imped: 437,\n  Implies: 8658,\n  incare: 8453,\n  'in': 8712,\n  infin: 8734,\n  infintie: 10717,\n  inodot: 305,\n  intcal: 8890,\n  int: 8747,\n  Int: 8748,\n  integers: 8484,\n  Integral: 8747,\n  intercal: 8890,\n  Intersection: 8898,\n  intlarhk: 10775,\n  intprod: 10812,\n  InvisibleComma: 8291,\n  InvisibleTimes: 8290,\n  IOcy: 1025,\n  iocy: 1105,\n  Iogon: 302,\n  iogon: 303,\n  Iopf: 55349,\n  iopf: 55349,\n  Iota: 921,\n  iota: 953,\n  iprod: 10812,\n  iquest: 191,\n  iscr: 55349,\n  Iscr: 8464,\n  isin: 8712,\n  isindot: 8949,\n  isinE: 8953,\n  isins: 8948,\n  isinsv: 8947,\n  isinv: 8712,\n  it: 8290,\n  Itilde: 296,\n  itilde: 297,\n  Iukcy: 1030,\n  iukcy: 1110,\n  Iuml: 207,\n  iuml: 239,\n  Jcirc: 308,\n  jcirc: 309,\n  Jcy: 1049,\n  jcy: 1081,\n  Jfr: 55349,\n  jfr: 55349,\n  jmath: 567,\n  Jopf: 55349,\n  jopf: 55349,\n  Jscr: 55349,\n  jscr: 55349,\n  Jsercy: 1032,\n  jsercy: 1112,\n  Jukcy: 1028,\n  jukcy: 1108,\n  Kappa: 922,\n  kappa: 954,\n  kappav: 1008,\n  Kcedil: 310,\n  kcedil: 311,\n  Kcy: 1050,\n  kcy: 1082,\n  Kfr: 55349,\n  kfr: 55349,\n  kgreen: 312,\n  KHcy: 1061,\n  khcy: 1093,\n  KJcy: 1036,\n  kjcy: 1116,\n  Kopf: 55349,\n  kopf: 55349,\n  Kscr: 55349,\n  kscr: 55349,\n  lAarr: 8666,\n  Lacute: 313,\n  lacute: 314,\n  laemptyv: 10676,\n  lagran: 8466,\n  Lambda: 923,\n  lambda: 955,\n  lang: 10216,\n  Lang: 10218,\n  langd: 10641,\n  langle: 10216,\n  lap: 10885,\n  Laplacetrf: 8466,\n  laquo: 171,\n  larrb: 8676,\n  larrbfs: 10527,\n  larr: 8592,\n  Larr: 8606,\n  lArr: 8656,\n  larrfs: 10525,\n  larrhk: 8617,\n  larrlp: 8619,\n  larrpl: 10553,\n  larrsim: 10611,\n  larrtl: 8610,\n  latail: 10521,\n  lAtail: 10523,\n  lat: 10923,\n  late: 10925,\n  lates: 10925,\n  lbarr: 10508,\n  lBarr: 10510,\n  lbbrk: 10098,\n  lbrace: 123,\n  lbrack: 91,\n  lbrke: 10635,\n  lbrksld: 10639,\n  lbrkslu: 10637,\n  Lcaron: 317,\n  lcaron: 318,\n  Lcedil: 315,\n  lcedil: 316,\n  lceil: 8968,\n  lcub: 123,\n  Lcy: 1051,\n  lcy: 1083,\n  ldca: 10550,\n  ldquo: 8220,\n  ldquor: 8222,\n  ldrdhar: 10599,\n  ldrushar: 10571,\n  ldsh: 8626,\n  le: 8804,\n  lE: 8806,\n  LeftAngleBracket: 10216,\n  LeftArrowBar: 8676,\n  leftarrow: 8592,\n  LeftArrow: 8592,\n  Leftarrow: 8656,\n  LeftArrowRightArrow: 8646,\n  leftarrowtail: 8610,\n  LeftCeiling: 8968,\n  LeftDoubleBracket: 10214,\n  LeftDownTeeVector: 10593,\n  LeftDownVectorBar: 10585,\n  LeftDownVector: 8643,\n  LeftFloor: 8970,\n  leftharpoondown: 8637,\n  leftharpoonup: 8636,\n  leftleftarrows: 8647,\n  leftrightarrow: 8596,\n  LeftRightArrow: 8596,\n  Leftrightarrow: 8660,\n  leftrightarrows: 8646,\n  leftrightharpoons: 8651,\n  leftrightsquigarrow: 8621,\n  LeftRightVector: 10574,\n  LeftTeeArrow: 8612,\n  LeftTee: 8867,\n  LeftTeeVector: 10586,\n  leftthreetimes: 8907,\n  LeftTriangleBar: 10703,\n  LeftTriangle: 8882,\n  LeftTriangleEqual: 8884,\n  LeftUpDownVector: 10577,\n  LeftUpTeeVector: 10592,\n  LeftUpVectorBar: 10584,\n  LeftUpVector: 8639,\n  LeftVectorBar: 10578,\n  LeftVector: 8636,\n  lEg: 10891,\n  leg: 8922,\n  leq: 8804,\n  leqq: 8806,\n  leqslant: 10877,\n  lescc: 10920,\n  les: 10877,\n  lesdot: 10879,\n  lesdoto: 10881,\n  lesdotor: 10883,\n  lesg: 8922,\n  lesges: 10899,\n  lessapprox: 10885,\n  lessdot: 8918,\n  lesseqgtr: 8922,\n  lesseqqgtr: 10891,\n  LessEqualGreater: 8922,\n  LessFullEqual: 8806,\n  LessGreater: 8822,\n  lessgtr: 8822,\n  LessLess: 10913,\n  lesssim: 8818,\n  LessSlantEqual: 10877,\n  LessTilde: 8818,\n  lfisht: 10620,\n  lfloor: 8970,\n  Lfr: 55349,\n  lfr: 55349,\n  lg: 8822,\n  lgE: 10897,\n  lHar: 10594,\n  lhard: 8637,\n  lharu: 8636,\n  lharul: 10602,\n  lhblk: 9604,\n  LJcy: 1033,\n  ljcy: 1113,\n  llarr: 8647,\n  ll: 8810,\n  Ll: 8920,\n  llcorner: 8990,\n  Lleftarrow: 8666,\n  llhard: 10603,\n  lltri: 9722,\n  Lmidot: 319,\n  lmidot: 320,\n  lmoustache: 9136,\n  lmoust: 9136,\n  lnap: 10889,\n  lnapprox: 10889,\n  lne: 10887,\n  lnE: 8808,\n  lneq: 10887,\n  lneqq: 8808,\n  lnsim: 8934,\n  loang: 10220,\n  loarr: 8701,\n  lobrk: 10214,\n  longleftarrow: 10229,\n  LongLeftArrow: 10229,\n  Longleftarrow: 10232,\n  longleftrightarrow: 10231,\n  LongLeftRightArrow: 10231,\n  Longleftrightarrow: 10234,\n  longmapsto: 10236,\n  longrightarrow: 10230,\n  LongRightArrow: 10230,\n  Longrightarrow: 10233,\n  looparrowleft: 8619,\n  looparrowright: 8620,\n  lopar: 10629,\n  Lopf: 55349,\n  lopf: 55349,\n  loplus: 10797,\n  lotimes: 10804,\n  lowast: 8727,\n  lowbar: 95,\n  LowerLeftArrow: 8601,\n  LowerRightArrow: 8600,\n  loz: 9674,\n  lozenge: 9674,\n  lozf: 10731,\n  lpar: 40,\n  lparlt: 10643,\n  lrarr: 8646,\n  lrcorner: 8991,\n  lrhar: 8651,\n  lrhard: 10605,\n  lrm: 8206,\n  lrtri: 8895,\n  lsaquo: 8249,\n  lscr: 55349,\n  Lscr: 8466,\n  lsh: 8624,\n  Lsh: 8624,\n  lsim: 8818,\n  lsime: 10893,\n  lsimg: 10895,\n  lsqb: 91,\n  lsquo: 8216,\n  lsquor: 8218,\n  Lstrok: 321,\n  lstrok: 322,\n  ltcc: 10918,\n  ltcir: 10873,\n  lt: 60,\n  LT: 60,\n  Lt: 8810,\n  ltdot: 8918,\n  lthree: 8907,\n  ltimes: 8905,\n  ltlarr: 10614,\n  ltquest: 10875,\n  ltri: 9667,\n  ltrie: 8884,\n  ltrif: 9666,\n  ltrPar: 10646,\n  lurdshar: 10570,\n  luruhar: 10598,\n  lvertneqq: 8808,\n  lvnE: 8808,\n  macr: 175,\n  male: 9794,\n  malt: 10016,\n  maltese: 10016,\n  Map: 10501,\n  map: 8614,\n  mapsto: 8614,\n  mapstodown: 8615,\n  mapstoleft: 8612,\n  mapstoup: 8613,\n  marker: 9646,\n  mcomma: 10793,\n  Mcy: 1052,\n  mcy: 1084,\n  mdash: 8212,\n  mDDot: 8762,\n  measuredangle: 8737,\n  MediumSpace: 8287,\n  Mellintrf: 8499,\n  Mfr: 55349,\n  mfr: 55349,\n  mho: 8487,\n  micro: 181,\n  midast: 42,\n  midcir: 10992,\n  mid: 8739,\n  middot: 183,\n  minusb: 8863,\n  minus: 8722,\n  minusd: 8760,\n  minusdu: 10794,\n  MinusPlus: 8723,\n  mlcp: 10971,\n  mldr: 8230,\n  mnplus: 8723,\n  models: 8871,\n  Mopf: 55349,\n  mopf: 55349,\n  mp: 8723,\n  mscr: 55349,\n  Mscr: 8499,\n  mstpos: 8766,\n  Mu: 924,\n  mu: 956,\n  multimap: 8888,\n  mumap: 8888,\n  nabla: 8711,\n  Nacute: 323,\n  nacute: 324,\n  nang: 8736,\n  nap: 8777,\n  napE: 10864,\n  napid: 8779,\n  napos: 329,\n  napprox: 8777,\n  natural: 9838,\n  naturals: 8469,\n  natur: 9838,\n  nbsp: 160,\n  nbump: 8782,\n  nbumpe: 8783,\n  ncap: 10819,\n  Ncaron: 327,\n  ncaron: 328,\n  Ncedil: 325,\n  ncedil: 326,\n  ncong: 8775,\n  ncongdot: 10861,\n  ncup: 10818,\n  Ncy: 1053,\n  ncy: 1085,\n  ndash: 8211,\n  nearhk: 10532,\n  nearr: 8599,\n  neArr: 8663,\n  nearrow: 8599,\n  ne: 8800,\n  nedot: 8784,\n  NegativeMediumSpace: 8203,\n  NegativeThickSpace: 8203,\n  NegativeThinSpace: 8203,\n  NegativeVeryThinSpace: 8203,\n  nequiv: 8802,\n  nesear: 10536,\n  nesim: 8770,\n  NestedGreaterGreater: 8811,\n  NestedLessLess: 8810,\n  NewLine: 10,\n  nexist: 8708,\n  nexists: 8708,\n  Nfr: 55349,\n  nfr: 55349,\n  ngE: 8807,\n  nge: 8817,\n  ngeq: 8817,\n  ngeqq: 8807,\n  ngeqslant: 10878,\n  nges: 10878,\n  nGg: 8921,\n  ngsim: 8821,\n  nGt: 8811,\n  ngt: 8815,\n  ngtr: 8815,\n  nGtv: 8811,\n  nharr: 8622,\n  nhArr: 8654,\n  nhpar: 10994,\n  ni: 8715,\n  nis: 8956,\n  nisd: 8954,\n  niv: 8715,\n  NJcy: 1034,\n  njcy: 1114,\n  nlarr: 8602,\n  nlArr: 8653,\n  nldr: 8229,\n  nlE: 8806,\n  nle: 8816,\n  nleftarrow: 8602,\n  nLeftarrow: 8653,\n  nleftrightarrow: 8622,\n  nLeftrightarrow: 8654,\n  nleq: 8816,\n  nleqq: 8806,\n  nleqslant: 10877,\n  nles: 10877,\n  nless: 8814,\n  nLl: 8920,\n  nlsim: 8820,\n  nLt: 8810,\n  nlt: 8814,\n  nltri: 8938,\n  nltrie: 8940,\n  nLtv: 8810,\n  nmid: 8740,\n  NoBreak: 8288,\n  NonBreakingSpace: 160,\n  nopf: 55349,\n  Nopf: 8469,\n  Not: 10988,\n  not: 172,\n  NotCongruent: 8802,\n  NotCupCap: 8813,\n  NotDoubleVerticalBar: 8742,\n  NotElement: 8713,\n  NotEqual: 8800,\n  NotEqualTilde: 8770,\n  NotExists: 8708,\n  NotGreater: 8815,\n  NotGreaterEqual: 8817,\n  NotGreaterFullEqual: 8807,\n  NotGreaterGreater: 8811,\n  NotGreaterLess: 8825,\n  NotGreaterSlantEqual: 10878,\n  NotGreaterTilde: 8821,\n  NotHumpDownHump: 8782,\n  NotHumpEqual: 8783,\n  notin: 8713,\n  notindot: 8949,\n  notinE: 8953,\n  notinva: 8713,\n  notinvb: 8951,\n  notinvc: 8950,\n  NotLeftTriangleBar: 10703,\n  NotLeftTriangle: 8938,\n  NotLeftTriangleEqual: 8940,\n  NotLess: 8814,\n  NotLessEqual: 8816,\n  NotLessGreater: 8824,\n  NotLessLess: 8810,\n  NotLessSlantEqual: 10877,\n  NotLessTilde: 8820,\n  NotNestedGreaterGreater: 10914,\n  NotNestedLessLess: 10913,\n  notni: 8716,\n  notniva: 8716,\n  notnivb: 8958,\n  notnivc: 8957,\n  NotPrecedes: 8832,\n  NotPrecedesEqual: 10927,\n  NotPrecedesSlantEqual: 8928,\n  NotReverseElement: 8716,\n  NotRightTriangleBar: 10704,\n  NotRightTriangle: 8939,\n  NotRightTriangleEqual: 8941,\n  NotSquareSubset: 8847,\n  NotSquareSubsetEqual: 8930,\n  NotSquareSuperset: 8848,\n  NotSquareSupersetEqual: 8931,\n  NotSubset: 8834,\n  NotSubsetEqual: 8840,\n  NotSucceeds: 8833,\n  NotSucceedsEqual: 10928,\n  NotSucceedsSlantEqual: 8929,\n  NotSucceedsTilde: 8831,\n  NotSuperset: 8835,\n  NotSupersetEqual: 8841,\n  NotTilde: 8769,\n  NotTildeEqual: 8772,\n  NotTildeFullEqual: 8775,\n  NotTildeTilde: 8777,\n  NotVerticalBar: 8740,\n  nparallel: 8742,\n  npar: 8742,\n  nparsl: 11005,\n  npart: 8706,\n  npolint: 10772,\n  npr: 8832,\n  nprcue: 8928,\n  nprec: 8832,\n  npreceq: 10927,\n  npre: 10927,\n  nrarrc: 10547,\n  nrarr: 8603,\n  nrArr: 8655,\n  nrarrw: 8605,\n  nrightarrow: 8603,\n  nRightarrow: 8655,\n  nrtri: 8939,\n  nrtrie: 8941,\n  nsc: 8833,\n  nsccue: 8929,\n  nsce: 10928,\n  Nscr: 55349,\n  nscr: 55349,\n  nshortmid: 8740,\n  nshortparallel: 8742,\n  nsim: 8769,\n  nsime: 8772,\n  nsimeq: 8772,\n  nsmid: 8740,\n  nspar: 8742,\n  nsqsube: 8930,\n  nsqsupe: 8931,\n  nsub: 8836,\n  nsubE: 10949,\n  nsube: 8840,\n  nsubset: 8834,\n  nsubseteq: 8840,\n  nsubseteqq: 10949,\n  nsucc: 8833,\n  nsucceq: 10928,\n  nsup: 8837,\n  nsupE: 10950,\n  nsupe: 8841,\n  nsupset: 8835,\n  nsupseteq: 8841,\n  nsupseteqq: 10950,\n  ntgl: 8825,\n  Ntilde: 209,\n  ntilde: 241,\n  ntlg: 8824,\n  ntriangleleft: 8938,\n  ntrianglelefteq: 8940,\n  ntriangleright: 8939,\n  ntrianglerighteq: 8941,\n  Nu: 925,\n  nu: 957,\n  num: 35,\n  numero: 8470,\n  numsp: 8199,\n  nvap: 8781,\n  nvdash: 8876,\n  nvDash: 8877,\n  nVdash: 8878,\n  nVDash: 8879,\n  nvge: 8805,\n  nvgt: 62,\n  nvHarr: 10500,\n  nvinfin: 10718,\n  nvlArr: 10498,\n  nvle: 8804,\n  nvlt: 62,\n  nvltrie: 8884,\n  nvrArr: 10499,\n  nvrtrie: 8885,\n  nvsim: 8764,\n  nwarhk: 10531,\n  nwarr: 8598,\n  nwArr: 8662,\n  nwarrow: 8598,\n  nwnear: 10535,\n  Oacute: 211,\n  oacute: 243,\n  oast: 8859,\n  Ocirc: 212,\n  ocirc: 244,\n  ocir: 8858,\n  Ocy: 1054,\n  ocy: 1086,\n  odash: 8861,\n  Odblac: 336,\n  odblac: 337,\n  odiv: 10808,\n  odot: 8857,\n  odsold: 10684,\n  OElig: 338,\n  oelig: 339,\n  ofcir: 10687,\n  Ofr: 55349,\n  ofr: 55349,\n  ogon: 731,\n  Ograve: 210,\n  ograve: 242,\n  ogt: 10689,\n  ohbar: 10677,\n  ohm: 937,\n  oint: 8750,\n  olarr: 8634,\n  olcir: 10686,\n  olcross: 10683,\n  oline: 8254,\n  olt: 10688,\n  Omacr: 332,\n  omacr: 333,\n  Omega: 937,\n  omega: 969,\n  Omicron: 927,\n  omicron: 959,\n  omid: 10678,\n  ominus: 8854,\n  Oopf: 55349,\n  oopf: 55349,\n  opar: 10679,\n  OpenCurlyDoubleQuote: 8220,\n  OpenCurlyQuote: 8216,\n  operp: 10681,\n  oplus: 8853,\n  orarr: 8635,\n  Or: 10836,\n  or: 8744,\n  ord: 10845,\n  order: 8500,\n  orderof: 8500,\n  ordf: 170,\n  ordm: 186,\n  origof: 8886,\n  oror: 10838,\n  orslope: 10839,\n  orv: 10843,\n  oS: 9416,\n  Oscr: 55349,\n  oscr: 8500,\n  Oslash: 216,\n  oslash: 248,\n  osol: 8856,\n  Otilde: 213,\n  otilde: 245,\n  otimesas: 10806,\n  Otimes: 10807,\n  otimes: 8855,\n  Ouml: 214,\n  ouml: 246,\n  ovbar: 9021,\n  OverBar: 8254,\n  OverBrace: 9182,\n  OverBracket: 9140,\n  OverParenthesis: 9180,\n  para: 182,\n  parallel: 8741,\n  par: 8741,\n  parsim: 10995,\n  parsl: 11005,\n  part: 8706,\n  PartialD: 8706,\n  Pcy: 1055,\n  pcy: 1087,\n  percnt: 37,\n  period: 46,\n  permil: 8240,\n  perp: 8869,\n  pertenk: 8241,\n  Pfr: 55349,\n  pfr: 55349,\n  Phi: 934,\n  phi: 966,\n  phiv: 981,\n  phmmat: 8499,\n  phone: 9742,\n  Pi: 928,\n  pi: 960,\n  pitchfork: 8916,\n  piv: 982,\n  planck: 8463,\n  planckh: 8462,\n  plankv: 8463,\n  plusacir: 10787,\n  plusb: 8862,\n  pluscir: 10786,\n  plus: 43,\n  plusdo: 8724,\n  plusdu: 10789,\n  pluse: 10866,\n  PlusMinus: 177,\n  plusmn: 177,\n  plussim: 10790,\n  plustwo: 10791,\n  pm: 177,\n  Poincareplane: 8460,\n  pointint: 10773,\n  popf: 55349,\n  Popf: 8473,\n  pound: 163,\n  prap: 10935,\n  Pr: 10939,\n  pr: 8826,\n  prcue: 8828,\n  precapprox: 10935,\n  prec: 8826,\n  preccurlyeq: 8828,\n  Precedes: 8826,\n  PrecedesEqual: 10927,\n  PrecedesSlantEqual: 8828,\n  PrecedesTilde: 8830,\n  preceq: 10927,\n  precnapprox: 10937,\n  precneqq: 10933,\n  precnsim: 8936,\n  pre: 10927,\n  prE: 10931,\n  precsim: 8830,\n  prime: 8242,\n  Prime: 8243,\n  primes: 8473,\n  prnap: 10937,\n  prnE: 10933,\n  prnsim: 8936,\n  prod: 8719,\n  Product: 8719,\n  profalar: 9006,\n  profline: 8978,\n  profsurf: 8979,\n  prop: 8733,\n  Proportional: 8733,\n  Proportion: 8759,\n  propto: 8733,\n  prsim: 8830,\n  prurel: 8880,\n  Pscr: 55349,\n  pscr: 55349,\n  Psi: 936,\n  psi: 968,\n  puncsp: 8200,\n  Qfr: 55349,\n  qfr: 55349,\n  qint: 10764,\n  qopf: 55349,\n  Qopf: 8474,\n  qprime: 8279,\n  Qscr: 55349,\n  qscr: 55349,\n  quaternions: 8461,\n  quatint: 10774,\n  quest: 63,\n  questeq: 8799,\n  quot: 34,\n  QUOT: 34,\n  rAarr: 8667,\n  race: 8765,\n  Racute: 340,\n  racute: 341,\n  radic: 8730,\n  raemptyv: 10675,\n  rang: 10217,\n  Rang: 10219,\n  rangd: 10642,\n  range: 10661,\n  rangle: 10217,\n  raquo: 187,\n  rarrap: 10613,\n  rarrb: 8677,\n  rarrbfs: 10528,\n  rarrc: 10547,\n  rarr: 8594,\n  Rarr: 8608,\n  rArr: 8658,\n  rarrfs: 10526,\n  rarrhk: 8618,\n  rarrlp: 8620,\n  rarrpl: 10565,\n  rarrsim: 10612,\n  Rarrtl: 10518,\n  rarrtl: 8611,\n  rarrw: 8605,\n  ratail: 10522,\n  rAtail: 10524,\n  ratio: 8758,\n  rationals: 8474,\n  rbarr: 10509,\n  rBarr: 10511,\n  RBarr: 10512,\n  rbbrk: 10099,\n  rbrace: 125,\n  rbrack: 93,\n  rbrke: 10636,\n  rbrksld: 10638,\n  rbrkslu: 10640,\n  Rcaron: 344,\n  rcaron: 345,\n  Rcedil: 342,\n  rcedil: 343,\n  rceil: 8969,\n  rcub: 125,\n  Rcy: 1056,\n  rcy: 1088,\n  rdca: 10551,\n  rdldhar: 10601,\n  rdquo: 8221,\n  rdquor: 8221,\n  rdsh: 8627,\n  real: 8476,\n  realine: 8475,\n  realpart: 8476,\n  reals: 8477,\n  Re: 8476,\n  rect: 9645,\n  reg: 174,\n  REG: 174,\n  ReverseElement: 8715,\n  ReverseEquilibrium: 8651,\n  ReverseUpEquilibrium: 10607,\n  rfisht: 10621,\n  rfloor: 8971,\n  rfr: 55349,\n  Rfr: 8476,\n  rHar: 10596,\n  rhard: 8641,\n  rharu: 8640,\n  rharul: 10604,\n  Rho: 929,\n  rho: 961,\n  rhov: 1009,\n  RightAngleBracket: 10217,\n  RightArrowBar: 8677,\n  rightarrow: 8594,\n  RightArrow: 8594,\n  Rightarrow: 8658,\n  RightArrowLeftArrow: 8644,\n  rightarrowtail: 8611,\n  RightCeiling: 8969,\n  RightDoubleBracket: 10215,\n  RightDownTeeVector: 10589,\n  RightDownVectorBar: 10581,\n  RightDownVector: 8642,\n  RightFloor: 8971,\n  rightharpoondown: 8641,\n  rightharpoonup: 8640,\n  rightleftarrows: 8644,\n  rightleftharpoons: 8652,\n  rightrightarrows: 8649,\n  rightsquigarrow: 8605,\n  RightTeeArrow: 8614,\n  RightTee: 8866,\n  RightTeeVector: 10587,\n  rightthreetimes: 8908,\n  RightTriangleBar: 10704,\n  RightTriangle: 8883,\n  RightTriangleEqual: 8885,\n  RightUpDownVector: 10575,\n  RightUpTeeVector: 10588,\n  RightUpVectorBar: 10580,\n  RightUpVector: 8638,\n  RightVectorBar: 10579,\n  RightVector: 8640,\n  ring: 730,\n  risingdotseq: 8787,\n  rlarr: 8644,\n  rlhar: 8652,\n  rlm: 8207,\n  rmoustache: 9137,\n  rmoust: 9137,\n  rnmid: 10990,\n  roang: 10221,\n  roarr: 8702,\n  robrk: 10215,\n  ropar: 10630,\n  ropf: 55349,\n  Ropf: 8477,\n  roplus: 10798,\n  rotimes: 10805,\n  RoundImplies: 10608,\n  rpar: 41,\n  rpargt: 10644,\n  rppolint: 10770,\n  rrarr: 8649,\n  Rrightarrow: 8667,\n  rsaquo: 8250,\n  rscr: 55349,\n  Rscr: 8475,\n  rsh: 8625,\n  Rsh: 8625,\n  rsqb: 93,\n  rsquo: 8217,\n  rsquor: 8217,\n  rthree: 8908,\n  rtimes: 8906,\n  rtri: 9657,\n  rtrie: 8885,\n  rtrif: 9656,\n  rtriltri: 10702,\n  RuleDelayed: 10740,\n  ruluhar: 10600,\n  rx: 8478,\n  Sacute: 346,\n  sacute: 347,\n  sbquo: 8218,\n  scap: 10936,\n  Scaron: 352,\n  scaron: 353,\n  Sc: 10940,\n  sc: 8827,\n  sccue: 8829,\n  sce: 10928,\n  scE: 10932,\n  Scedil: 350,\n  scedil: 351,\n  Scirc: 348,\n  scirc: 349,\n  scnap: 10938,\n  scnE: 10934,\n  scnsim: 8937,\n  scpolint: 10771,\n  scsim: 8831,\n  Scy: 1057,\n  scy: 1089,\n  sdotb: 8865,\n  sdot: 8901,\n  sdote: 10854,\n  searhk: 10533,\n  searr: 8600,\n  seArr: 8664,\n  searrow: 8600,\n  sect: 167,\n  semi: 59,\n  seswar: 10537,\n  setminus: 8726,\n  setmn: 8726,\n  sext: 10038,\n  Sfr: 55349,\n  sfr: 55349,\n  sfrown: 8994,\n  sharp: 9839,\n  SHCHcy: 1065,\n  shchcy: 1097,\n  SHcy: 1064,\n  shcy: 1096,\n  ShortDownArrow: 8595,\n  ShortLeftArrow: 8592,\n  shortmid: 8739,\n  shortparallel: 8741,\n  ShortRightArrow: 8594,\n  ShortUpArrow: 8593,\n  shy: 173,\n  Sigma: 931,\n  sigma: 963,\n  sigmaf: 962,\n  sigmav: 962,\n  sim: 8764,\n  simdot: 10858,\n  sime: 8771,\n  simeq: 8771,\n  simg: 10910,\n  simgE: 10912,\n  siml: 10909,\n  simlE: 10911,\n  simne: 8774,\n  simplus: 10788,\n  simrarr: 10610,\n  slarr: 8592,\n  SmallCircle: 8728,\n  smallsetminus: 8726,\n  smashp: 10803,\n  smeparsl: 10724,\n  smid: 8739,\n  smile: 8995,\n  smt: 10922,\n  smte: 10924,\n  smtes: 10924,\n  SOFTcy: 1068,\n  softcy: 1100,\n  solbar: 9023,\n  solb: 10692,\n  sol: 47,\n  Sopf: 55349,\n  sopf: 55349,\n  spades: 9824,\n  spadesuit: 9824,\n  spar: 8741,\n  sqcap: 8851,\n  sqcaps: 8851,\n  sqcup: 8852,\n  sqcups: 8852,\n  Sqrt: 8730,\n  sqsub: 8847,\n  sqsube: 8849,\n  sqsubset: 8847,\n  sqsubseteq: 8849,\n  sqsup: 8848,\n  sqsupe: 8850,\n  sqsupset: 8848,\n  sqsupseteq: 8850,\n  square: 9633,\n  Square: 9633,\n  SquareIntersection: 8851,\n  SquareSubset: 8847,\n  SquareSubsetEqual: 8849,\n  SquareSuperset: 8848,\n  SquareSupersetEqual: 8850,\n  SquareUnion: 8852,\n  squarf: 9642,\n  squ: 9633,\n  squf: 9642,\n  srarr: 8594,\n  Sscr: 55349,\n  sscr: 55349,\n  ssetmn: 8726,\n  ssmile: 8995,\n  sstarf: 8902,\n  Star: 8902,\n  star: 9734,\n  starf: 9733,\n  straightepsilon: 1013,\n  straightphi: 981,\n  strns: 175,\n  sub: 8834,\n  Sub: 8912,\n  subdot: 10941,\n  subE: 10949,\n  sube: 8838,\n  subedot: 10947,\n  submult: 10945,\n  subnE: 10955,\n  subne: 8842,\n  subplus: 10943,\n  subrarr: 10617,\n  subset: 8834,\n  Subset: 8912,\n  subseteq: 8838,\n  subseteqq: 10949,\n  SubsetEqual: 8838,\n  subsetneq: 8842,\n  subsetneqq: 10955,\n  subsim: 10951,\n  subsub: 10965,\n  subsup: 10963,\n  succapprox: 10936,\n  succ: 8827,\n  succcurlyeq: 8829,\n  Succeeds: 8827,\n  SucceedsEqual: 10928,\n  SucceedsSlantEqual: 8829,\n  SucceedsTilde: 8831,\n  succeq: 10928,\n  succnapprox: 10938,\n  succneqq: 10934,\n  succnsim: 8937,\n  succsim: 8831,\n  SuchThat: 8715,\n  sum: 8721,\n  Sum: 8721,\n  sung: 9834,\n  sup1: 185,\n  sup2: 178,\n  sup3: 179,\n  sup: 8835,\n  Sup: 8913,\n  supdot: 10942,\n  supdsub: 10968,\n  supE: 10950,\n  supe: 8839,\n  supedot: 10948,\n  Superset: 8835,\n  SupersetEqual: 8839,\n  suphsol: 10185,\n  suphsub: 10967,\n  suplarr: 10619,\n  supmult: 10946,\n  supnE: 10956,\n  supne: 8843,\n  supplus: 10944,\n  supset: 8835,\n  Supset: 8913,\n  supseteq: 8839,\n  supseteqq: 10950,\n  supsetneq: 8843,\n  supsetneqq: 10956,\n  supsim: 10952,\n  supsub: 10964,\n  supsup: 10966,\n  swarhk: 10534,\n  swarr: 8601,\n  swArr: 8665,\n  swarrow: 8601,\n  swnwar: 10538,\n  szlig: 223,\n  Tab: NaN,\n  target: 8982,\n  Tau: 932,\n  tau: 964,\n  tbrk: 9140,\n  Tcaron: 356,\n  tcaron: 357,\n  Tcedil: 354,\n  tcedil: 355,\n  Tcy: 1058,\n  tcy: 1090,\n  tdot: 8411,\n  telrec: 8981,\n  Tfr: 55349,\n  tfr: 55349,\n  there4: 8756,\n  therefore: 8756,\n  Therefore: 8756,\n  Theta: 920,\n  theta: 952,\n  thetasym: 977,\n  thetav: 977,\n  thickapprox: 8776,\n  thicksim: 8764,\n  ThickSpace: 8287,\n  ThinSpace: 8201,\n  thinsp: 8201,\n  thkap: 8776,\n  thksim: 8764,\n  THORN: 222,\n  thorn: 254,\n  tilde: 732,\n  Tilde: 8764,\n  TildeEqual: 8771,\n  TildeFullEqual: 8773,\n  TildeTilde: 8776,\n  timesbar: 10801,\n  timesb: 8864,\n  times: 215,\n  timesd: 10800,\n  tint: 8749,\n  toea: 10536,\n  topbot: 9014,\n  topcir: 10993,\n  top: 8868,\n  Topf: 55349,\n  topf: 55349,\n  topfork: 10970,\n  tosa: 10537,\n  tprime: 8244,\n  trade: 8482,\n  TRADE: 8482,\n  triangle: 9653,\n  triangledown: 9663,\n  triangleleft: 9667,\n  trianglelefteq: 8884,\n  triangleq: 8796,\n  triangleright: 9657,\n  trianglerighteq: 8885,\n  tridot: 9708,\n  trie: 8796,\n  triminus: 10810,\n  TripleDot: 8411,\n  triplus: 10809,\n  trisb: 10701,\n  tritime: 10811,\n  trpezium: 9186,\n  Tscr: 55349,\n  tscr: 55349,\n  TScy: 1062,\n  tscy: 1094,\n  TSHcy: 1035,\n  tshcy: 1115,\n  Tstrok: 358,\n  tstrok: 359,\n  twixt: 8812,\n  twoheadleftarrow: 8606,\n  twoheadrightarrow: 8608,\n  Uacute: 218,\n  uacute: 250,\n  uarr: 8593,\n  Uarr: 8607,\n  uArr: 8657,\n  Uarrocir: 10569,\n  Ubrcy: 1038,\n  ubrcy: 1118,\n  Ubreve: 364,\n  ubreve: 365,\n  Ucirc: 219,\n  ucirc: 251,\n  Ucy: 1059,\n  ucy: 1091,\n  udarr: 8645,\n  Udblac: 368,\n  udblac: 369,\n  udhar: 10606,\n  ufisht: 10622,\n  Ufr: 55349,\n  ufr: 55349,\n  Ugrave: 217,\n  ugrave: 249,\n  uHar: 10595,\n  uharl: 8639,\n  uharr: 8638,\n  uhblk: 9600,\n  ulcorn: 8988,\n  ulcorner: 8988,\n  ulcrop: 8975,\n  ultri: 9720,\n  Umacr: 362,\n  umacr: 363,\n  uml: 168,\n  UnderBar: 95,\n  UnderBrace: 9183,\n  UnderBracket: 9141,\n  UnderParenthesis: 9181,\n  Union: 8899,\n  UnionPlus: 8846,\n  Uogon: 370,\n  uogon: 371,\n  Uopf: 55349,\n  uopf: 55349,\n  UpArrowBar: 10514,\n  uparrow: 8593,\n  UpArrow: 8593,\n  Uparrow: 8657,\n  UpArrowDownArrow: 8645,\n  updownarrow: 8597,\n  UpDownArrow: 8597,\n  Updownarrow: 8661,\n  UpEquilibrium: 10606,\n  upharpoonleft: 8639,\n  upharpoonright: 8638,\n  uplus: 8846,\n  UpperLeftArrow: 8598,\n  UpperRightArrow: 8599,\n  upsi: 965,\n  Upsi: 978,\n  upsih: 978,\n  Upsilon: 933,\n  upsilon: 965,\n  UpTeeArrow: 8613,\n  UpTee: 8869,\n  upuparrows: 8648,\n  urcorn: 8989,\n  urcorner: 8989,\n  urcrop: 8974,\n  Uring: 366,\n  uring: 367,\n  urtri: 9721,\n  Uscr: 55349,\n  uscr: 55349,\n  utdot: 8944,\n  Utilde: 360,\n  utilde: 361,\n  utri: 9653,\n  utrif: 9652,\n  uuarr: 8648,\n  Uuml: 220,\n  uuml: 252,\n  uwangle: 10663,\n  vangrt: 10652,\n  varepsilon: 1013,\n  varkappa: 1008,\n  varnothing: 8709,\n  varphi: 981,\n  varpi: 982,\n  varpropto: 8733,\n  varr: 8597,\n  vArr: 8661,\n  varrho: 1009,\n  varsigma: 962,\n  varsubsetneq: 8842,\n  varsubsetneqq: 10955,\n  varsupsetneq: 8843,\n  varsupsetneqq: 10956,\n  vartheta: 977,\n  vartriangleleft: 8882,\n  vartriangleright: 8883,\n  vBar: 10984,\n  Vbar: 10987,\n  vBarv: 10985,\n  Vcy: 1042,\n  vcy: 1074,\n  vdash: 8866,\n  vDash: 8872,\n  Vdash: 8873,\n  VDash: 8875,\n  Vdashl: 10982,\n  veebar: 8891,\n  vee: 8744,\n  Vee: 8897,\n  veeeq: 8794,\n  vellip: 8942,\n  verbar: 124,\n  Verbar: 8214,\n  vert: 124,\n  Vert: 8214,\n  VerticalBar: 8739,\n  VerticalLine: 124,\n  VerticalSeparator: 10072,\n  VerticalTilde: 8768,\n  VeryThinSpace: 8202,\n  Vfr: 55349,\n  vfr: 55349,\n  vltri: 8882,\n  vnsub: 8834,\n  vnsup: 8835,\n  Vopf: 55349,\n  vopf: 55349,\n  vprop: 8733,\n  vrtri: 8883,\n  Vscr: 55349,\n  vscr: 55349,\n  vsubnE: 10955,\n  vsubne: 8842,\n  vsupnE: 10956,\n  vsupne: 8843,\n  Vvdash: 8874,\n  vzigzag: 10650,\n  Wcirc: 372,\n  wcirc: 373,\n  wedbar: 10847,\n  wedge: 8743,\n  Wedge: 8896,\n  wedgeq: 8793,\n  weierp: 8472,\n  Wfr: 55349,\n  wfr: 55349,\n  Wopf: 55349,\n  wopf: 55349,\n  wp: 8472,\n  wr: 8768,\n  wreath: 8768,\n  Wscr: 55349,\n  wscr: 55349,\n  xcap: 8898,\n  xcirc: 9711,\n  xcup: 8899,\n  xdtri: 9661,\n  Xfr: 55349,\n  xfr: 55349,\n  xharr: 10231,\n  xhArr: 10234,\n  Xi: 926,\n  xi: 958,\n  xlarr: 10229,\n  xlArr: 10232,\n  xmap: 10236,\n  xnis: 8955,\n  xodot: 10752,\n  Xopf: 55349,\n  xopf: 55349,\n  xoplus: 10753,\n  xotime: 10754,\n  xrarr: 10230,\n  xrArr: 10233,\n  Xscr: 55349,\n  xscr: 55349,\n  xsqcup: 10758,\n  xuplus: 10756,\n  xutri: 9651,\n  xvee: 8897,\n  xwedge: 8896,\n  Yacute: 221,\n  yacute: 253,\n  YAcy: 1071,\n  yacy: 1103,\n  Ycirc: 374,\n  ycirc: 375,\n  Ycy: 1067,\n  ycy: 1099,\n  yen: 165,\n  Yfr: 55349,\n  yfr: 55349,\n  YIcy: 1031,\n  yicy: 1111,\n  Yopf: 55349,\n  yopf: 55349,\n  Yscr: 55349,\n  yscr: 55349,\n  YUcy: 1070,\n  yucy: 1102,\n  yuml: 255,\n  Yuml: 376,\n  Zacute: 377,\n  zacute: 378,\n  Zcaron: 381,\n  zcaron: 382,\n  Zcy: 1047,\n  zcy: 1079,\n  Zdot: 379,\n  zdot: 380,\n  zeetrf: 8488,\n  ZeroWidthSpace: 8203,\n  Zeta: 918,\n  zeta: 950,\n  zfr: 55349,\n  Zfr: 8488,\n  ZHcy: 1046,\n  zhcy: 1078,\n  zigrarr: 8669,\n  zopf: 55349,\n  Zopf: 8484,\n  Zscr: 55349,\n  zscr: 55349,\n  zwj: 8205,\n  zwnj: 8204 };\n\nvar entityToChar = function(m) {\n    var isNumeric = m.slice(0, 2) === \"&#\";\n    var c;\n    var isHex = isNumeric && (c = m.slice(2, 3)) && (c === 'X' || c === 'x');\n    var uchar;\n    var ucode;\n    if (isNumeric) {\n        var num;\n        if (isHex) {\n            num = parseInt(m.slice(3, m.length - 1), 16);\n        } else {\n            num = parseInt(m.slice(2, m.length - 1), 10);\n        }\n        if (num === 0) {\n            uchar = '\\uFFFD';\n        } else {\n            uchar = fromCodePoint(num);\n        }\n    } else {\n        ucode = entities[m.slice(1, m.length - 1)];\n        if (ucode) {\n            uchar = fromCodePoint(entities[m.slice(1, m.length - 1)]);\n        }\n    }\n    return (uchar || m);\n};\n\nmodule.exports.entityToChar = entityToChar;\n\n},{\"./from-code-point\":118}],121:[function(require,module,exports){\n\"use strict\";\n\n// commonmark.js - CommomMark in JavaScript\n// Copyright (C) 2014 John MacFarlane\n// License: BSD3.\n\n// Basic usage:\n//\n// var commonmark = require('commonmark');\n// var parser = new commonmark.Parser();\n// var renderer = new commonmark.HtmlRenderer();\n// console.log(renderer.render(parser.parse('Hello *world*')));\n\nmodule.exports.Node = require('./node');\nmodule.exports.Parser = require('./blocks');\nmodule.exports.HtmlRenderer = require('./html');\nmodule.exports.XmlRenderer = require('./xml');\n\n},{\"./blocks\":114,\"./html\":119,\"./node\":123,\"./xml\":125}],122:[function(require,module,exports){\n\"use strict\";\n\nvar Node = require('./node');\nvar common = require('./common');\nvar normalizeReference = require('./normalize-reference');\n\nvar normalizeURI = common.normalizeURI;\nvar unescapeString = common.unescapeString;\nvar fromCodePoint = require('./from-code-point.js');\nvar entityToChar = require('./html5-entities.js').entityToChar;\n\n// Constants for character codes:\n\nvar C_NEWLINE = 10;\nvar C_ASTERISK = 42;\nvar C_UNDERSCORE = 95;\nvar C_BACKTICK = 96;\nvar C_OPEN_BRACKET = 91;\nvar C_CLOSE_BRACKET = 93;\nvar C_LESSTHAN = 60;\nvar C_BANG = 33;\nvar C_BACKSLASH = 92;\nvar C_AMPERSAND = 38;\nvar C_OPEN_PAREN = 40;\nvar C_CLOSE_PAREN = 41;\nvar C_COLON = 58;\nvar C_SINGLEQUOTE = 39;\nvar C_DOUBLEQUOTE = 34;\n\n// Some regexps used in inline parser:\n\nvar ESCAPABLE = common.ESCAPABLE;\nvar ESCAPED_CHAR = '\\\\\\\\' + ESCAPABLE;\nvar REG_CHAR = '[^\\\\\\\\()\\\\x00-\\\\x20]';\nvar IN_PARENS_NOSP = '\\\\((' + REG_CHAR + '|' + ESCAPED_CHAR + ')*\\\\)';\nvar TAGNAME = '[A-Za-z][A-Za-z0-9]*';\nvar ATTRIBUTENAME = '[a-zA-Z_:][a-zA-Z0-9:._-]*';\nvar UNQUOTEDVALUE = \"[^\\\"'=<>`\\\\x00-\\\\x20]+\";\nvar SINGLEQUOTEDVALUE = \"'[^']*'\";\nvar DOUBLEQUOTEDVALUE = '\"[^\"]*\"';\nvar ATTRIBUTEVALUE = \"(?:\" + UNQUOTEDVALUE + \"|\" + SINGLEQUOTEDVALUE + \"|\" + DOUBLEQUOTEDVALUE + \")\";\nvar ATTRIBUTEVALUESPEC = \"(?:\" + \"\\\\s*=\" + \"\\\\s*\" + ATTRIBUTEVALUE + \")\";\nvar ATTRIBUTE = \"(?:\" + \"\\\\s+\" + ATTRIBUTENAME + ATTRIBUTEVALUESPEC + \"?)\";\nvar OPENTAG = \"<\" + TAGNAME + ATTRIBUTE + \"*\" + \"\\\\s*/?>\";\nvar CLOSETAG = \"</\" + TAGNAME + \"\\\\s*[>]\";\nvar HTMLCOMMENT = \"<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->\";\nvar PROCESSINGINSTRUCTION = \"[<][?].*?[?][>]\";\nvar DECLARATION = \"<![A-Z]+\" + \"\\\\s+[^>]*>\";\nvar CDATA = \"<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?\\\\]\\\\]>\";\nvar HTMLTAG = \"(?:\" + OPENTAG + \"|\" + CLOSETAG + \"|\" + HTMLCOMMENT + \"|\" +\n        PROCESSINGINSTRUCTION + \"|\" + DECLARATION + \"|\" + CDATA + \")\";\nvar ENTITY = common.ENTITY;\n\nvar rePunctuation = new RegExp(/^[\\u2000-\\u206F\\u2E00-\\u2E7F\\\\'!\"#\\$%&\\(\\)\\*\\+,\\-\\.\\/:;<=>\\?@\\[\\]\\^_`\\{\\|\\}~]/);\n\nvar reHtmlTag = new RegExp('^' + HTMLTAG, 'i');\n\nvar reLinkTitle = new RegExp(\n    '^(?:\"(' + ESCAPED_CHAR + '|[^\"\\\\x00])*\"' +\n        '|' +\n        '\\'(' + ESCAPED_CHAR + '|[^\\'\\\\x00])*\\'' +\n        '|' +\n        '\\\\((' + ESCAPED_CHAR + '|[^)\\\\x00])*\\\\))');\n\nvar reLinkDestinationBraces = new RegExp(\n    '^(?:[<](?:[^<>\\\\n\\\\\\\\\\\\x00]' + '|' + ESCAPED_CHAR + '|' + '\\\\\\\\)*[>])');\n\nvar reLinkDestination = new RegExp(\n    '^(?:' + REG_CHAR + '+|' + ESCAPED_CHAR + '|' + IN_PARENS_NOSP + ')*');\n\nvar reEscapable = new RegExp('^' + ESCAPABLE);\n\nvar reEntityHere = new RegExp('^' + ENTITY, 'i');\n\nvar reTicks = /`+/;\n\nvar reTicksHere = /^`+/;\n\nvar reEllipses = /\\.\\.\\./g;\n\nvar reDash = /---?/g;\n\nvar reEmailAutolink = /^<([a-zA-Z0-9.!#$%&'*+\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)>/;\n\nvar reAutolink = /^<(?:coap|doi|javascript|aaa|aaas|about|acap|cap|cid|crid|data|dav|dict|dns|file|ftp|geo|go|gopher|h323|http|https|iax|icap|im|imap|info|ipp|iris|iris.beep|iris.xpc|iris.xpcs|iris.lwz|ldap|mailto|mid|msrp|msrps|mtqp|mupdate|news|nfs|ni|nih|nntp|opaquelocktoken|pop|pres|rtsp|service|session|shttp|sieve|sip|sips|sms|snmp|soap.beep|soap.beeps|tag|tel|telnet|tftp|thismessage|tn3270|tip|tv|urn|vemmi|ws|wss|xcon|xcon-userid|xmlrpc.beep|xmlrpc.beeps|xmpp|z39.50r|z39.50s|adiumxtra|afp|afs|aim|apt|attachment|aw|beshare|bitcoin|bolo|callto|chrome|chrome-extension|com-eventbrite-attendee|content|cvs|dlna-playsingle|dlna-playcontainer|dtn|dvb|ed2k|facetime|feed|finger|fish|gg|git|gizmoproject|gtalk|hcp|icon|ipn|irc|irc6|ircs|itms|jar|jms|keyparc|lastfm|ldaps|magnet|maps|market|message|mms|ms-help|msnim|mumble|mvn|notes|oid|palm|paparazzi|platform|proxy|psyc|query|res|resource|rmi|rsync|rtmp|secondlife|sftp|sgn|skype|smb|soldat|spotify|ssh|steam|svn|teamspeak|things|udp|unreal|ut2004|ventrilo|view-source|webcal|wtai|wyciwyg|xfire|xri|ymsgr):[^<>\\x00-\\x20]*>/i;\n\nvar reSpnl = /^ *(?:\\n *)?/;\n\nvar reWhitespaceChar = /^\\s/;\n\nvar reWhitespace = /\\s+/g;\n\nvar reFinalSpace = / *$/;\n\nvar reInitialSpace = /^ */;\n\nvar reSpaceAtEndOfLine = /^ *(?:\\n|$)/;\n\nvar reLinkLabel = /^\\[(?:[^\\\\\\[\\]]|\\\\[\\[\\]]){0,1000}\\]/;\n\n// Matches a string of non-special characters.\nvar reMain = /^[^\\n`\\[\\]\\\\!<&*_'\"]+/m;\n\nvar text = function(s) {\n    var node = new Node('Text');\n    node._literal = s;\n    return node;\n};\n\n// INLINE PARSER\n\n// These are methods of an InlineParser object, defined below.\n// An InlineParser keeps track of a subject (a string to be\n// parsed) and a position in that subject.\n\n// If re matches at current position in the subject, advance\n// position in subject and return the match; otherwise return null.\nvar match = function(re) {\n    var m = re.exec(this.subject.slice(this.pos));\n    if (m === null) {\n        return null;\n    } else {\n        this.pos += m.index + m[0].length;\n        return m[0];\n    }\n};\n\n// Returns the code for the character at the current subject position, or -1\n// there are no more characters.\nvar peek = function() {\n    if (this.pos < this.subject.length) {\n        return this.subject.charCodeAt(this.pos);\n    } else {\n        return -1;\n    }\n};\n\n// Parse zero or more space characters, including at most one newline\nvar spnl = function() {\n    this.match(reSpnl);\n    return true;\n};\n\n// All of the parsers below try to match something at the current position\n// in the subject.  If they succeed in matching anything, they\n// return the inline matched, advancing the subject.\n\n// Attempt to parse backticks, adding either a backtick code span or a\n// literal sequence of backticks.\nvar parseBackticks = function(block) {\n    var ticks = this.match(reTicksHere);\n    if (ticks === null) {\n        return false;\n    }\n    var afterOpenTicks = this.pos;\n    var matched;\n    var node;\n    while ((matched = this.match(reTicks)) !== null) {\n        if (matched === ticks) {\n            node = new Node('Code');\n            node._literal = this.subject.slice(afterOpenTicks,\n                                        this.pos - ticks.length)\n                          .trim().replace(reWhitespace, ' ');\n            block.appendChild(node);\n            return true;\n        }\n    }\n    // If we got here, we didn't match a closing backtick sequence.\n    this.pos = afterOpenTicks;\n    block.appendChild(text(ticks));\n    return true;\n};\n\n// Parse a backslash-escaped special character, adding either the escaped\n// character, a hard line break (if the backslash is followed by a newline),\n// or a literal backslash to the block's children.  Assumes current character\n// is a backslash.\nvar parseBackslash = function(block) {\n    var subj = this.subject;\n    var node;\n    this.pos += 1;\n    if (this.peek() === C_NEWLINE) {\n        this.pos += 1;\n        node = new Node('Hardbreak');\n        block.appendChild(node);\n    } else if (reEscapable.test(subj.charAt(this.pos))) {\n        block.appendChild(text(subj.charAt(this.pos)));\n        this.pos += 1;\n    } else {\n        block.appendChild(text('\\\\'));\n    }\n    return true;\n};\n\n// Attempt to parse an autolink (URL or email in pointy brackets).\nvar parseAutolink = function(block) {\n    var m;\n    var dest;\n    var node;\n    if ((m = this.match(reEmailAutolink))) {\n        dest = m.slice(1, m.length - 1);\n        node = new Node('Link');\n        node._destination = normalizeURI('mailto:' + dest);\n        node._title = '';\n        node.appendChild(text(dest));\n        block.appendChild(node);\n        return true;\n    } else if ((m = this.match(reAutolink))) {\n        dest = m.slice(1, m.length - 1);\n        node = new Node('Link');\n        node._destination = normalizeURI(dest);\n        node._title = '';\n        node.appendChild(text(dest));\n        block.appendChild(node);\n        return true;\n    } else {\n        return false;\n    }\n};\n\n// Attempt to parse a raw HTML tag.\nvar parseHtmlTag = function(block) {\n    var m = this.match(reHtmlTag);\n    if (m === null) {\n        return false;\n    } else {\n        var node = new Node('Html');\n        node._literal = m;\n        block.appendChild(node);\n        return true;\n    }\n};\n\n// Scan a sequence of characters with code cc, and return information about\n// the number of delimiters and whether they are positioned such that\n// they can open and/or close emphasis or strong emphasis.  A utility\n// function for strong/emph parsing.\nvar scanDelims = function(cc) {\n    var numdelims = 0;\n    var char_before, char_after, cc_after;\n    var startpos = this.pos;\n    var left_flanking, right_flanking, can_open, can_close;\n    var after_is_whitespace, after_is_punctuation, before_is_whitespace, before_is_punctuation;\n\n    if (cc === C_SINGLEQUOTE || cc === C_DOUBLEQUOTE) {\n        numdelims++;\n        this.pos++;\n    } else {\n        while (this.peek() === cc) {\n            numdelims++;\n            this.pos++;\n        }\n    }\n\n    if (numdelims === 0) {\n        return null;\n    }\n\n    char_before = startpos === 0 ? '\\n' : this.subject.charAt(startpos - 1);\n\n    cc_after = this.peek();\n    if (cc_after === -1) {\n        char_after = '\\n';\n    } else {\n        char_after = fromCodePoint(cc_after);\n    }\n\n    after_is_whitespace = reWhitespaceChar.test(char_after);\n    after_is_punctuation = rePunctuation.test(char_after);\n    before_is_whitespace = reWhitespaceChar.test(char_before);\n    before_is_punctuation = rePunctuation.test(char_before);\n\n    left_flanking = !after_is_whitespace &&\n            !(after_is_punctuation && !before_is_whitespace && !before_is_punctuation);\n    right_flanking = !before_is_whitespace &&\n            !(before_is_punctuation && !after_is_whitespace && !after_is_punctuation);\n    if (cc === C_UNDERSCORE) {\n        can_open = left_flanking &&\n            (!right_flanking || before_is_punctuation);\n        can_close = right_flanking &&\n            (!left_flanking || after_is_punctuation);\n    } else {\n        can_open = left_flanking;\n        can_close = right_flanking;\n    }\n    this.pos = startpos;\n    return { numdelims: numdelims,\n             can_open: can_open,\n             can_close: can_close };\n};\n\n// Handle a delimiter marker for emphasis or a quote.\nvar handleDelim = function(cc, block) {\n    var res = this.scanDelims(cc);\n    if (!res) {\n        return false;\n    }\n    var numdelims = res.numdelims;\n    var startpos = this.pos;\n    var contents;\n\n    this.pos += numdelims;\n    if (cc === C_SINGLEQUOTE) {\n        contents = \"\\u2019\";\n    } else if (cc === C_DOUBLEQUOTE) {\n        contents = \"\\u201C\";\n    } else {\n        contents = this.subject.slice(startpos, this.pos);\n    }\n    var node = text(contents);\n    block.appendChild(node);\n\n    // Add entry to stack for this opener\n    this.delimiters = { cc: cc,\n                        numdelims: numdelims,\n                        node: node,\n                        previous: this.delimiters,\n                        next: null,\n                        can_open: res.can_open,\n                        can_close: res.can_close,\n                        active: true };\n    if (this.delimiters.previous !== null) {\n        this.delimiters.previous.next = this.delimiters;\n    }\n\n    return true;\n\n};\n\nvar removeDelimiter = function(delim) {\n    if (delim.previous !== null) {\n        delim.previous.next = delim.next;\n    }\n    if (delim.next === null) {\n        // top of stack\n        this.delimiters = delim.previous;\n    } else {\n        delim.next.previous = delim.previous;\n    }\n};\n\nvar removeDelimitersBetween = function(bottom, top) {\n    if (bottom.next !== top) {\n        bottom.next = top;\n        top.previous = bottom;\n    }\n};\n\nvar processEmphasis = function(stack_bottom) {\n    var opener, closer;\n    var opener_inl, closer_inl;\n    var tempstack;\n    var use_delims;\n    var tmp, next;\n\n    // find first closer above stack_bottom:\n    closer = this.delimiters;\n    while (closer !== null && closer.previous !== stack_bottom) {\n        closer = closer.previous;\n    }\n    // move forward, looking for closers, and handling each\n    while (closer !== null) {\n        var closercc = closer.cc;\n        if (!(closer.can_close && (closercc === C_UNDERSCORE ||\n                                   closercc === C_ASTERISK ||\n                                   closercc === C_SINGLEQUOTE ||\n                                   closercc === C_DOUBLEQUOTE))) {\n            closer = closer.next;\n        } else {\n            // found emphasis closer. now look back for first matching opener:\n            opener = closer.previous;\n            while (opener !== null && opener !== stack_bottom) {\n                if (opener.cc === closer.cc && opener.can_open) {\n                    break;\n                }\n                opener = opener.previous;\n            }\n            if (closercc === C_ASTERISK || closercc === C_UNDERSCORE) {\n                if (opener === null || opener === stack_bottom) {\n                    closer = closer.next;\n                } else {\n                    // calculate actual number of delimiters used from closer\n                    if (closer.numdelims < 3 || opener.numdelims < 3) {\n                        use_delims = closer.numdelims <= opener.numdelims ?\n                            closer.numdelims : opener.numdelims;\n                    } else {\n                        use_delims = closer.numdelims % 2 === 0 ? 2 : 1;\n                    }\n\n                    opener_inl = opener.node;\n                    closer_inl = closer.node;\n\n                    // remove used delimiters from stack elts and inlines\n                    opener.numdelims -= use_delims;\n                    closer.numdelims -= use_delims;\n                    opener_inl._literal =\n                        opener_inl._literal.slice(0,\n                                                  opener_inl._literal.length - use_delims);\n                    closer_inl._literal =\n                        closer_inl._literal.slice(0,\n                                                  closer_inl._literal.length - use_delims);\n\n                    // build contents for new emph element\n                    var emph = new Node(use_delims === 1 ? 'Emph' : 'Strong');\n\n                    tmp = opener_inl._next;\n                    while (tmp && tmp !== closer_inl) {\n                        next = tmp._next;\n                        tmp.unlink();\n                        emph.appendChild(tmp);\n                        tmp = next;\n                    }\n\n                    opener_inl.insertAfter(emph);\n\n                    // remove elts between opener and closer in delimiters stack\n                    removeDelimitersBetween(opener, closer);\n\n                    // if opener has 0 delims, remove it and the inline\n                    if (opener.numdelims === 0) {\n                        opener_inl.unlink();\n                        this.removeDelimiter(opener);\n                    }\n\n                    if (closer.numdelims === 0) {\n                        closer_inl.unlink();\n                        tempstack = closer.next;\n                        this.removeDelimiter(closer);\n                        closer = tempstack;\n                    }\n\n                }\n\n            } else if (closercc === C_SINGLEQUOTE) {\n                closer.node._literal = \"\\u2019\";\n                if (opener !== null && opener !== stack_bottom) {\n                    opener.node._literal = \"\\u2018\";\n                }\n                closer = closer.next;\n\n            } else if (closercc === C_DOUBLEQUOTE) {\n                closer.node._literal = \"\\u201D\";\n                if (opener !== null && opener !== stack_bottom) {\n                    opener.node.literal = \"\\u201C\";\n                }\n                closer = closer.next;\n\n            }\n\n        }\n\n    }\n\n    // remove all delimiters\n    while (this.delimiters !== stack_bottom) {\n        this.removeDelimiter(this.delimiters);\n    }\n};\n\n// Attempt to parse link title (sans quotes), returning the string\n// or null if no match.\nvar parseLinkTitle = function() {\n    var title = this.match(reLinkTitle);\n    if (title === null) {\n        return null;\n    } else {\n        // chop off quotes from title and unescape:\n        return unescapeString(title.substr(1, title.length - 2));\n    }\n};\n\n// Attempt to parse link destination, returning the string or\n// null if no match.\nvar parseLinkDestination = function() {\n    var res = this.match(reLinkDestinationBraces);\n    if (res === null) {\n        res = this.match(reLinkDestination);\n        if (res === null) {\n            return null;\n        } else {\n            return normalizeURI(unescapeString(res));\n        }\n    } else {  // chop off surrounding <..>:\n        return normalizeURI(unescapeString(res.substr(1, res.length - 2)));\n    }\n};\n\n// Attempt to parse a link label, returning number of characters parsed.\nvar parseLinkLabel = function() {\n    var m = this.match(reLinkLabel);\n    return m === null ? 0 : m.length;\n};\n\n// Add open bracket to delimiter stack and add a text node to block's children.\nvar parseOpenBracket = function(block) {\n    var startpos = this.pos;\n    this.pos += 1;\n\n    var node = text('[');\n    block.appendChild(node);\n\n    // Add entry to stack for this opener\n    this.delimiters = { cc: C_OPEN_BRACKET,\n                        numdelims: 1,\n                        node: node,\n                        previous: this.delimiters,\n                        next: null,\n                        can_open: true,\n                        can_close: false,\n                        index: startpos,\n                        active: true };\n    if (this.delimiters.previous !== null) {\n        this.delimiters.previous.next = this.delimiters;\n    }\n\n    return true;\n\n};\n\n// IF next character is [, and ! delimiter to delimiter stack and\n// add a text node to block's children.  Otherwise just add a text node.\nvar parseBang = function(block) {\n    var startpos = this.pos;\n    this.pos += 1;\n    if (this.peek() === C_OPEN_BRACKET) {\n        this.pos += 1;\n\n        var node = text('![');\n        block.appendChild(node);\n\n        // Add entry to stack for this opener\n        this.delimiters = { cc: C_BANG,\n                            numdelims: 1,\n                            node: node,\n                            previous: this.delimiters,\n                            next: null,\n                            can_open: true,\n                            can_close: false,\n                            index: startpos + 1,\n                            active: true };\n        if (this.delimiters.previous !== null) {\n            this.delimiters.previous.next = this.delimiters;\n        }\n    } else {\n        block.appendChild(text('!'));\n    }\n    return true;\n};\n\n// Try to match close bracket against an opening in the delimiter\n// stack.  Add either a link or image, or a plain [ character,\n// to block's children.  If there is a matching delimiter,\n// remove it from the delimiter stack.\nvar parseCloseBracket = function(block) {\n    var startpos;\n    var is_image;\n    var dest;\n    var title;\n    var matched = false;\n    var reflabel;\n    var opener;\n\n    this.pos += 1;\n    startpos = this.pos;\n\n    // look through stack of delimiters for a [ or ![\n    opener = this.delimiters;\n\n    while (opener !== null) {\n        if (opener.cc === C_OPEN_BRACKET || opener.cc === C_BANG) {\n            break;\n        }\n        opener = opener.previous;\n    }\n\n    if (opener === null) {\n        // no matched opener, just return a literal\n        block.appendChild(text(']'));\n        return true;\n    }\n\n    if (!opener.active) {\n        // no matched opener, just return a literal\n        block.appendChild(text(']'));\n        // take opener off emphasis stack\n        this.removeDelimiter(opener);\n        return true;\n    }\n\n    // If we got here, open is a potential opener\n    is_image = opener.cc === C_BANG;\n\n    // Check to see if we have a link/image\n\n    // Inline link?\n    if (this.peek() === C_OPEN_PAREN) {\n        this.pos++;\n        if (this.spnl() &&\n            ((dest = this.parseLinkDestination()) !== null) &&\n            this.spnl() &&\n            // make sure there's a space before the title:\n            (reWhitespaceChar.test(this.subject.charAt(this.pos - 1)) &&\n             (title = this.parseLinkTitle()) || true) &&\n            this.spnl() &&\n            this.peek() === C_CLOSE_PAREN) {\n            this.pos += 1;\n            matched = true;\n        }\n    } else {\n\n        // Next, see if there's a link label\n        var savepos = this.pos;\n        this.spnl();\n        var beforelabel = this.pos;\n        var n = this.parseLinkLabel();\n        if (n === 0 || n === 2) {\n            // empty or missing second label\n            reflabel = this.subject.slice(opener.index, startpos);\n        } else {\n            reflabel = this.subject.slice(beforelabel, beforelabel + n);\n        }\n        if (n === 0) {\n            // If shortcut reference link, rewind before spaces we skipped.\n            this.pos = savepos;\n        }\n\n        // lookup rawlabel in refmap\n        var link = this.refmap[normalizeReference(reflabel)];\n        if (link) {\n            dest = link.destination;\n            title = link.title;\n            matched = true;\n        }\n    }\n\n    if (matched) {\n        var node = new Node(is_image ? 'Image' : 'Link');\n        node._destination = dest;\n        node._title = title || '';\n\n        var tmp, next;\n        tmp = opener.node._next;\n        while (tmp) {\n            next = tmp._next;\n            tmp.unlink();\n            node.appendChild(tmp);\n            tmp = next;\n        }\n        block.appendChild(node);\n        this.processEmphasis(opener.previous);\n\n        opener.node.unlink();\n\n        // processEmphasis will remove this and later delimiters.\n        // Now, for a link, we also deactivate earlier link openers.\n        // (no links in links)\n        if (!is_image) {\n          opener = this.delimiters;\n          while (opener !== null) {\n            if (opener.cc === C_OPEN_BRACKET) {\n                opener.active = false; // deactivate this opener\n            }\n            opener = opener.previous;\n          }\n        }\n\n        return true;\n\n    } else { // no match\n\n        this.removeDelimiter(opener);  // remove this opener from stack\n        this.pos = startpos;\n        block.appendChild(text(']'));\n        return true;\n    }\n\n};\n\n// Attempt to parse an entity.\nvar parseEntity = function(block) {\n    var m;\n    if ((m = this.match(reEntityHere))) {\n        block.appendChild(text(entityToChar(m)));\n        return true;\n    } else {\n        return false;\n    }\n};\n\n// Parse a run of ordinary characters, or a single character with\n// a special meaning in markdown, as a plain string.\nvar parseString = function(block) {\n    var m;\n    if ((m = this.match(reMain))) {\n        if (this.options.smart) {\n            block.appendChild(text(\n                m.replace(reEllipses, \"\\u2026\")\n                    .replace(reDash, function(chars) {\n                        return (chars.length === 3) ? \"\\u2014\" : \"\\u2013\";\n                    })));\n        } else {\n            block.appendChild(text(m));\n        }\n        return true;\n    } else {\n        return false;\n    }\n};\n\n// Parse a newline.  If it was preceded by two spaces, return a hard\n// line break; otherwise a soft line break.\nvar parseNewline = function(block) {\n    this.pos += 1; // assume we're at a \\n\n    // check previous node for trailing spaces\n    var lastc = block._lastChild;\n    if (lastc && lastc.type === 'Text' && lastc._literal[lastc._literal.length - 1] === ' ') {\n        var hardbreak = lastc._literal[lastc._literal.length - 2] === ' ';\n        lastc._literal = lastc._literal.replace(reFinalSpace, '');\n        block.appendChild(new Node(hardbreak ? 'Hardbreak' : 'Softbreak'));\n    } else {\n        block.appendChild(new Node('Softbreak'));\n    }\n    this.match(reInitialSpace); // gobble leading spaces in next line\n    return true;\n};\n\n// Attempt to parse a link reference, modifying refmap.\nvar parseReference = function(s, refmap) {\n    this.subject = s;\n    this.pos = 0;\n    var rawlabel;\n    var dest;\n    var title;\n    var matchChars;\n    var startpos = this.pos;\n\n    // label:\n    matchChars = this.parseLinkLabel();\n    if (matchChars === 0) {\n        return 0;\n    } else {\n        rawlabel = this.subject.substr(0, matchChars);\n    }\n\n    // colon:\n    if (this.peek() === C_COLON) {\n        this.pos++;\n    } else {\n        this.pos = startpos;\n        return 0;\n    }\n\n    //  link url\n    this.spnl();\n\n    dest = this.parseLinkDestination();\n    if (dest === null || dest.length === 0) {\n        this.pos = startpos;\n        return 0;\n    }\n\n    var beforetitle = this.pos;\n    this.spnl();\n    title = this.parseLinkTitle();\n    if (title === null) {\n        title = '';\n        // rewind before spaces\n        this.pos = beforetitle;\n    }\n\n    // make sure we're at line end:\n    if (this.match(reSpaceAtEndOfLine) === null) {\n        this.pos = startpos;\n        return 0;\n    }\n\n    var normlabel = normalizeReference(rawlabel);\n    if (normlabel === '') {\n        // label must contain non-whitespace characters\n        this.pos = startpos;\n        return 0;\n    }\n\n    if (!refmap[normlabel]) {\n        refmap[normlabel] = { destination: dest, title: title };\n    }\n    return this.pos - startpos;\n};\n\n// Parse the next inline element in subject, advancing subject position.\n// On success, add the result to block's children and return true.\n// On failure, return false.\nvar parseInline = function(block) {\n    var res = false;\n    var c = this.peek();\n    if (c === -1) {\n        return false;\n    }\n    switch(c) {\n    case C_NEWLINE:\n        res = this.parseNewline(block);\n        break;\n    case C_BACKSLASH:\n        res = this.parseBackslash(block);\n        break;\n    case C_BACKTICK:\n        res = this.parseBackticks(block);\n        break;\n    case C_ASTERISK:\n    case C_UNDERSCORE:\n        res = this.handleDelim(c, block);\n        break;\n    case C_SINGLEQUOTE:\n    case C_DOUBLEQUOTE:\n        res = this.options.smart && this.handleDelim(c, block);\n        break;\n    case C_OPEN_BRACKET:\n        res = this.parseOpenBracket(block);\n        break;\n    case C_BANG:\n        res = this.parseBang(block);\n        break;\n    case C_CLOSE_BRACKET:\n        res = this.parseCloseBracket(block);\n        break;\n    case C_LESSTHAN:\n        res = this.parseAutolink(block) || this.parseHtmlTag(block);\n        break;\n    case C_AMPERSAND:\n        res = this.parseEntity(block);\n        break;\n    default:\n        res = this.parseString(block);\n        break;\n    }\n    if (!res) {\n        this.pos += 1;\n        block.appendChild(text(fromCodePoint(c)));\n    }\n\n    return true;\n};\n\n// Parse string content in block into inline children,\n// using refmap to resolve references.\nvar parseInlines = function(block) {\n    this.subject = block._string_content.trim();\n    this.pos = 0;\n    this.delimiters = null;\n    while (this.parseInline(block)) {\n    }\n    block._string_content = null; // allow raw string to be garbage collected\n    this.processEmphasis(null);\n};\n\n// The InlineParser object.\nfunction InlineParser(options){\n    return {\n        subject: '',\n        delimiters: null,  // used by handleDelim method\n        pos: 0,\n        refmap: {},\n        match: match,\n        peek: peek,\n        spnl: spnl,\n        parseBackticks: parseBackticks,\n        parseBackslash: parseBackslash,\n        parseAutolink: parseAutolink,\n        parseHtmlTag: parseHtmlTag,\n        scanDelims: scanDelims,\n        handleDelim: handleDelim,\n        parseLinkTitle: parseLinkTitle,\n        parseLinkDestination: parseLinkDestination,\n        parseLinkLabel: parseLinkLabel,\n        parseOpenBracket: parseOpenBracket,\n        parseCloseBracket: parseCloseBracket,\n        parseBang: parseBang,\n        parseEntity: parseEntity,\n        parseString: parseString,\n        parseNewline: parseNewline,\n        parseReference: parseReference,\n        parseInline: parseInline,\n        processEmphasis: processEmphasis,\n        removeDelimiter: removeDelimiter,\n        options: options || {},\n        parse: parseInlines\n    };\n}\n\nmodule.exports = InlineParser;\n\n},{\"./common\":115,\"./from-code-point.js\":118,\"./html5-entities.js\":120,\"./node\":123,\"./normalize-reference\":124}],123:[function(require,module,exports){\n\"use strict\";\n\nfunction isContainer(node) {\n    switch (node._type) {\n    case 'Document':\n    case 'BlockQuote':\n    case 'List':\n    case 'Item':\n    case 'Paragraph':\n    case 'Header':\n    case 'Emph':\n    case 'Strong':\n    case 'Link':\n    case 'Image':\n        return true;\n    default:\n        return false;\n    }\n}\n\nvar resumeAt = function(node, entering) {\n    this.current = node;\n    this.entering = (entering === true);\n};\n\nvar next = function(){\n    var cur = this.current;\n    var entering = this.entering;\n\n    if (cur === null) {\n        return null;\n    }\n\n    var container = isContainer(cur);\n\n    if (entering && container) {\n        if (cur._firstChild) {\n            this.current = cur._firstChild;\n            this.entering = true;\n        } else {\n            // stay on node but exit\n            this.entering = false;\n        }\n\n    } else if (cur === this.root) {\n        this.current = null;\n\n    } else if (cur._next === null) {\n        this.current = cur._parent;\n        this.entering = false;\n\n    } else {\n        this.current = cur._next;\n        this.entering = true;\n    }\n\n    return {entering: entering, node: cur};\n};\n\nvar NodeWalker = function(root) {\n    return { current: root,\n             root: root,\n             entering: true,\n             next: next,\n             resumeAt: resumeAt };\n};\n\nvar Node = function(nodeType, sourcepos) {\n    this._type = nodeType;\n    this._parent = null;\n    this._firstChild = null;\n    this._lastChild = null;\n    this._prev = null;\n    this._next = null;\n    this._sourcepos = sourcepos;\n    this._lastLineBlank = false;\n    this._open = true;\n    this._string_content = null;\n    this._literal = null;\n    this._listData = null;\n    this._info = null;\n    this._destination = null;\n    this._title = null;\n    this._isFenced = false;\n    this._fenceChar = null;\n    this._fenceLength = 0;\n    this._fenceOffset = null;\n    this._level = null;\n};\n\nvar proto = Node.prototype;\n\nObject.defineProperty(proto, 'isContainer', {\n    get: function () { return isContainer(this); }\n});\n\nObject.defineProperty(proto, 'type', {\n    get: function() { return this._type; }\n});\n\nObject.defineProperty(proto, 'firstChild', {\n    get: function() { return this._firstChild; }\n});\n\nObject.defineProperty(proto, 'lastChild', {\n    get: function() { return this._lastChild; }\n});\n\nObject.defineProperty(proto, 'next', {\n    get: function() { return this._next; }\n});\n\nObject.defineProperty(proto, 'prev', {\n    get: function() { return this._prev; }\n});\n\nObject.defineProperty(proto, 'parent', {\n    get: function() { return this._parent; }\n});\n\nObject.defineProperty(proto, 'sourcepos', {\n    get: function() { return this._sourcepos; }\n});\n\nObject.defineProperty(proto, 'literal', {\n    get: function() { return this._literal; },\n    set: function(s) { this._literal = s; }\n});\n\nObject.defineProperty(proto, 'destination', {\n    get: function() { return this._destination; },\n    set: function(s) { this._destination = s; }\n});\n\nObject.defineProperty(proto, 'title', {\n    get: function() { return this._title; },\n    set: function(s) { this._title = s; }\n});\n\nObject.defineProperty(proto, 'info', {\n    get: function() { return this._info; },\n    set: function(s) { this._info = s; }\n});\n\nObject.defineProperty(proto, 'level', {\n    get: function() { return this._level; },\n    set: function(s) { this._level = s; }\n});\n\nObject.defineProperty(proto, 'listType', {\n    get: function() { return this._listData.type; },\n    set: function(t) { this._listData.type = t; }\n});\n\nObject.defineProperty(proto, 'listTight', {\n    get: function() { return this._listData.tight; },\n    set: function(t) { this._listData.tight = t; }\n});\n\nObject.defineProperty(proto, 'listStart', {\n    get: function() { return this._listData.start; },\n    set: function(n) { this._listData.start = n; }\n});\n\nObject.defineProperty(proto, 'listDelimiter', {\n    get: function() { return this._listData.delimiter; },\n    set: function(delim) { this._listData.delimiter = delim; }\n});\n\nNode.prototype.appendChild = function(child) {\n    child.unlink();\n    child._parent = this;\n    if (this._lastChild) {\n        this._lastChild._next = child;\n        child._prev = this._lastChild;\n        this._lastChild = child;\n    } else {\n        this._firstChild = child;\n        this._lastChild = child;\n    }\n};\n\nNode.prototype.prependChild = function(child) {\n    child.unlink();\n    child._parent = this;\n    if (this._firstChild) {\n        this._firstChild._prev = child;\n        child._next = this._firstChild;\n        this._firstChild = child;\n    } else {\n        this._firstChild = child;\n        this._lastChild = child;\n    }\n};\n\nNode.prototype.unlink = function() {\n    if (this._prev) {\n        this._prev._next = this._next;\n    } else if (this._parent) {\n        this._parent._firstChild = this._next;\n    }\n    if (this._next) {\n        this._next._prev = this._prev;\n    } else if (this._parent) {\n        this._parent._lastChild = this._prev;\n    }\n    this._parent = null;\n    this._next = null;\n    this._prev = null;\n};\n\nNode.prototype.insertAfter = function(sibling) {\n    sibling.unlink();\n    sibling._next = this._next;\n    if (sibling._next) {\n        sibling._next._prev = sibling;\n    }\n    sibling._prev = this;\n    this._next = sibling;\n    sibling._parent = this._parent;\n    if (!sibling._next) {\n        sibling._parent._lastChild = sibling;\n    }\n};\n\nNode.prototype.insertBefore = function(sibling) {\n    sibling.unlink();\n    sibling._prev = this._prev;\n    if (sibling._prev) {\n        sibling._prev._next = sibling;\n    }\n    sibling._next = this;\n    this._prev = sibling;\n    sibling._parent = this._parent;\n    if (!sibling._prev) {\n        sibling._parent._firstChild = sibling;\n    }\n};\n\nNode.prototype.walker = function() {\n    var walker = new NodeWalker(this);\n    return walker;\n};\n\nmodule.exports = Node;\n\n\n/* Example of use of walker:\n\n var walker = w.walker();\n var event;\n\n while (event = walker.next()) {\n console.log(event.entering, event.node.type);\n }\n\n */\n\n},{}],124:[function(require,module,exports){\n\"use strict\";\n\n/* The bulk of this code derives from https://github.com/dmoscrop/fold-case\nBut in addition to case-folding, we also normalize whitespace.\n\nfold-case is Copyright Mathias Bynens <https://mathiasbynens.be/>\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n/*eslint-disable  key-spacing, comma-spacing */\n\nvar regex = /[ \\t\\r\\n]+|[A-Z\\xB5\\xC0-\\xD6\\xD8-\\xDF\\u0100\\u0102\\u0104\\u0106\\u0108\\u010A\\u010C\\u010E\\u0110\\u0112\\u0114\\u0116\\u0118\\u011A\\u011C\\u011E\\u0120\\u0122\\u0124\\u0126\\u0128\\u012A\\u012C\\u012E\\u0130\\u0132\\u0134\\u0136\\u0139\\u013B\\u013D\\u013F\\u0141\\u0143\\u0145\\u0147\\u0149\\u014A\\u014C\\u014E\\u0150\\u0152\\u0154\\u0156\\u0158\\u015A\\u015C\\u015E\\u0160\\u0162\\u0164\\u0166\\u0168\\u016A\\u016C\\u016E\\u0170\\u0172\\u0174\\u0176\\u0178\\u0179\\u017B\\u017D\\u017F\\u0181\\u0182\\u0184\\u0186\\u0187\\u0189-\\u018B\\u018E-\\u0191\\u0193\\u0194\\u0196-\\u0198\\u019C\\u019D\\u019F\\u01A0\\u01A2\\u01A4\\u01A6\\u01A7\\u01A9\\u01AC\\u01AE\\u01AF\\u01B1-\\u01B3\\u01B5\\u01B7\\u01B8\\u01BC\\u01C4\\u01C5\\u01C7\\u01C8\\u01CA\\u01CB\\u01CD\\u01CF\\u01D1\\u01D3\\u01D5\\u01D7\\u01D9\\u01DB\\u01DE\\u01E0\\u01E2\\u01E4\\u01E6\\u01E8\\u01EA\\u01EC\\u01EE\\u01F0-\\u01F2\\u01F4\\u01F6-\\u01F8\\u01FA\\u01FC\\u01FE\\u0200\\u0202\\u0204\\u0206\\u0208\\u020A\\u020C\\u020E\\u0210\\u0212\\u0214\\u0216\\u0218\\u021A\\u021C\\u021E\\u0220\\u0222\\u0224\\u0226\\u0228\\u022A\\u022C\\u022E\\u0230\\u0232\\u023A\\u023B\\u023D\\u023E\\u0241\\u0243-\\u0246\\u0248\\u024A\\u024C\\u024E\\u0345\\u0370\\u0372\\u0376\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03AB\\u03B0\\u03C2\\u03CF-\\u03D1\\u03D5\\u03D6\\u03D8\\u03DA\\u03DC\\u03DE\\u03E0\\u03E2\\u03E4\\u03E6\\u03E8\\u03EA\\u03EC\\u03EE\\u03F0\\u03F1\\u03F4\\u03F5\\u03F7\\u03F9\\u03FA\\u03FD-\\u042F\\u0460\\u0462\\u0464\\u0466\\u0468\\u046A\\u046C\\u046E\\u0470\\u0472\\u0474\\u0476\\u0478\\u047A\\u047C\\u047E\\u0480\\u048A\\u048C\\u048E\\u0490\\u0492\\u0494\\u0496\\u0498\\u049A\\u049C\\u049E\\u04A0\\u04A2\\u04A4\\u04A6\\u04A8\\u04AA\\u04AC\\u04AE\\u04B0\\u04B2\\u04B4\\u04B6\\u04B8\\u04BA\\u04BC\\u04BE\\u04C0\\u04C1\\u04C3\\u04C5\\u04C7\\u04C9\\u04CB\\u04CD\\u04D0\\u04D2\\u04D4\\u04D6\\u04D8\\u04DA\\u04DC\\u04DE\\u04E0\\u04E2\\u04E4\\u04E6\\u04E8\\u04EA\\u04EC\\u04EE\\u04F0\\u04F2\\u04F4\\u04F6\\u04F8\\u04FA\\u04FC\\u04FE\\u0500\\u0502\\u0504\\u0506\\u0508\\u050A\\u050C\\u050E\\u0510\\u0512\\u0514\\u0516\\u0518\\u051A\\u051C\\u051E\\u0520\\u0522\\u0524\\u0526\\u0528\\u052A\\u052C\\u052E\\u0531-\\u0556\\u0587\\u10A0-\\u10C5\\u10C7\\u10CD\\u1E00\\u1E02\\u1E04\\u1E06\\u1E08\\u1E0A\\u1E0C\\u1E0E\\u1E10\\u1E12\\u1E14\\u1E16\\u1E18\\u1E1A\\u1E1C\\u1E1E\\u1E20\\u1E22\\u1E24\\u1E26\\u1E28\\u1E2A\\u1E2C\\u1E2E\\u1E30\\u1E32\\u1E34\\u1E36\\u1E38\\u1E3A\\u1E3C\\u1E3E\\u1E40\\u1E42\\u1E44\\u1E46\\u1E48\\u1E4A\\u1E4C\\u1E4E\\u1E50\\u1E52\\u1E54\\u1E56\\u1E58\\u1E5A\\u1E5C\\u1E5E\\u1E60\\u1E62\\u1E64\\u1E66\\u1E68\\u1E6A\\u1E6C\\u1E6E\\u1E70\\u1E72\\u1E74\\u1E76\\u1E78\\u1E7A\\u1E7C\\u1E7E\\u1E80\\u1E82\\u1E84\\u1E86\\u1E88\\u1E8A\\u1E8C\\u1E8E\\u1E90\\u1E92\\u1E94\\u1E96-\\u1E9B\\u1E9E\\u1EA0\\u1EA2\\u1EA4\\u1EA6\\u1EA8\\u1EAA\\u1EAC\\u1EAE\\u1EB0\\u1EB2\\u1EB4\\u1EB6\\u1EB8\\u1EBA\\u1EBC\\u1EBE\\u1EC0\\u1EC2\\u1EC4\\u1EC6\\u1EC8\\u1ECA\\u1ECC\\u1ECE\\u1ED0\\u1ED2\\u1ED4\\u1ED6\\u1ED8\\u1EDA\\u1EDC\\u1EDE\\u1EE0\\u1EE2\\u1EE4\\u1EE6\\u1EE8\\u1EEA\\u1EEC\\u1EEE\\u1EF0\\u1EF2\\u1EF4\\u1EF6\\u1EF8\\u1EFA\\u1EFC\\u1EFE\\u1F08-\\u1F0F\\u1F18-\\u1F1D\\u1F28-\\u1F2F\\u1F38-\\u1F3F\\u1F48-\\u1F4D\\u1F50\\u1F52\\u1F54\\u1F56\\u1F59\\u1F5B\\u1F5D\\u1F5F\\u1F68-\\u1F6F\\u1F80-\\u1FAF\\u1FB2-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD2\\u1FD3\\u1FD6-\\u1FDB\\u1FE2-\\u1FE4\\u1FE6-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2126\\u212A\\u212B\\u2132\\u2160-\\u216F\\u2183\\u24B6-\\u24CF\\u2C00-\\u2C2E\\u2C60\\u2C62-\\u2C64\\u2C67\\u2C69\\u2C6B\\u2C6D-\\u2C70\\u2C72\\u2C75\\u2C7E-\\u2C80\\u2C82\\u2C84\\u2C86\\u2C88\\u2C8A\\u2C8C\\u2C8E\\u2C90\\u2C92\\u2C94\\u2C96\\u2C98\\u2C9A\\u2C9C\\u2C9E\\u2CA0\\u2CA2\\u2CA4\\u2CA6\\u2CA8\\u2CAA\\u2CAC\\u2CAE\\u2CB0\\u2CB2\\u2CB4\\u2CB6\\u2CB8\\u2CBA\\u2CBC\\u2CBE\\u2CC0\\u2CC2\\u2CC4\\u2CC6\\u2CC8\\u2CCA\\u2CCC\\u2CCE\\u2CD0\\u2CD2\\u2CD4\\u2CD6\\u2CD8\\u2CDA\\u2CDC\\u2CDE\\u2CE0\\u2CE2\\u2CEB\\u2CED\\u2CF2\\uA640\\uA642\\uA644\\uA646\\uA648\\uA64A\\uA64C\\uA64E\\uA650\\uA652\\uA654\\uA656\\uA658\\uA65A\\uA65C\\uA65E\\uA660\\uA662\\uA664\\uA666\\uA668\\uA66A\\uA66C\\uA680\\uA682\\uA684\\uA686\\uA688\\uA68A\\uA68C\\uA68E\\uA690\\uA692\\uA694\\uA696\\uA698\\uA69A\\uA722\\uA724\\uA726\\uA728\\uA72A\\uA72C\\uA72E\\uA732\\uA734\\uA736\\uA738\\uA73A\\uA73C\\uA73E\\uA740\\uA742\\uA744\\uA746\\uA748\\uA74A\\uA74C\\uA74E\\uA750\\uA752\\uA754\\uA756\\uA758\\uA75A\\uA75C\\uA75E\\uA760\\uA762\\uA764\\uA766\\uA768\\uA76A\\uA76C\\uA76E\\uA779\\uA77B\\uA77D\\uA77E\\uA780\\uA782\\uA784\\uA786\\uA78B\\uA78D\\uA790\\uA792\\uA796\\uA798\\uA79A\\uA79C\\uA79E\\uA7A0\\uA7A2\\uA7A4\\uA7A6\\uA7A8\\uA7AA-\\uA7AD\\uA7B0\\uA7B1\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFF21-\\uFF3A]|\\uD801[\\uDC00-\\uDC27]|\\uD806[\\uDCA0-\\uDCBF]/g;\n\nvar map = {'A':'a','B':'b','C':'c','D':'d','E':'e','F':'f','G':'g','H':'h','I':'i','J':'j','K':'k','L':'l','M':'m','N':'n','O':'o','P':'p','Q':'q','R':'r','S':'s','T':'t','U':'u','V':'v','W':'w','X':'x','Y':'y','Z':'z','\\xB5':'\\u03BC','\\xC0':'\\xE0','\\xC1':'\\xE1','\\xC2':'\\xE2','\\xC3':'\\xE3','\\xC4':'\\xE4','\\xC5':'\\xE5','\\xC6':'\\xE6','\\xC7':'\\xE7','\\xC8':'\\xE8','\\xC9':'\\xE9','\\xCA':'\\xEA','\\xCB':'\\xEB','\\xCC':'\\xEC','\\xCD':'\\xED','\\xCE':'\\xEE','\\xCF':'\\xEF','\\xD0':'\\xF0','\\xD1':'\\xF1','\\xD2':'\\xF2','\\xD3':'\\xF3','\\xD4':'\\xF4','\\xD5':'\\xF5','\\xD6':'\\xF6','\\xD8':'\\xF8','\\xD9':'\\xF9','\\xDA':'\\xFA','\\xDB':'\\xFB','\\xDC':'\\xFC','\\xDD':'\\xFD','\\xDE':'\\xFE','\\u0100':'\\u0101','\\u0102':'\\u0103','\\u0104':'\\u0105','\\u0106':'\\u0107','\\u0108':'\\u0109','\\u010A':'\\u010B','\\u010C':'\\u010D','\\u010E':'\\u010F','\\u0110':'\\u0111','\\u0112':'\\u0113','\\u0114':'\\u0115','\\u0116':'\\u0117','\\u0118':'\\u0119','\\u011A':'\\u011B','\\u011C':'\\u011D','\\u011E':'\\u011F','\\u0120':'\\u0121','\\u0122':'\\u0123','\\u0124':'\\u0125','\\u0126':'\\u0127','\\u0128':'\\u0129','\\u012A':'\\u012B','\\u012C':'\\u012D','\\u012E':'\\u012F','\\u0132':'\\u0133','\\u0134':'\\u0135','\\u0136':'\\u0137','\\u0139':'\\u013A','\\u013B':'\\u013C','\\u013D':'\\u013E','\\u013F':'\\u0140','\\u0141':'\\u0142','\\u0143':'\\u0144','\\u0145':'\\u0146','\\u0147':'\\u0148','\\u014A':'\\u014B','\\u014C':'\\u014D','\\u014E':'\\u014F','\\u0150':'\\u0151','\\u0152':'\\u0153','\\u0154':'\\u0155','\\u0156':'\\u0157','\\u0158':'\\u0159','\\u015A':'\\u015B','\\u015C':'\\u015D','\\u015E':'\\u015F','\\u0160':'\\u0161','\\u0162':'\\u0163','\\u0164':'\\u0165','\\u0166':'\\u0167','\\u0168':'\\u0169','\\u016A':'\\u016B','\\u016C':'\\u016D','\\u016E':'\\u016F','\\u0170':'\\u0171','\\u0172':'\\u0173','\\u0174':'\\u0175','\\u0176':'\\u0177','\\u0178':'\\xFF','\\u0179':'\\u017A','\\u017B':'\\u017C','\\u017D':'\\u017E','\\u017F':'s','\\u0181':'\\u0253','\\u0182':'\\u0183','\\u0184':'\\u0185','\\u0186':'\\u0254','\\u0187':'\\u0188','\\u0189':'\\u0256','\\u018A':'\\u0257','\\u018B':'\\u018C','\\u018E':'\\u01DD','\\u018F':'\\u0259','\\u0190':'\\u025B','\\u0191':'\\u0192','\\u0193':'\\u0260','\\u0194':'\\u0263','\\u0196':'\\u0269','\\u0197':'\\u0268','\\u0198':'\\u0199','\\u019C':'\\u026F','\\u019D':'\\u0272','\\u019F':'\\u0275','\\u01A0':'\\u01A1','\\u01A2':'\\u01A3','\\u01A4':'\\u01A5','\\u01A6':'\\u0280','\\u01A7':'\\u01A8','\\u01A9':'\\u0283','\\u01AC':'\\u01AD','\\u01AE':'\\u0288','\\u01AF':'\\u01B0','\\u01B1':'\\u028A','\\u01B2':'\\u028B','\\u01B3':'\\u01B4','\\u01B5':'\\u01B6','\\u01B7':'\\u0292','\\u01B8':'\\u01B9','\\u01BC':'\\u01BD','\\u01C4':'\\u01C6','\\u01C5':'\\u01C6','\\u01C7':'\\u01C9','\\u01C8':'\\u01C9','\\u01CA':'\\u01CC','\\u01CB':'\\u01CC','\\u01CD':'\\u01CE','\\u01CF':'\\u01D0','\\u01D1':'\\u01D2','\\u01D3':'\\u01D4','\\u01D5':'\\u01D6','\\u01D7':'\\u01D8','\\u01D9':'\\u01DA','\\u01DB':'\\u01DC','\\u01DE':'\\u01DF','\\u01E0':'\\u01E1','\\u01E2':'\\u01E3','\\u01E4':'\\u01E5','\\u01E6':'\\u01E7','\\u01E8':'\\u01E9','\\u01EA':'\\u01EB','\\u01EC':'\\u01ED','\\u01EE':'\\u01EF','\\u01F1':'\\u01F3','\\u01F2':'\\u01F3','\\u01F4':'\\u01F5','\\u01F6':'\\u0195','\\u01F7':'\\u01BF','\\u01F8':'\\u01F9','\\u01FA':'\\u01FB','\\u01FC':'\\u01FD','\\u01FE':'\\u01FF','\\u0200':'\\u0201','\\u0202':'\\u0203','\\u0204':'\\u0205','\\u0206':'\\u0207','\\u0208':'\\u0209','\\u020A':'\\u020B','\\u020C':'\\u020D','\\u020E':'\\u020F','\\u0210':'\\u0211','\\u0212':'\\u0213','\\u0214':'\\u0215','\\u0216':'\\u0217','\\u0218':'\\u0219','\\u021A':'\\u021B','\\u021C':'\\u021D','\\u021E':'\\u021F','\\u0220':'\\u019E','\\u0222':'\\u0223','\\u0224':'\\u0225','\\u0226':'\\u0227','\\u0228':'\\u0229','\\u022A':'\\u022B','\\u022C':'\\u022D','\\u022E':'\\u022F','\\u0230':'\\u0231','\\u0232':'\\u0233','\\u023A':'\\u2C65','\\u023B':'\\u023C','\\u023D':'\\u019A','\\u023E':'\\u2C66','\\u0241':'\\u0242','\\u0243':'\\u0180','\\u0244':'\\u0289','\\u0245':'\\u028C','\\u0246':'\\u0247','\\u0248':'\\u0249','\\u024A':'\\u024B','\\u024C':'\\u024D','\\u024E':'\\u024F','\\u0345':'\\u03B9','\\u0370':'\\u0371','\\u0372':'\\u0373','\\u0376':'\\u0377','\\u037F':'\\u03F3','\\u0386':'\\u03AC','\\u0388':'\\u03AD','\\u0389':'\\u03AE','\\u038A':'\\u03AF','\\u038C':'\\u03CC','\\u038E':'\\u03CD','\\u038F':'\\u03CE','\\u0391':'\\u03B1','\\u0392':'\\u03B2','\\u0393':'\\u03B3','\\u0394':'\\u03B4','\\u0395':'\\u03B5','\\u0396':'\\u03B6','\\u0397':'\\u03B7','\\u0398':'\\u03B8','\\u0399':'\\u03B9','\\u039A':'\\u03BA','\\u039B':'\\u03BB','\\u039C':'\\u03BC','\\u039D':'\\u03BD','\\u039E':'\\u03BE','\\u039F':'\\u03BF','\\u03A0':'\\u03C0','\\u03A1':'\\u03C1','\\u03A3':'\\u03C3','\\u03A4':'\\u03C4','\\u03A5':'\\u03C5','\\u03A6':'\\u03C6','\\u03A7':'\\u03C7','\\u03A8':'\\u03C8','\\u03A9':'\\u03C9','\\u03AA':'\\u03CA','\\u03AB':'\\u03CB','\\u03C2':'\\u03C3','\\u03CF':'\\u03D7','\\u03D0':'\\u03B2','\\u03D1':'\\u03B8','\\u03D5':'\\u03C6','\\u03D6':'\\u03C0','\\u03D8':'\\u03D9','\\u03DA':'\\u03DB','\\u03DC':'\\u03DD','\\u03DE':'\\u03DF','\\u03E0':'\\u03E1','\\u03E2':'\\u03E3','\\u03E4':'\\u03E5','\\u03E6':'\\u03E7','\\u03E8':'\\u03E9','\\u03EA':'\\u03EB','\\u03EC':'\\u03ED','\\u03EE':'\\u03EF','\\u03F0':'\\u03BA','\\u03F1':'\\u03C1','\\u03F4':'\\u03B8','\\u03F5':'\\u03B5','\\u03F7':'\\u03F8','\\u03F9':'\\u03F2','\\u03FA':'\\u03FB','\\u03FD':'\\u037B','\\u03FE':'\\u037C','\\u03FF':'\\u037D','\\u0400':'\\u0450','\\u0401':'\\u0451','\\u0402':'\\u0452','\\u0403':'\\u0453','\\u0404':'\\u0454','\\u0405':'\\u0455','\\u0406':'\\u0456','\\u0407':'\\u0457','\\u0408':'\\u0458','\\u0409':'\\u0459','\\u040A':'\\u045A','\\u040B':'\\u045B','\\u040C':'\\u045C','\\u040D':'\\u045D','\\u040E':'\\u045E','\\u040F':'\\u045F','\\u0410':'\\u0430','\\u0411':'\\u0431','\\u0412':'\\u0432','\\u0413':'\\u0433','\\u0414':'\\u0434','\\u0415':'\\u0435','\\u0416':'\\u0436','\\u0417':'\\u0437','\\u0418':'\\u0438','\\u0419':'\\u0439','\\u041A':'\\u043A','\\u041B':'\\u043B','\\u041C':'\\u043C','\\u041D':'\\u043D','\\u041E':'\\u043E','\\u041F':'\\u043F','\\u0420':'\\u0440','\\u0421':'\\u0441','\\u0422':'\\u0442','\\u0423':'\\u0443','\\u0424':'\\u0444','\\u0425':'\\u0445','\\u0426':'\\u0446','\\u0427':'\\u0447','\\u0428':'\\u0448','\\u0429':'\\u0449','\\u042A':'\\u044A','\\u042B':'\\u044B','\\u042C':'\\u044C','\\u042D':'\\u044D','\\u042E':'\\u044E','\\u042F':'\\u044F','\\u0460':'\\u0461','\\u0462':'\\u0463','\\u0464':'\\u0465','\\u0466':'\\u0467','\\u0468':'\\u0469','\\u046A':'\\u046B','\\u046C':'\\u046D','\\u046E':'\\u046F','\\u0470':'\\u0471','\\u0472':'\\u0473','\\u0474':'\\u0475','\\u0476':'\\u0477','\\u0478':'\\u0479','\\u047A':'\\u047B','\\u047C':'\\u047D','\\u047E':'\\u047F','\\u0480':'\\u0481','\\u048A':'\\u048B','\\u048C':'\\u048D','\\u048E':'\\u048F','\\u0490':'\\u0491','\\u0492':'\\u0493','\\u0494':'\\u0495','\\u0496':'\\u0497','\\u0498':'\\u0499','\\u049A':'\\u049B','\\u049C':'\\u049D','\\u049E':'\\u049F','\\u04A0':'\\u04A1','\\u04A2':'\\u04A3','\\u04A4':'\\u04A5','\\u04A6':'\\u04A7','\\u04A8':'\\u04A9','\\u04AA':'\\u04AB','\\u04AC':'\\u04AD','\\u04AE':'\\u04AF','\\u04B0':'\\u04B1','\\u04B2':'\\u04B3','\\u04B4':'\\u04B5','\\u04B6':'\\u04B7','\\u04B8':'\\u04B9','\\u04BA':'\\u04BB','\\u04BC':'\\u04BD','\\u04BE':'\\u04BF','\\u04C0':'\\u04CF','\\u04C1':'\\u04C2','\\u04C3':'\\u04C4','\\u04C5':'\\u04C6','\\u04C7':'\\u04C8','\\u04C9':'\\u04CA','\\u04CB':'\\u04CC','\\u04CD':'\\u04CE','\\u04D0':'\\u04D1','\\u04D2':'\\u04D3','\\u04D4':'\\u04D5','\\u04D6':'\\u04D7','\\u04D8':'\\u04D9','\\u04DA':'\\u04DB','\\u04DC':'\\u04DD','\\u04DE':'\\u04DF','\\u04E0':'\\u04E1','\\u04E2':'\\u04E3','\\u04E4':'\\u04E5','\\u04E6':'\\u04E7','\\u04E8':'\\u04E9','\\u04EA':'\\u04EB','\\u04EC':'\\u04ED','\\u04EE':'\\u04EF','\\u04F0':'\\u04F1','\\u04F2':'\\u04F3','\\u04F4':'\\u04F5','\\u04F6':'\\u04F7','\\u04F8':'\\u04F9','\\u04FA':'\\u04FB','\\u04FC':'\\u04FD','\\u04FE':'\\u04FF','\\u0500':'\\u0501','\\u0502':'\\u0503','\\u0504':'\\u0505','\\u0506':'\\u0507','\\u0508':'\\u0509','\\u050A':'\\u050B','\\u050C':'\\u050D','\\u050E':'\\u050F','\\u0510':'\\u0511','\\u0512':'\\u0513','\\u0514':'\\u0515','\\u0516':'\\u0517','\\u0518':'\\u0519','\\u051A':'\\u051B','\\u051C':'\\u051D','\\u051E':'\\u051F','\\u0520':'\\u0521','\\u0522':'\\u0523','\\u0524':'\\u0525','\\u0526':'\\u0527','\\u0528':'\\u0529','\\u052A':'\\u052B','\\u052C':'\\u052D','\\u052E':'\\u052F','\\u0531':'\\u0561','\\u0532':'\\u0562','\\u0533':'\\u0563','\\u0534':'\\u0564','\\u0535':'\\u0565','\\u0536':'\\u0566','\\u0537':'\\u0567','\\u0538':'\\u0568','\\u0539':'\\u0569','\\u053A':'\\u056A','\\u053B':'\\u056B','\\u053C':'\\u056C','\\u053D':'\\u056D','\\u053E':'\\u056E','\\u053F':'\\u056F','\\u0540':'\\u0570','\\u0541':'\\u0571','\\u0542':'\\u0572','\\u0543':'\\u0573','\\u0544':'\\u0574','\\u0545':'\\u0575','\\u0546':'\\u0576','\\u0547':'\\u0577','\\u0548':'\\u0578','\\u0549':'\\u0579','\\u054A':'\\u057A','\\u054B':'\\u057B','\\u054C':'\\u057C','\\u054D':'\\u057D','\\u054E':'\\u057E','\\u054F':'\\u057F','\\u0550':'\\u0580','\\u0551':'\\u0581','\\u0552':'\\u0582','\\u0553':'\\u0583','\\u0554':'\\u0584','\\u0555':'\\u0585','\\u0556':'\\u0586','\\u10A0':'\\u2D00','\\u10A1':'\\u2D01','\\u10A2':'\\u2D02','\\u10A3':'\\u2D03','\\u10A4':'\\u2D04','\\u10A5':'\\u2D05','\\u10A6':'\\u2D06','\\u10A7':'\\u2D07','\\u10A8':'\\u2D08','\\u10A9':'\\u2D09','\\u10AA':'\\u2D0A','\\u10AB':'\\u2D0B','\\u10AC':'\\u2D0C','\\u10AD':'\\u2D0D','\\u10AE':'\\u2D0E','\\u10AF':'\\u2D0F','\\u10B0':'\\u2D10','\\u10B1':'\\u2D11','\\u10B2':'\\u2D12','\\u10B3':'\\u2D13','\\u10B4':'\\u2D14','\\u10B5':'\\u2D15','\\u10B6':'\\u2D16','\\u10B7':'\\u2D17','\\u10B8':'\\u2D18','\\u10B9':'\\u2D19','\\u10BA':'\\u2D1A','\\u10BB':'\\u2D1B','\\u10BC':'\\u2D1C','\\u10BD':'\\u2D1D','\\u10BE':'\\u2D1E','\\u10BF':'\\u2D1F','\\u10C0':'\\u2D20','\\u10C1':'\\u2D21','\\u10C2':'\\u2D22','\\u10C3':'\\u2D23','\\u10C4':'\\u2D24','\\u10C5':'\\u2D25','\\u10C7':'\\u2D27','\\u10CD':'\\u2D2D','\\u1E00':'\\u1E01','\\u1E02':'\\u1E03','\\u1E04':'\\u1E05','\\u1E06':'\\u1E07','\\u1E08':'\\u1E09','\\u1E0A':'\\u1E0B','\\u1E0C':'\\u1E0D','\\u1E0E':'\\u1E0F','\\u1E10':'\\u1E11','\\u1E12':'\\u1E13','\\u1E14':'\\u1E15','\\u1E16':'\\u1E17','\\u1E18':'\\u1E19','\\u1E1A':'\\u1E1B','\\u1E1C':'\\u1E1D','\\u1E1E':'\\u1E1F','\\u1E20':'\\u1E21','\\u1E22':'\\u1E23','\\u1E24':'\\u1E25','\\u1E26':'\\u1E27','\\u1E28':'\\u1E29','\\u1E2A':'\\u1E2B','\\u1E2C':'\\u1E2D','\\u1E2E':'\\u1E2F','\\u1E30':'\\u1E31','\\u1E32':'\\u1E33','\\u1E34':'\\u1E35','\\u1E36':'\\u1E37','\\u1E38':'\\u1E39','\\u1E3A':'\\u1E3B','\\u1E3C':'\\u1E3D','\\u1E3E':'\\u1E3F','\\u1E40':'\\u1E41','\\u1E42':'\\u1E43','\\u1E44':'\\u1E45','\\u1E46':'\\u1E47','\\u1E48':'\\u1E49','\\u1E4A':'\\u1E4B','\\u1E4C':'\\u1E4D','\\u1E4E':'\\u1E4F','\\u1E50':'\\u1E51','\\u1E52':'\\u1E53','\\u1E54':'\\u1E55','\\u1E56':'\\u1E57','\\u1E58':'\\u1E59','\\u1E5A':'\\u1E5B','\\u1E5C':'\\u1E5D','\\u1E5E':'\\u1E5F','\\u1E60':'\\u1E61','\\u1E62':'\\u1E63','\\u1E64':'\\u1E65','\\u1E66':'\\u1E67','\\u1E68':'\\u1E69','\\u1E6A':'\\u1E6B','\\u1E6C':'\\u1E6D','\\u1E6E':'\\u1E6F','\\u1E70':'\\u1E71','\\u1E72':'\\u1E73','\\u1E74':'\\u1E75','\\u1E76':'\\u1E77','\\u1E78':'\\u1E79','\\u1E7A':'\\u1E7B','\\u1E7C':'\\u1E7D','\\u1E7E':'\\u1E7F','\\u1E80':'\\u1E81','\\u1E82':'\\u1E83','\\u1E84':'\\u1E85','\\u1E86':'\\u1E87','\\u1E88':'\\u1E89','\\u1E8A':'\\u1E8B','\\u1E8C':'\\u1E8D','\\u1E8E':'\\u1E8F','\\u1E90':'\\u1E91','\\u1E92':'\\u1E93','\\u1E94':'\\u1E95','\\u1E9B':'\\u1E61','\\u1EA0':'\\u1EA1','\\u1EA2':'\\u1EA3','\\u1EA4':'\\u1EA5','\\u1EA6':'\\u1EA7','\\u1EA8':'\\u1EA9','\\u1EAA':'\\u1EAB','\\u1EAC':'\\u1EAD','\\u1EAE':'\\u1EAF','\\u1EB0':'\\u1EB1','\\u1EB2':'\\u1EB3','\\u1EB4':'\\u1EB5','\\u1EB6':'\\u1EB7','\\u1EB8':'\\u1EB9','\\u1EBA':'\\u1EBB','\\u1EBC':'\\u1EBD','\\u1EBE':'\\u1EBF','\\u1EC0':'\\u1EC1','\\u1EC2':'\\u1EC3','\\u1EC4':'\\u1EC5','\\u1EC6':'\\u1EC7','\\u1EC8':'\\u1EC9','\\u1ECA':'\\u1ECB','\\u1ECC':'\\u1ECD','\\u1ECE':'\\u1ECF','\\u1ED0':'\\u1ED1','\\u1ED2':'\\u1ED3','\\u1ED4':'\\u1ED5','\\u1ED6':'\\u1ED7','\\u1ED8':'\\u1ED9','\\u1EDA':'\\u1EDB','\\u1EDC':'\\u1EDD','\\u1EDE':'\\u1EDF','\\u1EE0':'\\u1EE1','\\u1EE2':'\\u1EE3','\\u1EE4':'\\u1EE5','\\u1EE6':'\\u1EE7','\\u1EE8':'\\u1EE9','\\u1EEA':'\\u1EEB','\\u1EEC':'\\u1EED','\\u1EEE':'\\u1EEF','\\u1EF0':'\\u1EF1','\\u1EF2':'\\u1EF3','\\u1EF4':'\\u1EF5','\\u1EF6':'\\u1EF7','\\u1EF8':'\\u1EF9','\\u1EFA':'\\u1EFB','\\u1EFC':'\\u1EFD','\\u1EFE':'\\u1EFF','\\u1F08':'\\u1F00','\\u1F09':'\\u1F01','\\u1F0A':'\\u1F02','\\u1F0B':'\\u1F03','\\u1F0C':'\\u1F04','\\u1F0D':'\\u1F05','\\u1F0E':'\\u1F06','\\u1F0F':'\\u1F07','\\u1F18':'\\u1F10','\\u1F19':'\\u1F11','\\u1F1A':'\\u1F12','\\u1F1B':'\\u1F13','\\u1F1C':'\\u1F14','\\u1F1D':'\\u1F15','\\u1F28':'\\u1F20','\\u1F29':'\\u1F21','\\u1F2A':'\\u1F22','\\u1F2B':'\\u1F23','\\u1F2C':'\\u1F24','\\u1F2D':'\\u1F25','\\u1F2E':'\\u1F26','\\u1F2F':'\\u1F27','\\u1F38':'\\u1F30','\\u1F39':'\\u1F31','\\u1F3A':'\\u1F32','\\u1F3B':'\\u1F33','\\u1F3C':'\\u1F34','\\u1F3D':'\\u1F35','\\u1F3E':'\\u1F36','\\u1F3F':'\\u1F37','\\u1F48':'\\u1F40','\\u1F49':'\\u1F41','\\u1F4A':'\\u1F42','\\u1F4B':'\\u1F43','\\u1F4C':'\\u1F44','\\u1F4D':'\\u1F45','\\u1F59':'\\u1F51','\\u1F5B':'\\u1F53','\\u1F5D':'\\u1F55','\\u1F5F':'\\u1F57','\\u1F68':'\\u1F60','\\u1F69':'\\u1F61','\\u1F6A':'\\u1F62','\\u1F6B':'\\u1F63','\\u1F6C':'\\u1F64','\\u1F6D':'\\u1F65','\\u1F6E':'\\u1F66','\\u1F6F':'\\u1F67','\\u1FB8':'\\u1FB0','\\u1FB9':'\\u1FB1','\\u1FBA':'\\u1F70','\\u1FBB':'\\u1F71','\\u1FBE':'\\u03B9','\\u1FC8':'\\u1F72','\\u1FC9':'\\u1F73','\\u1FCA':'\\u1F74','\\u1FCB':'\\u1F75','\\u1FD8':'\\u1FD0','\\u1FD9':'\\u1FD1','\\u1FDA':'\\u1F76','\\u1FDB':'\\u1F77','\\u1FE8':'\\u1FE0','\\u1FE9':'\\u1FE1','\\u1FEA':'\\u1F7A','\\u1FEB':'\\u1F7B','\\u1FEC':'\\u1FE5','\\u1FF8':'\\u1F78','\\u1FF9':'\\u1F79','\\u1FFA':'\\u1F7C','\\u1FFB':'\\u1F7D','\\u2126':'\\u03C9','\\u212A':'k','\\u212B':'\\xE5','\\u2132':'\\u214E','\\u2160':'\\u2170','\\u2161':'\\u2171','\\u2162':'\\u2172','\\u2163':'\\u2173','\\u2164':'\\u2174','\\u2165':'\\u2175','\\u2166':'\\u2176','\\u2167':'\\u2177','\\u2168':'\\u2178','\\u2169':'\\u2179','\\u216A':'\\u217A','\\u216B':'\\u217B','\\u216C':'\\u217C','\\u216D':'\\u217D','\\u216E':'\\u217E','\\u216F':'\\u217F','\\u2183':'\\u2184','\\u24B6':'\\u24D0','\\u24B7':'\\u24D1','\\u24B8':'\\u24D2','\\u24B9':'\\u24D3','\\u24BA':'\\u24D4','\\u24BB':'\\u24D5','\\u24BC':'\\u24D6','\\u24BD':'\\u24D7','\\u24BE':'\\u24D8','\\u24BF':'\\u24D9','\\u24C0':'\\u24DA','\\u24C1':'\\u24DB','\\u24C2':'\\u24DC','\\u24C3':'\\u24DD','\\u24C4':'\\u24DE','\\u24C5':'\\u24DF','\\u24C6':'\\u24E0','\\u24C7':'\\u24E1','\\u24C8':'\\u24E2','\\u24C9':'\\u24E3','\\u24CA':'\\u24E4','\\u24CB':'\\u24E5','\\u24CC':'\\u24E6','\\u24CD':'\\u24E7','\\u24CE':'\\u24E8','\\u24CF':'\\u24E9','\\u2C00':'\\u2C30','\\u2C01':'\\u2C31','\\u2C02':'\\u2C32','\\u2C03':'\\u2C33','\\u2C04':'\\u2C34','\\u2C05':'\\u2C35','\\u2C06':'\\u2C36','\\u2C07':'\\u2C37','\\u2C08':'\\u2C38','\\u2C09':'\\u2C39','\\u2C0A':'\\u2C3A','\\u2C0B':'\\u2C3B','\\u2C0C':'\\u2C3C','\\u2C0D':'\\u2C3D','\\u2C0E':'\\u2C3E','\\u2C0F':'\\u2C3F','\\u2C10':'\\u2C40','\\u2C11':'\\u2C41','\\u2C12':'\\u2C42','\\u2C13':'\\u2C43','\\u2C14':'\\u2C44','\\u2C15':'\\u2C45','\\u2C16':'\\u2C46','\\u2C17':'\\u2C47','\\u2C18':'\\u2C48','\\u2C19':'\\u2C49','\\u2C1A':'\\u2C4A','\\u2C1B':'\\u2C4B','\\u2C1C':'\\u2C4C','\\u2C1D':'\\u2C4D','\\u2C1E':'\\u2C4E','\\u2C1F':'\\u2C4F','\\u2C20':'\\u2C50','\\u2C21':'\\u2C51','\\u2C22':'\\u2C52','\\u2C23':'\\u2C53','\\u2C24':'\\u2C54','\\u2C25':'\\u2C55','\\u2C26':'\\u2C56','\\u2C27':'\\u2C57','\\u2C28':'\\u2C58','\\u2C29':'\\u2C59','\\u2C2A':'\\u2C5A','\\u2C2B':'\\u2C5B','\\u2C2C':'\\u2C5C','\\u2C2D':'\\u2C5D','\\u2C2E':'\\u2C5E','\\u2C60':'\\u2C61','\\u2C62':'\\u026B','\\u2C63':'\\u1D7D','\\u2C64':'\\u027D','\\u2C67':'\\u2C68','\\u2C69':'\\u2C6A','\\u2C6B':'\\u2C6C','\\u2C6D':'\\u0251','\\u2C6E':'\\u0271','\\u2C6F':'\\u0250','\\u2C70':'\\u0252','\\u2C72':'\\u2C73','\\u2C75':'\\u2C76','\\u2C7E':'\\u023F','\\u2C7F':'\\u0240','\\u2C80':'\\u2C81','\\u2C82':'\\u2C83','\\u2C84':'\\u2C85','\\u2C86':'\\u2C87','\\u2C88':'\\u2C89','\\u2C8A':'\\u2C8B','\\u2C8C':'\\u2C8D','\\u2C8E':'\\u2C8F','\\u2C90':'\\u2C91','\\u2C92':'\\u2C93','\\u2C94':'\\u2C95','\\u2C96':'\\u2C97','\\u2C98':'\\u2C99','\\u2C9A':'\\u2C9B','\\u2C9C':'\\u2C9D','\\u2C9E':'\\u2C9F','\\u2CA0':'\\u2CA1','\\u2CA2':'\\u2CA3','\\u2CA4':'\\u2CA5','\\u2CA6':'\\u2CA7','\\u2CA8':'\\u2CA9','\\u2CAA':'\\u2CAB','\\u2CAC':'\\u2CAD','\\u2CAE':'\\u2CAF','\\u2CB0':'\\u2CB1','\\u2CB2':'\\u2CB3','\\u2CB4':'\\u2CB5','\\u2CB6':'\\u2CB7','\\u2CB8':'\\u2CB9','\\u2CBA':'\\u2CBB','\\u2CBC':'\\u2CBD','\\u2CBE':'\\u2CBF','\\u2CC0':'\\u2CC1','\\u2CC2':'\\u2CC3','\\u2CC4':'\\u2CC5','\\u2CC6':'\\u2CC7','\\u2CC8':'\\u2CC9','\\u2CCA':'\\u2CCB','\\u2CCC':'\\u2CCD','\\u2CCE':'\\u2CCF','\\u2CD0':'\\u2CD1','\\u2CD2':'\\u2CD3','\\u2CD4':'\\u2CD5','\\u2CD6':'\\u2CD7','\\u2CD8':'\\u2CD9','\\u2CDA':'\\u2CDB','\\u2CDC':'\\u2CDD','\\u2CDE':'\\u2CDF','\\u2CE0':'\\u2CE1','\\u2CE2':'\\u2CE3','\\u2CEB':'\\u2CEC','\\u2CED':'\\u2CEE','\\u2CF2':'\\u2CF3','\\uA640':'\\uA641','\\uA642':'\\uA643','\\uA644':'\\uA645','\\uA646':'\\uA647','\\uA648':'\\uA649','\\uA64A':'\\uA64B','\\uA64C':'\\uA64D','\\uA64E':'\\uA64F','\\uA650':'\\uA651','\\uA652':'\\uA653','\\uA654':'\\uA655','\\uA656':'\\uA657','\\uA658':'\\uA659','\\uA65A':'\\uA65B','\\uA65C':'\\uA65D','\\uA65E':'\\uA65F','\\uA660':'\\uA661','\\uA662':'\\uA663','\\uA664':'\\uA665','\\uA666':'\\uA667','\\uA668':'\\uA669','\\uA66A':'\\uA66B','\\uA66C':'\\uA66D','\\uA680':'\\uA681','\\uA682':'\\uA683','\\uA684':'\\uA685','\\uA686':'\\uA687','\\uA688':'\\uA689','\\uA68A':'\\uA68B','\\uA68C':'\\uA68D','\\uA68E':'\\uA68F','\\uA690':'\\uA691','\\uA692':'\\uA693','\\uA694':'\\uA695','\\uA696':'\\uA697','\\uA698':'\\uA699','\\uA69A':'\\uA69B','\\uA722':'\\uA723','\\uA724':'\\uA725','\\uA726':'\\uA727','\\uA728':'\\uA729','\\uA72A':'\\uA72B','\\uA72C':'\\uA72D','\\uA72E':'\\uA72F','\\uA732':'\\uA733','\\uA734':'\\uA735','\\uA736':'\\uA737','\\uA738':'\\uA739','\\uA73A':'\\uA73B','\\uA73C':'\\uA73D','\\uA73E':'\\uA73F','\\uA740':'\\uA741','\\uA742':'\\uA743','\\uA744':'\\uA745','\\uA746':'\\uA747','\\uA748':'\\uA749','\\uA74A':'\\uA74B','\\uA74C':'\\uA74D','\\uA74E':'\\uA74F','\\uA750':'\\uA751','\\uA752':'\\uA753','\\uA754':'\\uA755','\\uA756':'\\uA757','\\uA758':'\\uA759','\\uA75A':'\\uA75B','\\uA75C':'\\uA75D','\\uA75E':'\\uA75F','\\uA760':'\\uA761','\\uA762':'\\uA763','\\uA764':'\\uA765','\\uA766':'\\uA767','\\uA768':'\\uA769','\\uA76A':'\\uA76B','\\uA76C':'\\uA76D','\\uA76E':'\\uA76F','\\uA779':'\\uA77A','\\uA77B':'\\uA77C','\\uA77D':'\\u1D79','\\uA77E':'\\uA77F','\\uA780':'\\uA781','\\uA782':'\\uA783','\\uA784':'\\uA785','\\uA786':'\\uA787','\\uA78B':'\\uA78C','\\uA78D':'\\u0265','\\uA790':'\\uA791','\\uA792':'\\uA793','\\uA796':'\\uA797','\\uA798':'\\uA799','\\uA79A':'\\uA79B','\\uA79C':'\\uA79D','\\uA79E':'\\uA79F','\\uA7A0':'\\uA7A1','\\uA7A2':'\\uA7A3','\\uA7A4':'\\uA7A5','\\uA7A6':'\\uA7A7','\\uA7A8':'\\uA7A9','\\uA7AA':'\\u0266','\\uA7AB':'\\u025C','\\uA7AC':'\\u0261','\\uA7AD':'\\u026C','\\uA7B0':'\\u029E','\\uA7B1':'\\u0287','\\uFF21':'\\uFF41','\\uFF22':'\\uFF42','\\uFF23':'\\uFF43','\\uFF24':'\\uFF44','\\uFF25':'\\uFF45','\\uFF26':'\\uFF46','\\uFF27':'\\uFF47','\\uFF28':'\\uFF48','\\uFF29':'\\uFF49','\\uFF2A':'\\uFF4A','\\uFF2B':'\\uFF4B','\\uFF2C':'\\uFF4C','\\uFF2D':'\\uFF4D','\\uFF2E':'\\uFF4E','\\uFF2F':'\\uFF4F','\\uFF30':'\\uFF50','\\uFF31':'\\uFF51','\\uFF32':'\\uFF52','\\uFF33':'\\uFF53','\\uFF34':'\\uFF54','\\uFF35':'\\uFF55','\\uFF36':'\\uFF56','\\uFF37':'\\uFF57','\\uFF38':'\\uFF58','\\uFF39':'\\uFF59','\\uFF3A':'\\uFF5A','\\uD801\\uDC00':'\\uD801\\uDC28','\\uD801\\uDC01':'\\uD801\\uDC29','\\uD801\\uDC02':'\\uD801\\uDC2A','\\uD801\\uDC03':'\\uD801\\uDC2B','\\uD801\\uDC04':'\\uD801\\uDC2C','\\uD801\\uDC05':'\\uD801\\uDC2D','\\uD801\\uDC06':'\\uD801\\uDC2E','\\uD801\\uDC07':'\\uD801\\uDC2F','\\uD801\\uDC08':'\\uD801\\uDC30','\\uD801\\uDC09':'\\uD801\\uDC31','\\uD801\\uDC0A':'\\uD801\\uDC32','\\uD801\\uDC0B':'\\uD801\\uDC33','\\uD801\\uDC0C':'\\uD801\\uDC34','\\uD801\\uDC0D':'\\uD801\\uDC35','\\uD801\\uDC0E':'\\uD801\\uDC36','\\uD801\\uDC0F':'\\uD801\\uDC37','\\uD801\\uDC10':'\\uD801\\uDC38','\\uD801\\uDC11':'\\uD801\\uDC39','\\uD801\\uDC12':'\\uD801\\uDC3A','\\uD801\\uDC13':'\\uD801\\uDC3B','\\uD801\\uDC14':'\\uD801\\uDC3C','\\uD801\\uDC15':'\\uD801\\uDC3D','\\uD801\\uDC16':'\\uD801\\uDC3E','\\uD801\\uDC17':'\\uD801\\uDC3F','\\uD801\\uDC18':'\\uD801\\uDC40','\\uD801\\uDC19':'\\uD801\\uDC41','\\uD801\\uDC1A':'\\uD801\\uDC42','\\uD801\\uDC1B':'\\uD801\\uDC43','\\uD801\\uDC1C':'\\uD801\\uDC44','\\uD801\\uDC1D':'\\uD801\\uDC45','\\uD801\\uDC1E':'\\uD801\\uDC46','\\uD801\\uDC1F':'\\uD801\\uDC47','\\uD801\\uDC20':'\\uD801\\uDC48','\\uD801\\uDC21':'\\uD801\\uDC49','\\uD801\\uDC22':'\\uD801\\uDC4A','\\uD801\\uDC23':'\\uD801\\uDC4B','\\uD801\\uDC24':'\\uD801\\uDC4C','\\uD801\\uDC25':'\\uD801\\uDC4D','\\uD801\\uDC26':'\\uD801\\uDC4E','\\uD801\\uDC27':'\\uD801\\uDC4F','\\uD806\\uDCA0':'\\uD806\\uDCC0','\\uD806\\uDCA1':'\\uD806\\uDCC1','\\uD806\\uDCA2':'\\uD806\\uDCC2','\\uD806\\uDCA3':'\\uD806\\uDCC3','\\uD806\\uDCA4':'\\uD806\\uDCC4','\\uD806\\uDCA5':'\\uD806\\uDCC5','\\uD806\\uDCA6':'\\uD806\\uDCC6','\\uD806\\uDCA7':'\\uD806\\uDCC7','\\uD806\\uDCA8':'\\uD806\\uDCC8','\\uD806\\uDCA9':'\\uD806\\uDCC9','\\uD806\\uDCAA':'\\uD806\\uDCCA','\\uD806\\uDCAB':'\\uD806\\uDCCB','\\uD806\\uDCAC':'\\uD806\\uDCCC','\\uD806\\uDCAD':'\\uD806\\uDCCD','\\uD806\\uDCAE':'\\uD806\\uDCCE','\\uD806\\uDCAF':'\\uD806\\uDCCF','\\uD806\\uDCB0':'\\uD806\\uDCD0','\\uD806\\uDCB1':'\\uD806\\uDCD1','\\uD806\\uDCB2':'\\uD806\\uDCD2','\\uD806\\uDCB3':'\\uD806\\uDCD3','\\uD806\\uDCB4':'\\uD806\\uDCD4','\\uD806\\uDCB5':'\\uD806\\uDCD5','\\uD806\\uDCB6':'\\uD806\\uDCD6','\\uD806\\uDCB7':'\\uD806\\uDCD7','\\uD806\\uDCB8':'\\uD806\\uDCD8','\\uD806\\uDCB9':'\\uD806\\uDCD9','\\uD806\\uDCBA':'\\uD806\\uDCDA','\\uD806\\uDCBB':'\\uD806\\uDCDB','\\uD806\\uDCBC':'\\uD806\\uDCDC','\\uD806\\uDCBD':'\\uD806\\uDCDD','\\uD806\\uDCBE':'\\uD806\\uDCDE','\\uD806\\uDCBF':'\\uD806\\uDCDF','\\xDF':'ss','\\u0130':'i\\u0307','\\u0149':'\\u02BCn','\\u01F0':'j\\u030C','\\u0390':'\\u03B9\\u0308\\u0301','\\u03B0':'\\u03C5\\u0308\\u0301','\\u0587':'\\u0565\\u0582','\\u1E96':'h\\u0331','\\u1E97':'t\\u0308','\\u1E98':'w\\u030A','\\u1E99':'y\\u030A','\\u1E9A':'a\\u02BE','\\u1E9E':'ss','\\u1F50':'\\u03C5\\u0313','\\u1F52':'\\u03C5\\u0313\\u0300','\\u1F54':'\\u03C5\\u0313\\u0301','\\u1F56':'\\u03C5\\u0313\\u0342','\\u1F80':'\\u1F00\\u03B9','\\u1F81':'\\u1F01\\u03B9','\\u1F82':'\\u1F02\\u03B9','\\u1F83':'\\u1F03\\u03B9','\\u1F84':'\\u1F04\\u03B9','\\u1F85':'\\u1F05\\u03B9','\\u1F86':'\\u1F06\\u03B9','\\u1F87':'\\u1F07\\u03B9','\\u1F88':'\\u1F00\\u03B9','\\u1F89':'\\u1F01\\u03B9','\\u1F8A':'\\u1F02\\u03B9','\\u1F8B':'\\u1F03\\u03B9','\\u1F8C':'\\u1F04\\u03B9','\\u1F8D':'\\u1F05\\u03B9','\\u1F8E':'\\u1F06\\u03B9','\\u1F8F':'\\u1F07\\u03B9','\\u1F90':'\\u1F20\\u03B9','\\u1F91':'\\u1F21\\u03B9','\\u1F92':'\\u1F22\\u03B9','\\u1F93':'\\u1F23\\u03B9','\\u1F94':'\\u1F24\\u03B9','\\u1F95':'\\u1F25\\u03B9','\\u1F96':'\\u1F26\\u03B9','\\u1F97':'\\u1F27\\u03B9','\\u1F98':'\\u1F20\\u03B9','\\u1F99':'\\u1F21\\u03B9','\\u1F9A':'\\u1F22\\u03B9','\\u1F9B':'\\u1F23\\u03B9','\\u1F9C':'\\u1F24\\u03B9','\\u1F9D':'\\u1F25\\u03B9','\\u1F9E':'\\u1F26\\u03B9','\\u1F9F':'\\u1F27\\u03B9','\\u1FA0':'\\u1F60\\u03B9','\\u1FA1':'\\u1F61\\u03B9','\\u1FA2':'\\u1F62\\u03B9','\\u1FA3':'\\u1F63\\u03B9','\\u1FA4':'\\u1F64\\u03B9','\\u1FA5':'\\u1F65\\u03B9','\\u1FA6':'\\u1F66\\u03B9','\\u1FA7':'\\u1F67\\u03B9','\\u1FA8':'\\u1F60\\u03B9','\\u1FA9':'\\u1F61\\u03B9','\\u1FAA':'\\u1F62\\u03B9','\\u1FAB':'\\u1F63\\u03B9','\\u1FAC':'\\u1F64\\u03B9','\\u1FAD':'\\u1F65\\u03B9','\\u1FAE':'\\u1F66\\u03B9','\\u1FAF':'\\u1F67\\u03B9','\\u1FB2':'\\u1F70\\u03B9','\\u1FB3':'\\u03B1\\u03B9','\\u1FB4':'\\u03AC\\u03B9','\\u1FB6':'\\u03B1\\u0342','\\u1FB7':'\\u03B1\\u0342\\u03B9','\\u1FBC':'\\u03B1\\u03B9','\\u1FC2':'\\u1F74\\u03B9','\\u1FC3':'\\u03B7\\u03B9','\\u1FC4':'\\u03AE\\u03B9','\\u1FC6':'\\u03B7\\u0342','\\u1FC7':'\\u03B7\\u0342\\u03B9','\\u1FCC':'\\u03B7\\u03B9','\\u1FD2':'\\u03B9\\u0308\\u0300','\\u1FD3':'\\u03B9\\u0308\\u0301','\\u1FD6':'\\u03B9\\u0342','\\u1FD7':'\\u03B9\\u0308\\u0342','\\u1FE2':'\\u03C5\\u0308\\u0300','\\u1FE3':'\\u03C5\\u0308\\u0301','\\u1FE4':'\\u03C1\\u0313','\\u1FE6':'\\u03C5\\u0342','\\u1FE7':'\\u03C5\\u0308\\u0342','\\u1FF2':'\\u1F7C\\u03B9','\\u1FF3':'\\u03C9\\u03B9','\\u1FF4':'\\u03CE\\u03B9','\\u1FF6':'\\u03C9\\u0342','\\u1FF7':'\\u03C9\\u0342\\u03B9','\\u1FFC':'\\u03C9\\u03B9','\\uFB00':'ff','\\uFB01':'fi','\\uFB02':'fl','\\uFB03':'ffi','\\uFB04':'ffl','\\uFB05':'st','\\uFB06':'st','\\uFB13':'\\u0574\\u0576','\\uFB14':'\\u0574\\u0565','\\uFB15':'\\u0574\\u056B','\\uFB16':'\\u057E\\u0576','\\uFB17':'\\u0574\\u056D'};\n\n// Normalize reference label: collapse internal whitespace\n// to single space, remove leading/trailing whitespace, case fold.\nmodule.exports = function(string) {\n    return string.slice(1, string.length - 1).trim().replace(regex, function($0) {\n        // Note: there is no need to check `hasOwnProperty($0)` here.\n        // If character not found in lookup table, it must be whitespace.\n        return map[$0] || ' ';\n    });\n};\n\n},{}],125:[function(require,module,exports){\n\"use strict\";\n\nvar escapeXml = require('./common').escapeXml;\n\n// Helper function to produce an XML tag.\nvar tag = function(name, attrs, selfclosing) {\n    var result = '<' + name;\n    if (attrs && attrs.length > 0) {\n        var i = 0;\n        var attrib;\n        while ((attrib = attrs[i]) !== undefined) {\n            result += ' ' + attrib[0] + '=\"' + attrib[1] + '\"';\n            i++;\n        }\n    }\n    if (selfclosing) {\n        result += ' /';\n    }\n\n    result += '>';\n    return result;\n};\n\nvar reXMLTag = /\\<[^>]*\\>/;\n\nvar toTagName = function(s) {\n    return s.replace(/([a-z])([A-Z])/g, \"$1_$2\").toLowerCase();\n};\n\nvar renderNodes = function(block) {\n\n    var attrs;\n    var tagname;\n    var walker = block.walker();\n    var event, node, entering;\n    var buffer = \"\";\n    var lastOut = \"\\n\";\n    var disableTags = 0;\n    var indentLevel = 0;\n    var indent = '  ';\n    var unescapedContents;\n    var container;\n    var selfClosing;\n    var nodetype;\n\n    var out = function(s) {\n        if (disableTags > 0) {\n            buffer += s.replace(reXMLTag, '');\n        } else {\n            buffer += s;\n        }\n        lastOut = s;\n    };\n    var esc = this.escape;\n    var cr = function() {\n        if (lastOut !== '\\n') {\n            buffer += '\\n';\n            lastOut = '\\n';\n            for (var i = indentLevel; i--;) {\n                buffer += indent;\n            }\n        }\n    };\n\n    var options = this.options;\n\n    if (options.time) { console.time(\"rendering\"); }\n\n    buffer += '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n';\n    buffer += '<!DOCTYPE CommonMark SYSTEM \"CommonMark.dtd\">\\n';\n\n    while ((event = walker.next())) {\n        entering = event.entering;\n        node = event.node;\n        nodetype = node.type;\n\n        container = node.isContainer;\n        selfClosing = nodetype === 'HorizontalRule' || nodetype === 'Hardbreak' ||\n            nodetype === 'Softbreak' || nodetype === 'Image';\n        unescapedContents = nodetype === 'Html' || nodetype === 'HtmlInline';\n        tagname = toTagName(nodetype);\n\n        if (entering) {\n\n            attrs = [];\n\n            switch (nodetype) {\n            case 'List':\n                if (node.listType !== null) {\n                    attrs.push(['type', node.listType.toLowerCase()]);\n                }\n                if (node.listStart !== null) {\n                    attrs.push(['start', String(node.listStart)]);\n                }\n                if (node.listTight !== null) {\n                    attrs.push(['tight', (node.listTight ? 'true' : 'false')]);\n                }\n                var delim = node.listDelimiter;\n                if (delim !== null) {\n                    var delimword = '';\n                    if (delim === '.') {\n                        delimword = 'period';\n                    } else {\n                        delimword = 'paren';\n                    }\n                    attrs.push(['delimiter', delimword]);\n                }\n                break;\n            case 'CodeBlock':\n                if (node.info) {\n                    attrs.push(['info', node.info]);\n                }\n                break;\n            case 'Header':\n                attrs.push(['level', String(node.level)]);\n                break;\n            case 'Link':\n            case 'Image':\n                attrs.push(['destination', node.destination]);\n                attrs.push(['title', node.title]);\n                break;\n            default:\n                break;\n            }\n            if (options.sourcepos) {\n                var pos = node.sourcepos;\n                if (pos) {\n                    attrs.push(['sourcepos', String(pos[0][0]) + ':' +\n                                String(pos[0][1]) + '-' + String(pos[1][0]) + ':' +\n                                String(pos[1][1])]);\n                }\n            }\n\n            cr();\n            out(tag(tagname, attrs, selfClosing));\n            if (container) {\n                indentLevel += 1;\n            } else if (!container && !selfClosing) {\n                var lit = node.literal;\n                if (lit) {\n                    out(unescapedContents ? lit : esc(lit));\n                }\n                out(tag('/' + tagname));\n            }\n        } else {\n            indentLevel -= 1;\n            cr();\n            out(tag('/' + tagname));\n        }\n\n\n    }\n    if (options.time) { console.timeEnd(\"rendering\"); }\n    buffer += '\\n';\n    return buffer;\n};\n\n// The XmlRenderer object.\nfunction XmlRenderer(options){\n    return {\n        // default options:\n        softbreak: '\\n', // by default, soft breaks are rendered as newlines in HTML\n        // set to \"<br />\" to make them hard breaks\n        // set to \" \" if you want to ignore line wrapping in source\n        escape: escapeXml,\n        options: options || {},\n        render: renderNodes\n    };\n}\n\nmodule.exports = XmlRenderer;\n\n},{\"./common\":115}],126:[function(require,module,exports){\n/*!\n * content-type\n * Copyright(c) 2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n/**\n * RegExp to match *( \";\" parameter ) in RFC 7231 sec 3.1.1.1\n *\n * parameter     = token \"=\" ( token / quoted-string )\n * token         = 1*tchar\n * tchar         = \"!\" / \"#\" / \"$\" / \"%\" / \"&\" / \"'\" / \"*\"\n *               / \"+\" / \"-\" / \".\" / \"^\" / \"_\" / \"`\" / \"|\" / \"~\"\n *               / DIGIT / ALPHA\n *               ; any VCHAR, except delimiters\n * quoted-string = DQUOTE *( qdtext / quoted-pair ) DQUOTE\n * qdtext        = HTAB / SP / %x21 / %x23-5B / %x5D-7E / obs-text\n * obs-text      = %x80-FF\n * quoted-pair   = \"\\\" ( HTAB / SP / VCHAR / obs-text )\n */\nvar paramRegExp = /; *([!#$%&'\\*\\+\\-\\.\\^_`\\|~0-9A-Za-z]+) *= *(\"(?:[\\u000b\\u0020\\u0021\\u0023-\\u005b\\u005d-\\u007e\\u0080-\\u00ff]|\\\\[\\u000b\\u0020-\\u00ff])*\"|[!#$%&'\\*\\+\\-\\.\\^_`\\|~0-9A-Za-z]+) */g\nvar textRegExp = /^[\\u000b\\u0020-\\u007e\\u0080-\\u00ff]+$/\nvar tokenRegExp = /^[!#$%&'\\*\\+\\-\\.\\^_`\\|~0-9A-Za-z]+$/\n\n/**\n * RegExp to match quoted-pair in RFC 7230 sec 3.2.6\n *\n * quoted-pair = \"\\\" ( HTAB / SP / VCHAR / obs-text )\n * obs-text    = %x80-FF\n */\nvar qescRegExp = /\\\\([\\u000b\\u0020-\\u00ff])/g\n\n/**\n * RegExp to match chars that must be quoted-pair in RFC 7230 sec 3.2.6\n */\nvar quoteRegExp = /([\\\\\"])/g\n\n/**\n * RegExp to match type in RFC 6838\n *\n * media-type = type \"/\" subtype\n * type       = token\n * subtype    = token\n */\nvar typeRegExp = /^[!#$%&'\\*\\+\\-\\.\\^_`\\|~0-9A-Za-z]+\\/[!#$%&'\\*\\+\\-\\.\\^_`\\|~0-9A-Za-z]+$/\n\n/**\n * Module exports.\n * @public\n */\n\nexports.format = format\nexports.parse = parse\n\n/**\n * Format object to media type.\n *\n * @param {object} obj\n * @return {string}\n * @public\n */\n\nfunction format(obj) {\n  if (!obj || typeof obj !== 'object') {\n    throw new TypeError('argument obj is required')\n  }\n\n  var parameters = obj.parameters\n  var type = obj.type\n\n  if (!type || !typeRegExp.test(type)) {\n    throw new TypeError('invalid type')\n  }\n\n  var string = type\n\n  // append parameters\n  if (parameters && typeof parameters === 'object') {\n    var param\n    var params = Object.keys(parameters).sort()\n\n    for (var i = 0; i < params.length; i++) {\n      param = params[i]\n\n      if (!tokenRegExp.test(param)) {\n        throw new TypeError('invalid parameter name')\n      }\n\n      string += '; ' + param + '=' + qstring(parameters[param])\n    }\n  }\n\n  return string\n}\n\n/**\n * Parse media type to object.\n *\n * @param {string|object} string\n * @return {Object}\n * @public\n */\n\nfunction parse(string) {\n  if (!string) {\n    throw new TypeError('argument string is required')\n  }\n\n  if (typeof string === 'object') {\n    // support req/res-like objects as argument\n    string = getcontenttype(string)\n\n    if (typeof string !== 'string') {\n      throw new TypeError('content-type header is missing from object');\n    }\n  }\n\n  if (typeof string !== 'string') {\n    throw new TypeError('argument string is required to be a string')\n  }\n\n  var index = string.indexOf(';')\n  var type = index !== -1\n    ? string.substr(0, index).trim()\n    : string.trim()\n\n  if (!typeRegExp.test(type)) {\n    throw new TypeError('invalid media type')\n  }\n\n  var key\n  var match\n  var obj = new ContentType(type.toLowerCase())\n  var value\n\n  paramRegExp.lastIndex = index\n\n  while (match = paramRegExp.exec(string)) {\n    if (match.index !== index) {\n      throw new TypeError('invalid parameter format')\n    }\n\n    index += match[0].length\n    key = match[1].toLowerCase()\n    value = match[2]\n\n    if (value[0] === '\"') {\n      // remove quotes and escapes\n      value = value\n        .substr(1, value.length - 2)\n        .replace(qescRegExp, '$1')\n    }\n\n    obj.parameters[key] = value\n  }\n\n  if (index !== -1 && index !== string.length) {\n    throw new TypeError('invalid parameter format')\n  }\n\n  return obj\n}\n\n/**\n * Get content-type from req/res objects.\n *\n * @param {object}\n * @return {Object}\n * @private\n */\n\nfunction getcontenttype(obj) {\n  if (typeof obj.getHeader === 'function') {\n    // res-like\n    return obj.getHeader('content-type')\n  }\n\n  if (typeof obj.headers === 'object') {\n    // req-like\n    return obj.headers && obj.headers['content-type']\n  }\n}\n\n/**\n * Quote a string if necessary.\n *\n * @param {string} val\n * @return {string}\n * @private\n */\n\nfunction qstring(val) {\n  var str = String(val)\n\n  // no need to quote tokens\n  if (tokenRegExp.test(str)) {\n    return str\n  }\n\n  if (str.length > 0 && !textRegExp.test(str)) {\n    throw new TypeError('invalid parameter value')\n  }\n\n  return '\"' + str.replace(quoteRegExp, '\\\\$1') + '\"'\n}\n\n/**\n * Class to represent a content type.\n * @private\n */\nfunction ContentType(type) {\n  this.parameters = Object.create(null)\n  this.type = type\n}\n\n},{}],127:[function(require,module,exports){\nexports.parse = require(\"./parse\");\nexports.stringify = require(\"./stringify\");\nexports.parseValues = require(\"./parseValues\");\nexports.stringifyValues = require(\"./stringifyValues\");\n\n},{\"./parse\":128,\"./parseValues\":129,\"./stringify\":130,\"./stringifyValues\":131}],128:[function(require,module,exports){\n\"use strict\";\n\nvar Parser = require(\"fastparse\");\n\nfunction unescape(str) {\n\treturn str.replace(/\\\\(.)/g, \"$1\");\n}\n\nfunction commentMatch(match, content) {\n\tthis.selector.nodes.push({\n\t\ttype: \"comment\",\n\t\tcontent: content\n\t});\n}\n\nfunction typeMatch(type) {\n\treturn function(match, name) {\n\t\tthis.selector.nodes.push({\n\t\t\ttype: type,\n\t\t\tname: unescape(name)\n\t\t});\n\t};\n}\n\nfunction pseudoClassStartMatch(match, name) {\n\tvar newToken = {\n\t\ttype: \"pseudo-class\",\n\t\tname: unescape(name),\n\t\tcontent: \"\"\n\t};\n\tthis.selector.nodes.push(newToken);\n\tthis.token = newToken;\n\tthis.brackets = 1;\n\treturn \"inBrackets\";\n}\n\nfunction nestedPseudoClassStartMatch(match, name, after) {\n\tvar newSelector = {\n\t\ttype: \"selector\",\n\t\tnodes: []\n\t};\n\tvar newToken = {\n\t\ttype: \"nested-pseudo-class\",\n\t\tname: unescape(name),\n\t\tnodes: [newSelector]\n\t};\n\tif(after) {\n\t\tnewSelector.before = after;\n\t}\n\tthis.selector.nodes.push(newToken);\n\tthis.stack.push(this.root);\n\tthis.root = newToken;\n\tthis.selector = newSelector;\n}\n\nfunction nestedEnd(match, before) {\n\tif(this.stack.length > 0) {\n\t\tif(before) {\n\t\t\tthis.selector.after = before;\n\t\t}\n\t\tthis.root = this.stack.pop();\n\t\tthis.selector = this.root.nodes[this.root.nodes.length - 1];\n\t} else {\n\t\tthis.selector.nodes.push({\n\t\t\ttype: \"invalid\",\n\t\t\tvalue: match\n\t\t});\n\t}\n}\n\nfunction operatorMatch(match, before, operator, after) {\n\tvar token = {\n\t\ttype: \"operator\",\n\t\toperator: operator\n\t};\n\tif(before) {\n\t\ttoken.before = before;\n\t}\n\tif(after) {\n\t\ttoken.after = after;\n\t}\n\tthis.selector.nodes.push(token);\n}\n\nfunction spacingMatch(match) {\n\tthis.selector.nodes.push({\n\t\ttype: \"spacing\",\n\t\tvalue: match\n\t});\n}\n\nfunction elementMatch(match, namespace, name) {\n\tvar newToken = {\n\t\ttype: \"element\",\n\t\tname: unescape(name)\n\t};\n\n\tif(namespace) {\n\t\tnewToken.namespace = unescape(namespace.substr(0, namespace.length - 1));\n\t}\n\tthis.selector.nodes.push(newToken);\n}\n\nfunction universalMatch(match, namespace) {\n\tvar newToken = {\n\t\ttype: \"universal\"\n\t};\n\tif(namespace) {\n\t\tnewToken.namespace = unescape(namespace.substr(0, namespace.length - 1));\n\t}\n\tthis.selector.nodes.push(newToken);\n}\n\nfunction attributeMatch(match, content) {\n\tthis.selector.nodes.push({\n\t\ttype: \"attribute\",\n\t\tcontent: content\n\t});\n}\n\nfunction invalidMatch(match) {\n\tthis.selector.nodes.push({\n\t\ttype: \"invalid\",\n\t\tvalue: match\n\t});\n}\n\nfunction irrelevantSpacingStartMatch(match) {\n\tthis.selector.before = match;\n}\n\nfunction irrelevantSpacingEndMatch(match) {\n\tthis.selector.after = match;\n}\n\nfunction nextSelectorMatch(match, before, after) {\n\tvar newSelector = {\n\t\ttype: \"selector\",\n\t\tnodes: []\n\t};\n\tif(before) {\n\t\tthis.selector.after = before;\n\t}\n\tif(after) {\n\t\tnewSelector.before = after;\n\t}\n\tthis.root.nodes.push(newSelector);\n\tthis.selector = newSelector;\n}\n\nfunction addToCurrent(match) {\n\tthis.token.content += match;\n}\n\nfunction bracketStart(match) {\n\tthis.token.content += match;\n\tthis.brackets++;\n}\n\nfunction bracketEnd(match) {\n\tif(--this.brackets === 0) {\n\t\treturn \"selector\";\n\t}\n\tthis.token.content += match;\n}\n\nvar parser = new Parser({\n\tselector: {\n\t\t\"/\\\\*([\\\\s\\\\S]*?)\\\\*/\": commentMatch,\n\t\t\"\\\\.((?:\\\\\\\\.|[A-Za-z_\\\\-])(?:\\\\\\\\.|[A-Za-z_\\\\-0-9])*)\": typeMatch(\"class\"),\n\t\t\"#((?:\\\\\\\\.|[A-Za-z_\\\\-])(?:\\\\\\\\.|[A-Za-z_\\\\-0-9])*)\": typeMatch(\"id\"),\n\t\t\":(not|matches|has|local|global)\\\\((\\\\s*)\": nestedPseudoClassStartMatch,\n\t\t\":((?:\\\\\\\\.|[A-Za-z_\\\\-0-9])+)\\\\(\": pseudoClassStartMatch,\n\t\t\":((?:\\\\\\\\.|[A-Za-z_\\\\-0-9])+)\": typeMatch(\"pseudo-class\"),\n\t\t\"::((?:\\\\\\\\.|[A-Za-z_\\\\-0-9])+)\": typeMatch(\"pseudo-element\"),\n\t\t\"(\\\\*\\\\|)((?:\\\\\\\\.|[A-Za-z_\\\\-0-9])+)\": elementMatch,\n\t\t\"(\\\\*\\\\|)\\\\*\": universalMatch,\n\t\t\"((?:\\\\\\\\.|[A-Za-z_\\\\-0-9])*\\\\|)?\\\\*\": universalMatch,\n\t\t\"((?:\\\\\\\\.|[A-Za-z_\\\\-0-9])*\\\\|)?((?:\\\\\\\\.|[A-Za-z_\\\\-])(?:\\\\\\\\.|[A-Za-z_\\\\-0-9])*)\": elementMatch,\n\t\t\"\\\\[([^\\\\]]+)\\\\]\": attributeMatch,\n\t\t\"(\\\\s*)\\\\)\": nestedEnd,\n\t\t\"(\\\\s*)((?:\\\\|\\\\|)|(?:>>)|[>+~])(\\\\s*)\": operatorMatch,\n\t\t\"(\\\\s*),(\\\\s*)\": nextSelectorMatch,\n\t\t\"\\\\s+$\": irrelevantSpacingEndMatch,\n\t\t\"^\\\\s+\": irrelevantSpacingStartMatch,\n\t\t\"\\\\s+\": spacingMatch,\n\t\t\".\": invalidMatch\n\t},\n\tinBrackets: {\n\t\t\"/\\\\*[\\\\s\\\\S]*?\\\\*/\": addToCurrent,\n\t\t\"\\\"([^\\\\\\\\\\\"]|\\\\\\\\.)*\\\"\": addToCurrent,\n\t\t\"'([^\\\\\\\\']|\\\\\\\\.)*'\": addToCurrent,\n\t\t\"[^()'\\\"/]+\": addToCurrent,\n\t\t\"\\\\(\": bracketStart,\n\t\t\"\\\\)\": bracketEnd,\n\t\t\".\": addToCurrent\n\t}\n});\n\nfunction parse(str) {\n\tvar selectorNode = {\n\t\ttype: \"selector\",\n\t\tnodes: []\n\t};\n\tvar rootNode = {\n\t\ttype: \"selectors\",\n\t\tnodes: [\n\t\t\tselectorNode\n\t\t]\n\t};\n\tparser.parse(\"selector\", str, {\n\t\tstack: [],\n\t\troot: rootNode,\n\t\tselector: selectorNode\n\t});\n\treturn rootNode;\n}\n\nmodule.exports = parse;\n\n},{\"fastparse\":133}],129:[function(require,module,exports){\n\"use strict\";\n\nvar Parser = require(\"fastparse\");\n\nfunction commentMatch(match, content) {\n\tthis.value.nodes.push({\n\t\ttype: \"comment\",\n\t\tcontent: content\n\t});\n}\n\nfunction spacingMatch(match) {\n\tvar item = this.value.nodes[this.value.nodes.length - 1];\n\titem.after = (item.after || \"\") + match;\n}\n\nfunction initialSpacingMatch(match) {\n\tthis.value.before = match;\n}\n\nfunction endSpacingMatch(match) {\n\tthis.value.after = match;\n}\n\nfunction unescapeString(content) {\n\treturn content.replace(/\\\\([a-fA-F0-9]{2,5}|.)/g, function(escaped) {\n\t\tif(escaped.length > 2) {\n\t\t\tvar C = parseInt(escaped.substr(1), 16);\n\t\t\tif(C < 0x10000) {\n\t\t\t\treturn String.fromCharCode(C);\n\t\t\t} else {\n\t\t\t\treturn String.fromCharCode(Math.floor((C - 0x10000) / 0x400) + 0xD800) +\n\t\t\t\t\tString.fromCharCode((C - 0x10000) % 0x400 + 0xDC00);\n\t\t\t}\n\t\t} else {\n\t\t\treturn escaped.substr(1);\n\t\t}\n\t});\n}\n\nfunction stringMatch(match, content) {\n\tvar value = unescapeString(content);\n\tthis.value.nodes.push({\n\t\ttype: \"string\",\n\t\tvalue: value,\n\t\tstringType: match[0]\n\t});\n}\n\nfunction commaMatch(match, spacing) {\n\tvar newValue = {\n\t\ttype: \"value\",\n\t\tnodes: []\n\t};\n\tif(spacing) {\n\t\tnewValue.before = spacing;\n\t}\n\tthis.root.nodes.push(newValue);\n\tthis.value = newValue;\n}\n\nfunction itemMatch(match) {\n\tthis.value.nodes.push({\n\t\ttype: \"item\",\n\t\tname: match\n\t});\n}\n\nfunction nestedItemMatch(match, name, spacing) {\n\tthis.stack.push(this.root);\n\tthis.root = {\n\t\ttype: \"nested-item\",\n\t\tname: name,\n\t\tnodes: [\n\t\t\t{ type: \"value\", nodes: [] }\n\t\t]\n\t};\n\tif(spacing) {\n\t\tthis.root.nodes[0].before = spacing;\n\t}\n\tthis.value.nodes.push(this.root);\n\tthis.value = this.root.nodes[0];\n}\n\nfunction nestedItemEndMatch(match, spacing, remaining) {\n\tif(this.stack.length === 0) {\n\t\tif(spacing) {\n\t\t\tvar item = this.value.nodes[this.value.nodes.length - 1];\n\t\t\titem.after = (item.after || \"\") + spacing;\n\t\t}\n\t\tthis.value.nodes.push({\n\t\t\ttype: \"invalid\",\n\t\t\tvalue: remaining\n\t\t});\n\t} else {\n\t\tif(spacing) {\n\t\t\tthis.value.after = spacing;\n\t\t}\n\t\tthis.root = this.stack.pop();\n\t\tthis.value = this.root.nodes[this.root.nodes.length - 1];\n\t}\n}\n\nfunction urlMatch(match, innerSpacingBefore, content, innerSpacingAfter) {\n\tvar item = {\n\t\ttype: \"url\"\n\t};\n\tif(innerSpacingBefore) {\n\t\titem.innerSpacingBefore = innerSpacingBefore;\n\t}\n\tif(innerSpacingAfter) {\n\t\titem.innerSpacingAfter = innerSpacingAfter;\n\t}\n\tswitch(content[0]) {\n\t\tcase \"\\\"\":\n\t\t\titem.stringType = \"\\\"\";\n\t\t\titem.url = unescapeString(content.substr(1, content.length - 2));\n\t\t\tbreak;\n\t\tcase \"'\":\n\t\t\titem.stringType = \"'\";\n\t\t\titem.url = unescapeString(content.substr(1, content.length - 2));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\titem.url = unescapeString(content);\n\t\t\tbreak;\n\t}\n\tthis.value.nodes.push(item);\n}\n\nvar parser = new Parser({\n\tdecl: {\n\t\t\"^\\\\s+\": initialSpacingMatch,\n\t\t\"/\\\\*([\\\\s\\\\S]*?)\\\\*/\": commentMatch,\n\t\t\"\\\"((?:[^\\\\\\\\\\\"]|\\\\\\\\.)*)\\\"\": stringMatch,\n\t\t\"'((?:[^\\\\\\\\']|\\\\\\\\.)*)'\": stringMatch,\n\t\t\"url\\\\((\\\\s*)(\\\"(?:[^\\\\\\\\\\\"]|\\\\\\\\.)*\\\")(\\\\s*)\\\\)\": urlMatch,\n\t\t\"url\\\\((\\\\s*)('(?:[^\\\\\\\\']|\\\\\\\\.)*')(\\\\s*)\\\\)\": urlMatch,\n\t\t\"url\\\\((\\\\s*)((?:[^\\\\\\\\)'\\\"]|\\\\\\\\.)*)(\\\\s*)\\\\)\": urlMatch,\n\t\t\"([\\\\w\\-]+)\\\\((\\\\s*)\": nestedItemMatch,\n\t\t\"(\\\\s*)(\\\\))\": nestedItemEndMatch,\n\t\t\",(\\\\s*)\": commaMatch,\n\t\t\"\\\\s+$\": endSpacingMatch,\n\t\t\"\\\\s+\": spacingMatch,\n\t\t\"[^\\\\s,\\)]+\": itemMatch\n\t}\n});\n\nfunction parseValues(str) {\n\tvar valueNode = {\n\t\ttype: \"value\",\n\t\tnodes: []\n\t};\n\tvar rootNode = {\n\t\ttype: \"values\",\n\t\tnodes: [\n\t\t\tvalueNode\n\t\t]\n\t};\n\tparser.parse(\"decl\", str, {\n\t\tstack: [],\n\t\troot: rootNode,\n\t\tvalue: valueNode\n\t});\n\treturn rootNode;\n}\n\nmodule.exports = parseValues;\n\n},{\"fastparse\":133}],130:[function(require,module,exports){\n\"use strict\";\n\nvar stringify;\n\nfunction escape(str) {\n\tif(str === \"*\") {\n\t\treturn \"*\";\n\t}\n\treturn str.replace(/(^[^A-Za-z_\\\\-]|^\\-\\-|[^A-Za-z_0-9\\\\-])/g, \"\\\\$1\");\n}\n\nfunction stringifyWithoutBeforeAfter(tree) {\n\tswitch(tree.type) {\n\tcase \"selectors\":\n\t\treturn tree.nodes.map(stringify).join(\",\");\n\tcase \"selector\":\n\t\treturn tree.nodes.map(stringify).join(\"\");\n\tcase \"element\":\n\t\treturn (typeof tree.namespace === \"string\" ? escape(tree.namespace) + \"|\" : \"\") + escape(tree.name);\n\tcase \"class\":\n\t\treturn \".\" + escape(tree.name);\n\tcase \"id\":\n\t\treturn \"#\" + escape(tree.name);\n\tcase \"attribute\":\n\t\treturn \"[\" + tree.content + \"]\";\n\tcase \"spacing\":\n\t\treturn tree.value;\n\tcase \"pseudo-class\":\n\t\treturn \":\" + escape(tree.name) + (typeof tree.content === \"string\" ? \"(\" + tree.content + \")\" : \"\");\n\tcase \"nested-pseudo-class\":\n\t\treturn \":\" + escape(tree.name) + \"(\" + tree.nodes.map(stringify).join(\",\") + \")\";\n\tcase \"pseudo-element\":\n\t\treturn \"::\" + escape(tree.name);\n\tcase \"universal\":\n\t\treturn (typeof tree.namespace === \"string\" ? escape(tree.namespace) + \"|\" : \"\") + \"*\";\n\tcase \"operator\":\n\t\treturn tree.operator;\n\tcase \"comment\":\n\t\treturn \"/*\" + tree.content + \"*/\";\n\tcase \"invalid\":\n\t\treturn tree.value;\n\t}\n}\n\n\nstringify = function stringify(tree) {\n\tvar str = stringifyWithoutBeforeAfter(tree);\n\tif(tree.before) {\n\t\tstr = tree.before + str;\n\t}\n\tif(tree.after) {\n\t\tstr = str + tree.after;\n\t}\n\treturn str;\n};\n\nmodule.exports = stringify;\n\n},{}],131:[function(require,module,exports){\n\"use strict\";\n\nvar cssesc = require(\"cssesc\");\n\nvar stringify;\n\nfunction escape(str, stringType) {\n\treturn cssesc(str, {\n\t\tquotes: stringType === \"\\\"\" ? \"double\" : \"single\"\n\t});\n}\n\nfunction stringifyWithoutBeforeAfter(tree) {\n\tswitch(tree.type) {\n\tcase \"values\":\n\t\treturn tree.nodes.map(stringify).join(\",\");\n\tcase \"value\":\n\t\treturn tree.nodes.map(stringify).join(\"\");\n\tcase \"item\":\n\t\treturn tree.name;\n\tcase \"nested-item\":\n\t\treturn tree.name + \"(\" + tree.nodes.map(stringify).join(\",\") + \")\";\n\tcase \"invalid\":\n\t\treturn tree.value;\n\tcase \"comment\":\n\t\treturn \"/*\" + tree.content + \"*/\";\n\tcase \"string\":\n\t\tswitch(tree.stringType) {\n\t\tcase \"'\":\n\t\t\treturn \"'\" + escape(tree.value, \"'\") + \"'\";\n\t\tcase \"\\\"\":\n\t\t\treturn \"\\\"\" + escape(tree.value, \"\\\"\") + \"\\\"\";\n\t\t}\n\t\t/* istanbul ignore next */\n\t\tthrow new Error(\"Invalid stringType\");\n\tcase \"url\":\n\t\tvar start = \"url(\" + (tree.innerSpacingBefore || \"\");\n\t\tvar end = (tree.innerSpacingAfter || \"\") + \")\";\n\t\tswitch(tree.stringType) {\n\t\tcase \"'\":\n\t\t\treturn start + \"'\" + tree.url.replace(/'/g, \"\\\\'\") + \"'\" + end;\n\t\tcase \"\\\"\":\n\t\t\treturn start + \"\\\"\" + tree.url.replace(/\"/g, \"\\\\\\\"\") + \"\\\"\" + end;\n\t\tdefault:\n\t\t\treturn start + tree.url.replace(/(\"|'|\\))/g, \"\\\\$1\") + end;\n\t\t}\n\t}\n}\n\n\nstringify = function stringify(tree) {\n\tvar str = stringifyWithoutBeforeAfter(tree);\n\tif(tree.before) {\n\t\tstr = tree.before + str;\n\t}\n\tif(tree.after) {\n\t\tstr = str + tree.after;\n\t}\n\treturn str;\n};\n\nmodule.exports = stringify;\n\n},{\"cssesc\":132}],132:[function(require,module,exports){\n(function (global){\n/*! http://mths.be/cssesc v0.1.0 by @mathias */\n;(function(root) {\n\n\t// Detect free variables `exports`\n\tvar freeExports = typeof exports == 'object' && exports;\n\n\t// Detect free variable `module`\n\tvar freeModule = typeof module == 'object' && module &&\n\t\tmodule.exports == freeExports && module;\n\n\t// Detect free variable `global`, from Node.js or Browserified code,\n\t// and use it as `root`\n\tvar freeGlobal = typeof global == 'object' && global;\n\tif (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {\n\t\troot = freeGlobal;\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\tvar object = {};\n\tvar hasOwnProperty = object.hasOwnProperty;\n\tvar merge = function(options, defaults) {\n\t\tif (!options) {\n\t\t\treturn defaults;\n\t\t}\n\t\tvar key;\n\t\tvar result = {};\n\t\tfor (key in defaults) {\n\t\t\t// `if (defaults.hasOwnProperty(key) {  }` is not needed here, since\n\t\t\t// only recognized option names are used\n\t\t\tresult[key] = hasOwnProperty.call(options, key)\n\t\t\t\t? options[key]\n\t\t\t\t: defaults[key];\n\t\t}\n\t\treturn result;\n\t};\n\n\t/*--------------------------------------------------------------------------*/\n\n\tvar regexAnySingleEscape = /[\\x20-\\x2C\\x2E\\x2F\\x3B-\\x40\\x5B-\\x5E\\x60\\x7B-\\x7E]/;\n\tvar regexSingleEscape = /[\\x20\\x21\\x23-\\x26\\x28-\\x2C\\x2E\\x2F\\x3B-\\x40\\x5B\\x5D\\x5E\\x60\\x7B-\\x7E]/;\n\tvar regexAlwaysEscape = /['\"\\\\]/;\n\tvar regexExcessiveSpaces = /(^|\\\\+)?(\\\\[A-F0-9]{1,6})\\x20(?![a-fA-F0-9\\x20])/g;\n\n\t// http://mathiasbynens.be/notes/css-escapes#css\n\tvar cssesc = function(string, options) {\n\n\t\t// Handle options\n\t\toptions = merge(options, cssesc.options);\n\t\tif (options.quotes != 'single' && options.quotes != 'double') {\n\t\t\toptions.quotes = 'single';\n\t\t}\n\t\tvar quote = options.quotes == 'double' ? '\"' : '\\'';\n\t\tvar isIdentifier = options.isIdentifier;\n\n\t\tvar firstChar = string.charAt(0);\n\t\tvar output = '';\n\t\tvar counter = 0;\n\t\tvar length = string.length;\n\t\tvar value;\n\t\tvar character;\n\t\tvar codePoint;\n\t\tvar extra; // used for potential low surrogates\n\n\t\twhile (counter < length) {\n\t\t\tcharacter = string.charAt(counter++);\n\t\t\tcodePoint = character.charCodeAt();\n\t\t\t// if its not a printable ASCII character\n\t\t\tif (codePoint < 0x20 || codePoint > 0x7E) {\n\t\t\t\tif (codePoint >= 0xD800 && codePoint <= 0xDBFF && counter < length) {\n\t\t\t\t\t// high surrogate, and there is a next character\n\t\t\t\t\textra = string.charCodeAt(counter++);\n\t\t\t\t\tif ((extra & 0xFC00) == 0xDC00) { // next character is low surrogate\n\t\t\t\t\t\tcodePoint = ((codePoint & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// unmatched surrogate; only append this code unit, in case the next\n\t\t\t\t\t\t// code unit is the high surrogate of a surrogate pair\n\t\t\t\t\t\tcounter--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvalue = '\\\\' + codePoint.toString(16).toUpperCase() + ' ';\n\t\t\t} else {\n\t\t\t\tif (options.escapeEverything) {\n\t\t\t\t\tif (regexAnySingleEscape.test(character)) {\n\t\t\t\t\t\tvalue = '\\\\' + character;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvalue = '\\\\' + codePoint.toString(16).toUpperCase() + ' ';\n\t\t\t\t\t}\n\t\t\t\t// `:` can be escaped as `\\:`, but that fails in IE < 8\n\t\t\t\t} else if (/[\\t\\n\\f\\r\\x0B:]/.test(character)) {\n\t\t\t\t\tif (!isIdentifier && character == ':') {\n\t\t\t\t\t\tvalue = character;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvalue = '\\\\' + codePoint.toString(16).toUpperCase() + ' ';\n\t\t\t\t\t}\n\t\t\t\t} else if (\n\t\t\t\t\tcharacter == '\\\\' ||\n\t\t\t\t\t(\n\t\t\t\t\t\t!isIdentifier &&\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\t(character == '\"' && quote == character) ||\n\t\t\t\t\t\t\t(character == '\\'' && quote == character)\n\t\t\t\t\t\t)\n\t\t\t\t\t) ||\n\t\t\t\t\t(isIdentifier && regexSingleEscape.test(character))\n\t\t\t\t) {\n\t\t\t\t\tvalue = '\\\\' + character;\n\t\t\t\t} else {\n\t\t\t\t\tvalue = character;\n\t\t\t\t}\n\t\t\t}\n\t\t\toutput += value;\n\t\t}\n\n\t\tif (isIdentifier) {\n\t\t\tif (/^_/.test(output)) {\n\t\t\t\t// Prevent IE6 from ignoring the rule altogether (in case this is for an\n\t\t\t\t// identifier used as a selector)\n\t\t\t\toutput = '\\\\_' + output.slice(1);\n\t\t\t} else if (/^-[-\\d]/.test(output)) {\n\t\t\t\toutput = '\\\\-' + output.slice(1);\n\t\t\t} else if (/\\d/.test(firstChar)) {\n\t\t\t\toutput = '\\\\3' + firstChar + ' ' + output.slice(1);\n\t\t\t}\n\t\t}\n\n\t\t// Remove spaces after `\\HEX` escapes that are not followed by a hex digit,\n\t\t// since theyre redundant. Note that this is only possible if the escape\n\t\t// sequence isnt preceded by an odd number of backslashes.\n\t\toutput = output.replace(regexExcessiveSpaces, function($0, $1, $2) {\n\t\t\tif ($1 && $1.length % 2) {\n\t\t\t\t// its not safe to remove the space, so dont\n\t\t\t\treturn $0;\n\t\t\t}\n\t\t\t// strip the space\n\t\t\treturn ($1 || '') + $2;\n\t\t});\n\n\t\tif (!isIdentifier && options.wrap) {\n\t\t\treturn quote + output + quote;\n\t\t}\n\t\treturn output;\n\t};\n\n\t// Expose default options (so they can be overridden globally)\n\tcssesc.options = {\n\t\t'escapeEverything': false,\n\t\t'isIdentifier': false,\n\t\t'quotes': 'single',\n\t\t'wrap': false\n\t};\n\n\tcssesc.version = '0.1.0';\n\n\t/*--------------------------------------------------------------------------*/\n\n\t// Some AMD build optimizers, like r.js, check for specific condition patterns\n\t// like the following:\n\tif (\n\t\ttypeof define == 'function' &&\n\t\ttypeof define.amd == 'object' &&\n\t\tdefine.amd\n\t) {\n\t\tdefine(function() {\n\t\t\treturn cssesc;\n\t\t});\n\t}\telse if (freeExports && !freeExports.nodeType) {\n\t\tif (freeModule) { // in Node.js or RingoJS v0.8.0+\n\t\t\tfreeModule.exports = cssesc;\n\t\t} else { // in Narwhal or RingoJS v0.7.0-\n\t\t\tfreeExports.cssesc = cssesc;\n\t\t}\n\t} else { // in Rhino or a web browser\n\t\troot.cssesc = cssesc;\n\t}\n\n}(this));\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],133:[function(require,module,exports){\n/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\nfunction ignoreFunction() {}\n\nfunction createReturningFunction(value) {\n\treturn function() {\n\t\treturn value;\n\t};\n}\n\nfunction Parser(states) {\n\tthis.states = this.compileStates(states);\n}\n\nParser.prototype.compileStates = function(states) {\n\tvar result = {};\n\tObject.keys(states).forEach(function(name) {\n\t\tresult[name] = this.compileState(states[name], states);\n\t}, this);\n\treturn result;\n};\n\nParser.prototype.compileState = function(state, states) {\n\tvar regExps = [];\n\tfunction iterator(str, value) {\n\t\tregExps.push({\n\t\t\tgroups: Parser.getGroupCount(str),\n\t\t\tregExp: str,\n\t\t\tvalue: value\n\t\t});\n\t}\n\tfunction processState(statePart) {\n\t\tif(Array.isArray(statePart)) {\n\t\t\tstatePart.forEach(processState);\n\t\t} else if(typeof statePart === \"object\") {\n\t\t\tObject.keys(statePart).forEach(function(key) {\n\t\t\t\titerator(key, statePart[key]);\n\t\t\t});\n\t\t} else if(typeof statePart === \"string\") {\n\t\t\tprocessState(states[statePart]);\n\t\t} else {\n\t\t\tthrow new Error(\"Unexpected 'state' format\");\n\t\t}\n\t}\n\tprocessState(state);\n\tvar total = regExps.map(function(r) {\n\t\treturn \"(\" + r.regExp + \")\";\n\t}).join(\"|\");\n\tvar actions = [];\n\tvar pos = 1;\n\tregExps.forEach(function(r) {\n\t\tvar fn;\n\t\tif(typeof r.value === \"function\") {\n\t\t\tfn = r.value;\n\t\t} else if(typeof r.value === \"string\") {\n\t\t\tfn = createReturningFunction(r.value);\n\t\t} else {\n\t\t\tfn = ignoreFunction;\n\t\t}\n\t\tactions.push({\n\t\t\tname: r.regExp,\n\t\t\tfn: fn,\n\t\t\tpos: pos,\n\t\t\tpos2: pos + r.groups + 1\n\t\t});\n\t\tpos += r.groups + 1;\n\t});\n\treturn {\n\t\tregExp: new RegExp(total, \"g\"),\n\t\tactions: actions\n\t};\n};\n\nParser.getGroupCount = function(regExpStr) {\n\treturn new RegExp(\"(\" + regExpStr + \")|^$\").exec(\"\").length - 2;\n};\n\nParser.prototype.parse = function(initialState, string, context) {\n\tcontext = context || {};\n\tvar currentState = initialState;\n\tvar currentIndex = 0;\n\tfor(;;) {\n\t\tvar state = this.states[currentState];\n\t\tvar regExp = state.regExp;\n\t\tregExp.lastIndex = currentIndex;\n\t\tvar match = regExp.exec(string);\n\t\tif(!match) return context;\n\t\tvar actions = state.actions;\n\t\tcurrentIndex = state.regExp.lastIndex;\n\t\tfor(var i = 0; i < actions.length; i++) {\n\t\t\tvar action = actions[i];\n\t\t\tif(match[action.pos]) {\n\t\t\t\tvar ret = action.fn.apply(context, Array.prototype.slice.call(match, action.pos, action.pos2).concat([state.regExp.lastIndex - match[0].length, match[0].length]));\n\t\t\t\tif(ret) {\n\t\t\t\t\tif(!(ret in this.states))\n\t\t\t\t\t\tthrow new Error(\"State '\" + ret + \"' doesn't exist\");\n\t\t\t\t\tcurrentState = ret;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n};\n\nmodule.exports = Parser;\n\n},{}],134:[function(require,module,exports){\n(function (process){\n// vim:ts=4:sts=4:sw=4:\n/*!\n *\n * Copyright 2009-2012 Kris Kowal under the terms of the MIT\n * license found at http://github.com/kriskowal/q/raw/master/LICENSE\n *\n * With parts by Tyler Close\n * Copyright 2007-2009 Tyler Close under the terms of the MIT X license found\n * at http://www.opensource.org/licenses/mit-license.html\n * Forked at ref_send.js version: 2009-05-11\n *\n * With parts by Mark Miller\n * Copyright (C) 2011 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\n(function (definition) {\n    \"use strict\";\n\n    // This file will function properly as a <script> tag, or a module\n    // using CommonJS and NodeJS or RequireJS module formats.  In\n    // Common/Node/RequireJS, the module exports the Q API and when\n    // executed as a simple <script>, it creates a Q global instead.\n\n    // Montage Require\n    if (typeof bootstrap === \"function\") {\n        bootstrap(\"promise\", definition);\n\n    // CommonJS\n    } else if (typeof exports === \"object\" && typeof module === \"object\") {\n        module.exports = definition();\n\n    // RequireJS\n    } else if (typeof define === \"function\" && define.amd) {\n        define(definition);\n\n    // SES (Secure EcmaScript)\n    } else if (typeof ses !== \"undefined\") {\n        if (!ses.ok()) {\n            return;\n        } else {\n            ses.makeQ = definition;\n        }\n\n    // <script>\n    } else if (typeof window !== \"undefined\" || typeof self !== \"undefined\") {\n        // Prefer window over self for add-on scripts. Use self for\n        // non-windowed contexts.\n        var global = typeof window !== \"undefined\" ? window : self;\n\n        // Get the `window` object, save the previous Q global\n        // and initialize Q as a global.\n        var previousQ = global.Q;\n        global.Q = definition();\n\n        // Add a noConflict function so Q can be removed from the\n        // global namespace.\n        global.Q.noConflict = function () {\n            global.Q = previousQ;\n            return this;\n        };\n\n    } else {\n        throw new Error(\"This environment was not anticipated by Q. Please file a bug.\");\n    }\n\n})(function () {\n\"use strict\";\n\nvar hasStacks = false;\ntry {\n    throw new Error();\n} catch (e) {\n    hasStacks = !!e.stack;\n}\n\n// All code after this point will be filtered from stack traces reported\n// by Q.\nvar qStartingLine = captureLine();\nvar qFileName;\n\n// shims\n\n// used for fallback in \"allResolved\"\nvar noop = function () {};\n\n// Use the fastest possible means to execute a task in a future turn\n// of the event loop.\nvar nextTick =(function () {\n    // linked list of tasks (single, with head node)\n    var head = {task: void 0, next: null};\n    var tail = head;\n    var flushing = false;\n    var requestTick = void 0;\n    var isNodeJS = false;\n    // queue for late tasks, used by unhandled rejection tracking\n    var laterQueue = [];\n\n    function flush() {\n        /* jshint loopfunc: true */\n        var task, domain;\n\n        while (head.next) {\n            head = head.next;\n            task = head.task;\n            head.task = void 0;\n            domain = head.domain;\n\n            if (domain) {\n                head.domain = void 0;\n                domain.enter();\n            }\n            runSingle(task, domain);\n\n        }\n        while (laterQueue.length) {\n            task = laterQueue.pop();\n            runSingle(task);\n        }\n        flushing = false;\n    }\n    // runs a single function in the async queue\n    function runSingle(task, domain) {\n        try {\n            task();\n\n        } catch (e) {\n            if (isNodeJS) {\n                // In node, uncaught exceptions are considered fatal errors.\n                // Re-throw them synchronously to interrupt flushing!\n\n                // Ensure continuation if the uncaught exception is suppressed\n                // listening \"uncaughtException\" events (as domains does).\n                // Continue in next event to avoid tick recursion.\n                if (domain) {\n                    domain.exit();\n                }\n                setTimeout(flush, 0);\n                if (domain) {\n                    domain.enter();\n                }\n\n                throw e;\n\n            } else {\n                // In browsers, uncaught exceptions are not fatal.\n                // Re-throw them asynchronously to avoid slow-downs.\n                setTimeout(function () {\n                    throw e;\n                }, 0);\n            }\n        }\n\n        if (domain) {\n            domain.exit();\n        }\n    }\n\n    nextTick = function (task) {\n        tail = tail.next = {\n            task: task,\n            domain: isNodeJS && process.domain,\n            next: null\n        };\n\n        if (!flushing) {\n            flushing = true;\n            requestTick();\n        }\n    };\n\n    if (typeof process === \"object\" &&\n        process.toString() === \"[object process]\" && process.nextTick) {\n        // Ensure Q is in a real Node environment, with a `process.nextTick`.\n        // To see through fake Node environments:\n        // * Mocha test runner - exposes a `process` global without a `nextTick`\n        // * Browserify - exposes a `process.nexTick` function that uses\n        //   `setTimeout`. In this case `setImmediate` is preferred because\n        //    it is faster. Browserify's `process.toString()` yields\n        //   \"[object Object]\", while in a real Node environment\n        //   `process.nextTick()` yields \"[object process]\".\n        isNodeJS = true;\n\n        requestTick = function () {\n            process.nextTick(flush);\n        };\n\n    } else if (typeof setImmediate === \"function\") {\n        // In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate\n        if (typeof window !== \"undefined\") {\n            requestTick = setImmediate.bind(window, flush);\n        } else {\n            requestTick = function () {\n                setImmediate(flush);\n            };\n        }\n\n    } else if (typeof MessageChannel !== \"undefined\") {\n        // modern browsers\n        // http://www.nonblocking.io/2011/06/windownexttick.html\n        var channel = new MessageChannel();\n        // At least Safari Version 6.0.5 (8536.30.1) intermittently cannot create\n        // working message ports the first time a page loads.\n        channel.port1.onmessage = function () {\n            requestTick = requestPortTick;\n            channel.port1.onmessage = flush;\n            flush();\n        };\n        var requestPortTick = function () {\n            // Opera requires us to provide a message payload, regardless of\n            // whether we use it.\n            channel.port2.postMessage(0);\n        };\n        requestTick = function () {\n            setTimeout(flush, 0);\n            requestPortTick();\n        };\n\n    } else {\n        // old browsers\n        requestTick = function () {\n            setTimeout(flush, 0);\n        };\n    }\n    // runs a task after all other tasks have been run\n    // this is useful for unhandled rejection tracking that needs to happen\n    // after all `then`d tasks have been run.\n    nextTick.runAfter = function (task) {\n        laterQueue.push(task);\n        if (!flushing) {\n            flushing = true;\n            requestTick();\n        }\n    };\n    return nextTick;\n})();\n\n// Attempt to make generics safe in the face of downstream\n// modifications.\n// There is no situation where this is necessary.\n// If you need a security guarantee, these primordials need to be\n// deeply frozen anyway, and if you dont need a security guarantee,\n// this is just plain paranoid.\n// However, this **might** have the nice side-effect of reducing the size of\n// the minified code by reducing x.call() to merely x()\n// See Mark Millers explanation of what this does.\n// http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming\nvar call = Function.call;\nfunction uncurryThis(f) {\n    return function () {\n        return call.apply(f, arguments);\n    };\n}\n// This is equivalent, but slower:\n// uncurryThis = Function_bind.bind(Function_bind.call);\n// http://jsperf.com/uncurrythis\n\nvar array_slice = uncurryThis(Array.prototype.slice);\n\nvar array_reduce = uncurryThis(\n    Array.prototype.reduce || function (callback, basis) {\n        var index = 0,\n            length = this.length;\n        // concerning the initial value, if one is not provided\n        if (arguments.length === 1) {\n            // seek to the first value in the array, accounting\n            // for the possibility that is is a sparse array\n            do {\n                if (index in this) {\n                    basis = this[index++];\n                    break;\n                }\n                if (++index >= length) {\n                    throw new TypeError();\n                }\n            } while (1);\n        }\n        // reduce\n        for (; index < length; index++) {\n            // account for the possibility that the array is sparse\n            if (index in this) {\n                basis = callback(basis, this[index], index);\n            }\n        }\n        return basis;\n    }\n);\n\nvar array_indexOf = uncurryThis(\n    Array.prototype.indexOf || function (value) {\n        // not a very good shim, but good enough for our one use of it\n        for (var i = 0; i < this.length; i++) {\n            if (this[i] === value) {\n                return i;\n            }\n        }\n        return -1;\n    }\n);\n\nvar array_map = uncurryThis(\n    Array.prototype.map || function (callback, thisp) {\n        var self = this;\n        var collect = [];\n        array_reduce(self, function (undefined, value, index) {\n            collect.push(callback.call(thisp, value, index, self));\n        }, void 0);\n        return collect;\n    }\n);\n\nvar object_create = Object.create || function (prototype) {\n    function Type() { }\n    Type.prototype = prototype;\n    return new Type();\n};\n\nvar object_hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);\n\nvar object_keys = Object.keys || function (object) {\n    var keys = [];\n    for (var key in object) {\n        if (object_hasOwnProperty(object, key)) {\n            keys.push(key);\n        }\n    }\n    return keys;\n};\n\nvar object_toString = uncurryThis(Object.prototype.toString);\n\nfunction isObject(value) {\n    return value === Object(value);\n}\n\n// generator related shims\n\n// FIXME: Remove this function once ES6 generators are in SpiderMonkey.\nfunction isStopIteration(exception) {\n    return (\n        object_toString(exception) === \"[object StopIteration]\" ||\n        exception instanceof QReturnValue\n    );\n}\n\n// FIXME: Remove this helper and Q.return once ES6 generators are in\n// SpiderMonkey.\nvar QReturnValue;\nif (typeof ReturnValue !== \"undefined\") {\n    QReturnValue = ReturnValue;\n} else {\n    QReturnValue = function (value) {\n        this.value = value;\n    };\n}\n\n// long stack traces\n\nvar STACK_JUMP_SEPARATOR = \"From previous event:\";\n\nfunction makeStackTraceLong(error, promise) {\n    // If possible, transform the error stack trace by removing Node and Q\n    // cruft, then concatenating with the stack trace of `promise`. See #57.\n    if (hasStacks &&\n        promise.stack &&\n        typeof error === \"object\" &&\n        error !== null &&\n        error.stack &&\n        error.stack.indexOf(STACK_JUMP_SEPARATOR) === -1\n    ) {\n        var stacks = [];\n        for (var p = promise; !!p; p = p.source) {\n            if (p.stack) {\n                stacks.unshift(p.stack);\n            }\n        }\n        stacks.unshift(error.stack);\n\n        var concatedStacks = stacks.join(\"\\n\" + STACK_JUMP_SEPARATOR + \"\\n\");\n        error.stack = filterStackString(concatedStacks);\n    }\n}\n\nfunction filterStackString(stackString) {\n    var lines = stackString.split(\"\\n\");\n    var desiredLines = [];\n    for (var i = 0; i < lines.length; ++i) {\n        var line = lines[i];\n\n        if (!isInternalFrame(line) && !isNodeFrame(line) && line) {\n            desiredLines.push(line);\n        }\n    }\n    return desiredLines.join(\"\\n\");\n}\n\nfunction isNodeFrame(stackLine) {\n    return stackLine.indexOf(\"(module.js:\") !== -1 ||\n           stackLine.indexOf(\"(node.js:\") !== -1;\n}\n\nfunction getFileNameAndLineNumber(stackLine) {\n    // Named functions: \"at functionName (filename:lineNumber:columnNumber)\"\n    // In IE10 function name can have spaces (\"Anonymous function\") O_o\n    var attempt1 = /at .+ \\((.+):(\\d+):(?:\\d+)\\)$/.exec(stackLine);\n    if (attempt1) {\n        return [attempt1[1], Number(attempt1[2])];\n    }\n\n    // Anonymous functions: \"at filename:lineNumber:columnNumber\"\n    var attempt2 = /at ([^ ]+):(\\d+):(?:\\d+)$/.exec(stackLine);\n    if (attempt2) {\n        return [attempt2[1], Number(attempt2[2])];\n    }\n\n    // Firefox style: \"function@filename:lineNumber or @filename:lineNumber\"\n    var attempt3 = /.*@(.+):(\\d+)$/.exec(stackLine);\n    if (attempt3) {\n        return [attempt3[1], Number(attempt3[2])];\n    }\n}\n\nfunction isInternalFrame(stackLine) {\n    var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);\n\n    if (!fileNameAndLineNumber) {\n        return false;\n    }\n\n    var fileName = fileNameAndLineNumber[0];\n    var lineNumber = fileNameAndLineNumber[1];\n\n    return fileName === qFileName &&\n        lineNumber >= qStartingLine &&\n        lineNumber <= qEndingLine;\n}\n\n// discover own file name and line number range for filtering stack\n// traces\nfunction captureLine() {\n    if (!hasStacks) {\n        return;\n    }\n\n    try {\n        throw new Error();\n    } catch (e) {\n        var lines = e.stack.split(\"\\n\");\n        var firstLine = lines[0].indexOf(\"@\") > 0 ? lines[1] : lines[2];\n        var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);\n        if (!fileNameAndLineNumber) {\n            return;\n        }\n\n        qFileName = fileNameAndLineNumber[0];\n        return fileNameAndLineNumber[1];\n    }\n}\n\nfunction deprecate(callback, name, alternative) {\n    return function () {\n        if (typeof console !== \"undefined\" &&\n            typeof console.warn === \"function\") {\n            console.warn(name + \" is deprecated, use \" + alternative +\n                         \" instead.\", new Error(\"\").stack);\n        }\n        return callback.apply(callback, arguments);\n    };\n}\n\n// end of shims\n// beginning of real work\n\n/**\n * Constructs a promise for an immediate reference, passes promises through, or\n * coerces promises from different systems.\n * @param value immediate reference or promise\n */\nfunction Q(value) {\n    // If the object is already a Promise, return it directly.  This enables\n    // the resolve function to both be used to created references from objects,\n    // but to tolerably coerce non-promises to promises.\n    if (value instanceof Promise) {\n        return value;\n    }\n\n    // assimilate thenables\n    if (isPromiseAlike(value)) {\n        return coerce(value);\n    } else {\n        return fulfill(value);\n    }\n}\nQ.resolve = Q;\n\n/**\n * Performs a task in a future turn of the event loop.\n * @param {Function} task\n */\nQ.nextTick = nextTick;\n\n/**\n * Controls whether or not long stack traces will be on\n */\nQ.longStackSupport = false;\n\n// enable long stacks if Q_DEBUG is set\nif (typeof process === \"object\" && process && process.env && process.env.Q_DEBUG) {\n    Q.longStackSupport = true;\n}\n\n/**\n * Constructs a {promise, resolve, reject} object.\n *\n * `resolve` is a callback to invoke with a more resolved value for the\n * promise. To fulfill the promise, invoke `resolve` with any value that is\n * not a thenable. To reject the promise, invoke `resolve` with a rejected\n * thenable, or invoke `reject` with the reason directly. To resolve the\n * promise to another thenable, thus putting it in the same state, invoke\n * `resolve` with that other thenable.\n */\nQ.defer = defer;\nfunction defer() {\n    // if \"messages\" is an \"Array\", that indicates that the promise has not yet\n    // been resolved.  If it is \"undefined\", it has been resolved.  Each\n    // element of the messages array is itself an array of complete arguments to\n    // forward to the resolved promise.  We coerce the resolution value to a\n    // promise using the `resolve` function because it handles both fully\n    // non-thenable values and other thenables gracefully.\n    var messages = [], progressListeners = [], resolvedPromise;\n\n    var deferred = object_create(defer.prototype);\n    var promise = object_create(Promise.prototype);\n\n    promise.promiseDispatch = function (resolve, op, operands) {\n        var args = array_slice(arguments);\n        if (messages) {\n            messages.push(args);\n            if (op === \"when\" && operands[1]) { // progress operand\n                progressListeners.push(operands[1]);\n            }\n        } else {\n            Q.nextTick(function () {\n                resolvedPromise.promiseDispatch.apply(resolvedPromise, args);\n            });\n        }\n    };\n\n    // XXX deprecated\n    promise.valueOf = function () {\n        if (messages) {\n            return promise;\n        }\n        var nearerValue = nearer(resolvedPromise);\n        if (isPromise(nearerValue)) {\n            resolvedPromise = nearerValue; // shorten chain\n        }\n        return nearerValue;\n    };\n\n    promise.inspect = function () {\n        if (!resolvedPromise) {\n            return { state: \"pending\" };\n        }\n        return resolvedPromise.inspect();\n    };\n\n    if (Q.longStackSupport && hasStacks) {\n        try {\n            throw new Error();\n        } catch (e) {\n            // NOTE: don't try to use `Error.captureStackTrace` or transfer the\n            // accessor around; that causes memory leaks as per GH-111. Just\n            // reify the stack trace as a string ASAP.\n            //\n            // At the same time, cut off the first line; it's always just\n            // \"[object Promise]\\n\", as per the `toString`.\n            promise.stack = e.stack.substring(e.stack.indexOf(\"\\n\") + 1);\n        }\n    }\n\n    // NOTE: we do the checks for `resolvedPromise` in each method, instead of\n    // consolidating them into `become`, since otherwise we'd create new\n    // promises with the lines `become(whatever(value))`. See e.g. GH-252.\n\n    function become(newPromise) {\n        resolvedPromise = newPromise;\n        promise.source = newPromise;\n\n        array_reduce(messages, function (undefined, message) {\n            Q.nextTick(function () {\n                newPromise.promiseDispatch.apply(newPromise, message);\n            });\n        }, void 0);\n\n        messages = void 0;\n        progressListeners = void 0;\n    }\n\n    deferred.promise = promise;\n    deferred.resolve = function (value) {\n        if (resolvedPromise) {\n            return;\n        }\n\n        become(Q(value));\n    };\n\n    deferred.fulfill = function (value) {\n        if (resolvedPromise) {\n            return;\n        }\n\n        become(fulfill(value));\n    };\n    deferred.reject = function (reason) {\n        if (resolvedPromise) {\n            return;\n        }\n\n        become(reject(reason));\n    };\n    deferred.notify = function (progress) {\n        if (resolvedPromise) {\n            return;\n        }\n\n        array_reduce(progressListeners, function (undefined, progressListener) {\n            Q.nextTick(function () {\n                progressListener(progress);\n            });\n        }, void 0);\n    };\n\n    return deferred;\n}\n\n/**\n * Creates a Node-style callback that will resolve or reject the deferred\n * promise.\n * @returns a nodeback\n */\ndefer.prototype.makeNodeResolver = function () {\n    var self = this;\n    return function (error, value) {\n        if (error) {\n            self.reject(error);\n        } else if (arguments.length > 2) {\n            self.resolve(array_slice(arguments, 1));\n        } else {\n            self.resolve(value);\n        }\n    };\n};\n\n/**\n * @param resolver {Function} a function that returns nothing and accepts\n * the resolve, reject, and notify functions for a deferred.\n * @returns a promise that may be resolved with the given resolve and reject\n * functions, or rejected by a thrown exception in resolver\n */\nQ.Promise = promise; // ES6\nQ.promise = promise;\nfunction promise(resolver) {\n    if (typeof resolver !== \"function\") {\n        throw new TypeError(\"resolver must be a function.\");\n    }\n    var deferred = defer();\n    try {\n        resolver(deferred.resolve, deferred.reject, deferred.notify);\n    } catch (reason) {\n        deferred.reject(reason);\n    }\n    return deferred.promise;\n}\n\npromise.race = race; // ES6\npromise.all = all; // ES6\npromise.reject = reject; // ES6\npromise.resolve = Q; // ES6\n\n// XXX experimental.  This method is a way to denote that a local value is\n// serializable and should be immediately dispatched to a remote upon request,\n// instead of passing a reference.\nQ.passByCopy = function (object) {\n    //freeze(object);\n    //passByCopies.set(object, true);\n    return object;\n};\n\nPromise.prototype.passByCopy = function () {\n    //freeze(object);\n    //passByCopies.set(object, true);\n    return this;\n};\n\n/**\n * If two promises eventually fulfill to the same value, promises that value,\n * but otherwise rejects.\n * @param x {Any*}\n * @param y {Any*}\n * @returns {Any*} a promise for x and y if they are the same, but a rejection\n * otherwise.\n *\n */\nQ.join = function (x, y) {\n    return Q(x).join(y);\n};\n\nPromise.prototype.join = function (that) {\n    return Q([this, that]).spread(function (x, y) {\n        if (x === y) {\n            // TODO: \"===\" should be Object.is or equiv\n            return x;\n        } else {\n            throw new Error(\"Can't join: not the same: \" + x + \" \" + y);\n        }\n    });\n};\n\n/**\n * Returns a promise for the first of an array of promises to become settled.\n * @param answers {Array[Any*]} promises to race\n * @returns {Any*} the first promise to be settled\n */\nQ.race = race;\nfunction race(answerPs) {\n    return promise(function (resolve, reject) {\n        // Switch to this once we can assume at least ES5\n        // answerPs.forEach(function (answerP) {\n        //     Q(answerP).then(resolve, reject);\n        // });\n        // Use this in the meantime\n        for (var i = 0, len = answerPs.length; i < len; i++) {\n            Q(answerPs[i]).then(resolve, reject);\n        }\n    });\n}\n\nPromise.prototype.race = function () {\n    return this.then(Q.race);\n};\n\n/**\n * Constructs a Promise with a promise descriptor object and optional fallback\n * function.  The descriptor contains methods like when(rejected), get(name),\n * set(name, value), post(name, args), and delete(name), which all\n * return either a value, a promise for a value, or a rejection.  The fallback\n * accepts the operation name, a resolver, and any further arguments that would\n * have been forwarded to the appropriate method above had a method been\n * provided with the proper name.  The API makes no guarantees about the nature\n * of the returned object, apart from that it is usable whereever promises are\n * bought and sold.\n */\nQ.makePromise = Promise;\nfunction Promise(descriptor, fallback, inspect) {\n    if (fallback === void 0) {\n        fallback = function (op) {\n            return reject(new Error(\n                \"Promise does not support operation: \" + op\n            ));\n        };\n    }\n    if (inspect === void 0) {\n        inspect = function () {\n            return {state: \"unknown\"};\n        };\n    }\n\n    var promise = object_create(Promise.prototype);\n\n    promise.promiseDispatch = function (resolve, op, args) {\n        var result;\n        try {\n            if (descriptor[op]) {\n                result = descriptor[op].apply(promise, args);\n            } else {\n                result = fallback.call(promise, op, args);\n            }\n        } catch (exception) {\n            result = reject(exception);\n        }\n        if (resolve) {\n            resolve(result);\n        }\n    };\n\n    promise.inspect = inspect;\n\n    // XXX deprecated `valueOf` and `exception` support\n    if (inspect) {\n        var inspected = inspect();\n        if (inspected.state === \"rejected\") {\n            promise.exception = inspected.reason;\n        }\n\n        promise.valueOf = function () {\n            var inspected = inspect();\n            if (inspected.state === \"pending\" ||\n                inspected.state === \"rejected\") {\n                return promise;\n            }\n            return inspected.value;\n        };\n    }\n\n    return promise;\n}\n\nPromise.prototype.toString = function () {\n    return \"[object Promise]\";\n};\n\nPromise.prototype.then = function (fulfilled, rejected, progressed) {\n    var self = this;\n    var deferred = defer();\n    var done = false;   // ensure the untrusted promise makes at most a\n                        // single call to one of the callbacks\n\n    function _fulfilled(value) {\n        try {\n            return typeof fulfilled === \"function\" ? fulfilled(value) : value;\n        } catch (exception) {\n            return reject(exception);\n        }\n    }\n\n    function _rejected(exception) {\n        if (typeof rejected === \"function\") {\n            makeStackTraceLong(exception, self);\n            try {\n                return rejected(exception);\n            } catch (newException) {\n                return reject(newException);\n            }\n        }\n        return reject(exception);\n    }\n\n    function _progressed(value) {\n        return typeof progressed === \"function\" ? progressed(value) : value;\n    }\n\n    Q.nextTick(function () {\n        self.promiseDispatch(function (value) {\n            if (done) {\n                return;\n            }\n            done = true;\n\n            deferred.resolve(_fulfilled(value));\n        }, \"when\", [function (exception) {\n            if (done) {\n                return;\n            }\n            done = true;\n\n            deferred.resolve(_rejected(exception));\n        }]);\n    });\n\n    // Progress propagator need to be attached in the current tick.\n    self.promiseDispatch(void 0, \"when\", [void 0, function (value) {\n        var newValue;\n        var threw = false;\n        try {\n            newValue = _progressed(value);\n        } catch (e) {\n            threw = true;\n            if (Q.onerror) {\n                Q.onerror(e);\n            } else {\n                throw e;\n            }\n        }\n\n        if (!threw) {\n            deferred.notify(newValue);\n        }\n    }]);\n\n    return deferred.promise;\n};\n\nQ.tap = function (promise, callback) {\n    return Q(promise).tap(callback);\n};\n\n/**\n * Works almost like \"finally\", but not called for rejections.\n * Original resolution value is passed through callback unaffected.\n * Callback may return a promise that will be awaited for.\n * @param {Function} callback\n * @returns {Q.Promise}\n * @example\n * doSomething()\n *   .then(...)\n *   .tap(console.log)\n *   .then(...);\n */\nPromise.prototype.tap = function (callback) {\n    callback = Q(callback);\n\n    return this.then(function (value) {\n        return callback.fcall(value).thenResolve(value);\n    });\n};\n\n/**\n * Registers an observer on a promise.\n *\n * Guarantees:\n *\n * 1. that fulfilled and rejected will be called only once.\n * 2. that either the fulfilled callback or the rejected callback will be\n *    called, but not both.\n * 3. that fulfilled and rejected will not be called in this turn.\n *\n * @param value      promise or immediate reference to observe\n * @param fulfilled  function to be called with the fulfilled value\n * @param rejected   function to be called with the rejection exception\n * @param progressed function to be called on any progress notifications\n * @return promise for the return value from the invoked callback\n */\nQ.when = when;\nfunction when(value, fulfilled, rejected, progressed) {\n    return Q(value).then(fulfilled, rejected, progressed);\n}\n\nPromise.prototype.thenResolve = function (value) {\n    return this.then(function () { return value; });\n};\n\nQ.thenResolve = function (promise, value) {\n    return Q(promise).thenResolve(value);\n};\n\nPromise.prototype.thenReject = function (reason) {\n    return this.then(function () { throw reason; });\n};\n\nQ.thenReject = function (promise, reason) {\n    return Q(promise).thenReject(reason);\n};\n\n/**\n * If an object is not a promise, it is as \"near\" as possible.\n * If a promise is rejected, it is as \"near\" as possible too.\n * If its a fulfilled promise, the fulfillment value is nearer.\n * If its a deferred promise and the deferred has been resolved, the\n * resolution is \"nearer\".\n * @param object\n * @returns most resolved (nearest) form of the object\n */\n\n// XXX should we re-do this?\nQ.nearer = nearer;\nfunction nearer(value) {\n    if (isPromise(value)) {\n        var inspected = value.inspect();\n        if (inspected.state === \"fulfilled\") {\n            return inspected.value;\n        }\n    }\n    return value;\n}\n\n/**\n * @returns whether the given object is a promise.\n * Otherwise it is a fulfilled value.\n */\nQ.isPromise = isPromise;\nfunction isPromise(object) {\n    return object instanceof Promise;\n}\n\nQ.isPromiseAlike = isPromiseAlike;\nfunction isPromiseAlike(object) {\n    return isObject(object) && typeof object.then === \"function\";\n}\n\n/**\n * @returns whether the given object is a pending promise, meaning not\n * fulfilled or rejected.\n */\nQ.isPending = isPending;\nfunction isPending(object) {\n    return isPromise(object) && object.inspect().state === \"pending\";\n}\n\nPromise.prototype.isPending = function () {\n    return this.inspect().state === \"pending\";\n};\n\n/**\n * @returns whether the given object is a value or fulfilled\n * promise.\n */\nQ.isFulfilled = isFulfilled;\nfunction isFulfilled(object) {\n    return !isPromise(object) || object.inspect().state === \"fulfilled\";\n}\n\nPromise.prototype.isFulfilled = function () {\n    return this.inspect().state === \"fulfilled\";\n};\n\n/**\n * @returns whether the given object is a rejected promise.\n */\nQ.isRejected = isRejected;\nfunction isRejected(object) {\n    return isPromise(object) && object.inspect().state === \"rejected\";\n}\n\nPromise.prototype.isRejected = function () {\n    return this.inspect().state === \"rejected\";\n};\n\n//// BEGIN UNHANDLED REJECTION TRACKING\n\n// This promise library consumes exceptions thrown in handlers so they can be\n// handled by a subsequent promise.  The exceptions get added to this array when\n// they are created, and removed when they are handled.  Note that in ES6 or\n// shimmed environments, this would naturally be a `Set`.\nvar unhandledReasons = [];\nvar unhandledRejections = [];\nvar reportedUnhandledRejections = [];\nvar trackUnhandledRejections = true;\n\nfunction resetUnhandledRejections() {\n    unhandledReasons.length = 0;\n    unhandledRejections.length = 0;\n\n    if (!trackUnhandledRejections) {\n        trackUnhandledRejections = true;\n    }\n}\n\nfunction trackRejection(promise, reason) {\n    if (!trackUnhandledRejections) {\n        return;\n    }\n    if (typeof process === \"object\" && typeof process.emit === \"function\") {\n        Q.nextTick.runAfter(function () {\n            if (array_indexOf(unhandledRejections, promise) !== -1) {\n                process.emit(\"unhandledRejection\", reason, promise);\n                reportedUnhandledRejections.push(promise);\n            }\n        });\n    }\n\n    unhandledRejections.push(promise);\n    if (reason && typeof reason.stack !== \"undefined\") {\n        unhandledReasons.push(reason.stack);\n    } else {\n        unhandledReasons.push(\"(no stack) \" + reason);\n    }\n}\n\nfunction untrackRejection(promise) {\n    if (!trackUnhandledRejections) {\n        return;\n    }\n\n    var at = array_indexOf(unhandledRejections, promise);\n    if (at !== -1) {\n        if (typeof process === \"object\" && typeof process.emit === \"function\") {\n            Q.nextTick.runAfter(function () {\n                var atReport = array_indexOf(reportedUnhandledRejections, promise);\n                if (atReport !== -1) {\n                    process.emit(\"rejectionHandled\", unhandledReasons[at], promise);\n                    reportedUnhandledRejections.splice(atReport, 1);\n                }\n            });\n        }\n        unhandledRejections.splice(at, 1);\n        unhandledReasons.splice(at, 1);\n    }\n}\n\nQ.resetUnhandledRejections = resetUnhandledRejections;\n\nQ.getUnhandledReasons = function () {\n    // Make a copy so that consumers can't interfere with our internal state.\n    return unhandledReasons.slice();\n};\n\nQ.stopUnhandledRejectionTracking = function () {\n    resetUnhandledRejections();\n    trackUnhandledRejections = false;\n};\n\nresetUnhandledRejections();\n\n//// END UNHANDLED REJECTION TRACKING\n\n/**\n * Constructs a rejected promise.\n * @param reason value describing the failure\n */\nQ.reject = reject;\nfunction reject(reason) {\n    var rejection = Promise({\n        \"when\": function (rejected) {\n            // note that the error has been handled\n            if (rejected) {\n                untrackRejection(this);\n            }\n            return rejected ? rejected(reason) : this;\n        }\n    }, function fallback() {\n        return this;\n    }, function inspect() {\n        return { state: \"rejected\", reason: reason };\n    });\n\n    // Note that the reason has not been handled.\n    trackRejection(rejection, reason);\n\n    return rejection;\n}\n\n/**\n * Constructs a fulfilled promise for an immediate reference.\n * @param value immediate reference\n */\nQ.fulfill = fulfill;\nfunction fulfill(value) {\n    return Promise({\n        \"when\": function () {\n            return value;\n        },\n        \"get\": function (name) {\n            return value[name];\n        },\n        \"set\": function (name, rhs) {\n            value[name] = rhs;\n        },\n        \"delete\": function (name) {\n            delete value[name];\n        },\n        \"post\": function (name, args) {\n            // Mark Miller proposes that post with no name should apply a\n            // promised function.\n            if (name === null || name === void 0) {\n                return value.apply(void 0, args);\n            } else {\n                return value[name].apply(value, args);\n            }\n        },\n        \"apply\": function (thisp, args) {\n            return value.apply(thisp, args);\n        },\n        \"keys\": function () {\n            return object_keys(value);\n        }\n    }, void 0, function inspect() {\n        return { state: \"fulfilled\", value: value };\n    });\n}\n\n/**\n * Converts thenables to Q promises.\n * @param promise thenable promise\n * @returns a Q promise\n */\nfunction coerce(promise) {\n    var deferred = defer();\n    Q.nextTick(function () {\n        try {\n            promise.then(deferred.resolve, deferred.reject, deferred.notify);\n        } catch (exception) {\n            deferred.reject(exception);\n        }\n    });\n    return deferred.promise;\n}\n\n/**\n * Annotates an object such that it will never be\n * transferred away from this process over any promise\n * communication channel.\n * @param object\n * @returns promise a wrapping of that object that\n * additionally responds to the \"isDef\" message\n * without a rejection.\n */\nQ.master = master;\nfunction master(object) {\n    return Promise({\n        \"isDef\": function () {}\n    }, function fallback(op, args) {\n        return dispatch(object, op, args);\n    }, function () {\n        return Q(object).inspect();\n    });\n}\n\n/**\n * Spreads the values of a promised array of arguments into the\n * fulfillment callback.\n * @param fulfilled callback that receives variadic arguments from the\n * promised array\n * @param rejected callback that receives the exception if the promise\n * is rejected.\n * @returns a promise for the return value or thrown exception of\n * either callback.\n */\nQ.spread = spread;\nfunction spread(value, fulfilled, rejected) {\n    return Q(value).spread(fulfilled, rejected);\n}\n\nPromise.prototype.spread = function (fulfilled, rejected) {\n    return this.all().then(function (array) {\n        return fulfilled.apply(void 0, array);\n    }, rejected);\n};\n\n/**\n * The async function is a decorator for generator functions, turning\n * them into asynchronous generators.  Although generators are only part\n * of the newest ECMAScript 6 drafts, this code does not cause syntax\n * errors in older engines.  This code should continue to work and will\n * in fact improve over time as the language improves.\n *\n * ES6 generators are currently part of V8 version 3.19 with the\n * --harmony-generators runtime flag enabled.  SpiderMonkey has had them\n * for longer, but under an older Python-inspired form.  This function\n * works on both kinds of generators.\n *\n * Decorates a generator function such that:\n *  - it may yield promises\n *  - execution will continue when that promise is fulfilled\n *  - the value of the yield expression will be the fulfilled value\n *  - it returns a promise for the return value (when the generator\n *    stops iterating)\n *  - the decorated function returns a promise for the return value\n *    of the generator or the first rejected promise among those\n *    yielded.\n *  - if an error is thrown in the generator, it propagates through\n *    every following yield until it is caught, or until it escapes\n *    the generator function altogether, and is translated into a\n *    rejection for the promise returned by the decorated generator.\n */\nQ.async = async;\nfunction async(makeGenerator) {\n    return function () {\n        // when verb is \"send\", arg is a value\n        // when verb is \"throw\", arg is an exception\n        function continuer(verb, arg) {\n            var result;\n\n            // Until V8 3.19 / Chromium 29 is released, SpiderMonkey is the only\n            // engine that has a deployed base of browsers that support generators.\n            // However, SM's generators use the Python-inspired semantics of\n            // outdated ES6 drafts.  We would like to support ES6, but we'd also\n            // like to make it possible to use generators in deployed browsers, so\n            // we also support Python-style generators.  At some point we can remove\n            // this block.\n\n            if (typeof StopIteration === \"undefined\") {\n                // ES6 Generators\n                try {\n                    result = generator[verb](arg);\n                } catch (exception) {\n                    return reject(exception);\n                }\n                if (result.done) {\n                    return Q(result.value);\n                } else {\n                    return when(result.value, callback, errback);\n                }\n            } else {\n                // SpiderMonkey Generators\n                // FIXME: Remove this case when SM does ES6 generators.\n                try {\n                    result = generator[verb](arg);\n                } catch (exception) {\n                    if (isStopIteration(exception)) {\n                        return Q(exception.value);\n                    } else {\n                        return reject(exception);\n                    }\n                }\n                return when(result, callback, errback);\n            }\n        }\n        var generator = makeGenerator.apply(this, arguments);\n        var callback = continuer.bind(continuer, \"next\");\n        var errback = continuer.bind(continuer, \"throw\");\n        return callback();\n    };\n}\n\n/**\n * The spawn function is a small wrapper around async that immediately\n * calls the generator and also ends the promise chain, so that any\n * unhandled errors are thrown instead of forwarded to the error\n * handler. This is useful because it's extremely common to run\n * generators at the top-level to work with libraries.\n */\nQ.spawn = spawn;\nfunction spawn(makeGenerator) {\n    Q.done(Q.async(makeGenerator)());\n}\n\n// FIXME: Remove this interface once ES6 generators are in SpiderMonkey.\n/**\n * Throws a ReturnValue exception to stop an asynchronous generator.\n *\n * This interface is a stop-gap measure to support generator return\n * values in older Firefox/SpiderMonkey.  In browsers that support ES6\n * generators like Chromium 29, just use \"return\" in your generator\n * functions.\n *\n * @param value the return value for the surrounding generator\n * @throws ReturnValue exception with the value.\n * @example\n * // ES6 style\n * Q.async(function* () {\n *      var foo = yield getFooPromise();\n *      var bar = yield getBarPromise();\n *      return foo + bar;\n * })\n * // Older SpiderMonkey style\n * Q.async(function () {\n *      var foo = yield getFooPromise();\n *      var bar = yield getBarPromise();\n *      Q.return(foo + bar);\n * })\n */\nQ[\"return\"] = _return;\nfunction _return(value) {\n    throw new QReturnValue(value);\n}\n\n/**\n * The promised function decorator ensures that any promise arguments\n * are settled and passed as values (`this` is also settled and passed\n * as a value).  It will also ensure that the result of a function is\n * always a promise.\n *\n * @example\n * var add = Q.promised(function (a, b) {\n *     return a + b;\n * });\n * add(Q(a), Q(B));\n *\n * @param {function} callback The function to decorate\n * @returns {function} a function that has been decorated.\n */\nQ.promised = promised;\nfunction promised(callback) {\n    return function () {\n        return spread([this, all(arguments)], function (self, args) {\n            return callback.apply(self, args);\n        });\n    };\n}\n\n/**\n * sends a message to a value in a future turn\n * @param object* the recipient\n * @param op the name of the message operation, e.g., \"when\",\n * @param args further arguments to be forwarded to the operation\n * @returns result {Promise} a promise for the result of the operation\n */\nQ.dispatch = dispatch;\nfunction dispatch(object, op, args) {\n    return Q(object).dispatch(op, args);\n}\n\nPromise.prototype.dispatch = function (op, args) {\n    var self = this;\n    var deferred = defer();\n    Q.nextTick(function () {\n        self.promiseDispatch(deferred.resolve, op, args);\n    });\n    return deferred.promise;\n};\n\n/**\n * Gets the value of a property in a future turn.\n * @param object    promise or immediate reference for target object\n * @param name      name of property to get\n * @return promise for the property value\n */\nQ.get = function (object, key) {\n    return Q(object).dispatch(\"get\", [key]);\n};\n\nPromise.prototype.get = function (key) {\n    return this.dispatch(\"get\", [key]);\n};\n\n/**\n * Sets the value of a property in a future turn.\n * @param object    promise or immediate reference for object object\n * @param name      name of property to set\n * @param value     new value of property\n * @return promise for the return value\n */\nQ.set = function (object, key, value) {\n    return Q(object).dispatch(\"set\", [key, value]);\n};\n\nPromise.prototype.set = function (key, value) {\n    return this.dispatch(\"set\", [key, value]);\n};\n\n/**\n * Deletes a property in a future turn.\n * @param object    promise or immediate reference for target object\n * @param name      name of property to delete\n * @return promise for the return value\n */\nQ.del = // XXX legacy\nQ[\"delete\"] = function (object, key) {\n    return Q(object).dispatch(\"delete\", [key]);\n};\n\nPromise.prototype.del = // XXX legacy\nPromise.prototype[\"delete\"] = function (key) {\n    return this.dispatch(\"delete\", [key]);\n};\n\n/**\n * Invokes a method in a future turn.\n * @param object    promise or immediate reference for target object\n * @param name      name of method to invoke\n * @param value     a value to post, typically an array of\n *                  invocation arguments for promises that\n *                  are ultimately backed with `resolve` values,\n *                  as opposed to those backed with URLs\n *                  wherein the posted value can be any\n *                  JSON serializable object.\n * @return promise for the return value\n */\n// bound locally because it is used by other methods\nQ.mapply = // XXX As proposed by \"Redsandro\"\nQ.post = function (object, name, args) {\n    return Q(object).dispatch(\"post\", [name, args]);\n};\n\nPromise.prototype.mapply = // XXX As proposed by \"Redsandro\"\nPromise.prototype.post = function (name, args) {\n    return this.dispatch(\"post\", [name, args]);\n};\n\n/**\n * Invokes a method in a future turn.\n * @param object    promise or immediate reference for target object\n * @param name      name of method to invoke\n * @param ...args   array of invocation arguments\n * @return promise for the return value\n */\nQ.send = // XXX Mark Miller's proposed parlance\nQ.mcall = // XXX As proposed by \"Redsandro\"\nQ.invoke = function (object, name /*...args*/) {\n    return Q(object).dispatch(\"post\", [name, array_slice(arguments, 2)]);\n};\n\nPromise.prototype.send = // XXX Mark Miller's proposed parlance\nPromise.prototype.mcall = // XXX As proposed by \"Redsandro\"\nPromise.prototype.invoke = function (name /*...args*/) {\n    return this.dispatch(\"post\", [name, array_slice(arguments, 1)]);\n};\n\n/**\n * Applies the promised function in a future turn.\n * @param object    promise or immediate reference for target function\n * @param args      array of application arguments\n */\nQ.fapply = function (object, args) {\n    return Q(object).dispatch(\"apply\", [void 0, args]);\n};\n\nPromise.prototype.fapply = function (args) {\n    return this.dispatch(\"apply\", [void 0, args]);\n};\n\n/**\n * Calls the promised function in a future turn.\n * @param object    promise or immediate reference for target function\n * @param ...args   array of application arguments\n */\nQ[\"try\"] =\nQ.fcall = function (object /* ...args*/) {\n    return Q(object).dispatch(\"apply\", [void 0, array_slice(arguments, 1)]);\n};\n\nPromise.prototype.fcall = function (/*...args*/) {\n    return this.dispatch(\"apply\", [void 0, array_slice(arguments)]);\n};\n\n/**\n * Binds the promised function, transforming return values into a fulfilled\n * promise and thrown errors into a rejected one.\n * @param object    promise or immediate reference for target function\n * @param ...args   array of application arguments\n */\nQ.fbind = function (object /*...args*/) {\n    var promise = Q(object);\n    var args = array_slice(arguments, 1);\n    return function fbound() {\n        return promise.dispatch(\"apply\", [\n            this,\n            args.concat(array_slice(arguments))\n        ]);\n    };\n};\nPromise.prototype.fbind = function (/*...args*/) {\n    var promise = this;\n    var args = array_slice(arguments);\n    return function fbound() {\n        return promise.dispatch(\"apply\", [\n            this,\n            args.concat(array_slice(arguments))\n        ]);\n    };\n};\n\n/**\n * Requests the names of the owned properties of a promised\n * object in a future turn.\n * @param object    promise or immediate reference for target object\n * @return promise for the keys of the eventually settled object\n */\nQ.keys = function (object) {\n    return Q(object).dispatch(\"keys\", []);\n};\n\nPromise.prototype.keys = function () {\n    return this.dispatch(\"keys\", []);\n};\n\n/**\n * Turns an array of promises into a promise for an array.  If any of\n * the promises gets rejected, the whole array is rejected immediately.\n * @param {Array*} an array (or promise for an array) of values (or\n * promises for values)\n * @returns a promise for an array of the corresponding values\n */\n// By Mark Miller\n// http://wiki.ecmascript.org/doku.php?id=strawman:concurrency&rev=1308776521#allfulfilled\nQ.all = all;\nfunction all(promises) {\n    return when(promises, function (promises) {\n        var pendingCount = 0;\n        var deferred = defer();\n        array_reduce(promises, function (undefined, promise, index) {\n            var snapshot;\n            if (\n                isPromise(promise) &&\n                (snapshot = promise.inspect()).state === \"fulfilled\"\n            ) {\n                promises[index] = snapshot.value;\n            } else {\n                ++pendingCount;\n                when(\n                    promise,\n                    function (value) {\n                        promises[index] = value;\n                        if (--pendingCount === 0) {\n                            deferred.resolve(promises);\n                        }\n                    },\n                    deferred.reject,\n                    function (progress) {\n                        deferred.notify({ index: index, value: progress });\n                    }\n                );\n            }\n        }, void 0);\n        if (pendingCount === 0) {\n            deferred.resolve(promises);\n        }\n        return deferred.promise;\n    });\n}\n\nPromise.prototype.all = function () {\n    return all(this);\n};\n\n/**\n * Returns the first resolved promise of an array. Prior rejected promises are\n * ignored.  Rejects only if all promises are rejected.\n * @param {Array*} an array containing values or promises for values\n * @returns a promise fulfilled with the value of the first resolved promise,\n * or a rejected promise if all promises are rejected.\n */\nQ.any = any;\n\nfunction any(promises) {\n    if (promises.length === 0) {\n        return Q.resolve();\n    }\n\n    var deferred = Q.defer();\n    var pendingCount = 0;\n    array_reduce(promises, function (prev, current, index) {\n        var promise = promises[index];\n\n        pendingCount++;\n\n        when(promise, onFulfilled, onRejected, onProgress);\n        function onFulfilled(result) {\n            deferred.resolve(result);\n        }\n        function onRejected() {\n            pendingCount--;\n            if (pendingCount === 0) {\n                deferred.reject(new Error(\n                    \"Can't get fulfillment value from any promise, all \" +\n                    \"promises were rejected.\"\n                ));\n            }\n        }\n        function onProgress(progress) {\n            deferred.notify({\n                index: index,\n                value: progress\n            });\n        }\n    }, undefined);\n\n    return deferred.promise;\n}\n\nPromise.prototype.any = function () {\n    return any(this);\n};\n\n/**\n * Waits for all promises to be settled, either fulfilled or\n * rejected.  This is distinct from `all` since that would stop\n * waiting at the first rejection.  The promise returned by\n * `allResolved` will never be rejected.\n * @param promises a promise for an array (or an array) of promises\n * (or values)\n * @return a promise for an array of promises\n */\nQ.allResolved = deprecate(allResolved, \"allResolved\", \"allSettled\");\nfunction allResolved(promises) {\n    return when(promises, function (promises) {\n        promises = array_map(promises, Q);\n        return when(all(array_map(promises, function (promise) {\n            return when(promise, noop, noop);\n        })), function () {\n            return promises;\n        });\n    });\n}\n\nPromise.prototype.allResolved = function () {\n    return allResolved(this);\n};\n\n/**\n * @see Promise#allSettled\n */\nQ.allSettled = allSettled;\nfunction allSettled(promises) {\n    return Q(promises).allSettled();\n}\n\n/**\n * Turns an array of promises into a promise for an array of their states (as\n * returned by `inspect`) when they have all settled.\n * @param {Array[Any*]} values an array (or promise for an array) of values (or\n * promises for values)\n * @returns {Array[State]} an array of states for the respective values.\n */\nPromise.prototype.allSettled = function () {\n    return this.then(function (promises) {\n        return all(array_map(promises, function (promise) {\n            promise = Q(promise);\n            function regardless() {\n                return promise.inspect();\n            }\n            return promise.then(regardless, regardless);\n        }));\n    });\n};\n\n/**\n * Captures the failure of a promise, giving an oportunity to recover\n * with a callback.  If the given promise is fulfilled, the returned\n * promise is fulfilled.\n * @param {Any*} promise for something\n * @param {Function} callback to fulfill the returned promise if the\n * given promise is rejected\n * @returns a promise for the return value of the callback\n */\nQ.fail = // XXX legacy\nQ[\"catch\"] = function (object, rejected) {\n    return Q(object).then(void 0, rejected);\n};\n\nPromise.prototype.fail = // XXX legacy\nPromise.prototype[\"catch\"] = function (rejected) {\n    return this.then(void 0, rejected);\n};\n\n/**\n * Attaches a listener that can respond to progress notifications from a\n * promise's originating deferred. This listener receives the exact arguments\n * passed to ``deferred.notify``.\n * @param {Any*} promise for something\n * @param {Function} callback to receive any progress notifications\n * @returns the given promise, unchanged\n */\nQ.progress = progress;\nfunction progress(object, progressed) {\n    return Q(object).then(void 0, void 0, progressed);\n}\n\nPromise.prototype.progress = function (progressed) {\n    return this.then(void 0, void 0, progressed);\n};\n\n/**\n * Provides an opportunity to observe the settling of a promise,\n * regardless of whether the promise is fulfilled or rejected.  Forwards\n * the resolution to the returned promise when the callback is done.\n * The callback can return a promise to defer completion.\n * @param {Any*} promise\n * @param {Function} callback to observe the resolution of the given\n * promise, takes no arguments.\n * @returns a promise for the resolution of the given promise when\n * ``fin`` is done.\n */\nQ.fin = // XXX legacy\nQ[\"finally\"] = function (object, callback) {\n    return Q(object)[\"finally\"](callback);\n};\n\nPromise.prototype.fin = // XXX legacy\nPromise.prototype[\"finally\"] = function (callback) {\n    callback = Q(callback);\n    return this.then(function (value) {\n        return callback.fcall().then(function () {\n            return value;\n        });\n    }, function (reason) {\n        // TODO attempt to recycle the rejection with \"this\".\n        return callback.fcall().then(function () {\n            throw reason;\n        });\n    });\n};\n\n/**\n * Terminates a chain of promises, forcing rejections to be\n * thrown as exceptions.\n * @param {Any*} promise at the end of a chain of promises\n * @returns nothing\n */\nQ.done = function (object, fulfilled, rejected, progress) {\n    return Q(object).done(fulfilled, rejected, progress);\n};\n\nPromise.prototype.done = function (fulfilled, rejected, progress) {\n    var onUnhandledError = function (error) {\n        // forward to a future turn so that ``when``\n        // does not catch it and turn it into a rejection.\n        Q.nextTick(function () {\n            makeStackTraceLong(error, promise);\n            if (Q.onerror) {\n                Q.onerror(error);\n            } else {\n                throw error;\n            }\n        });\n    };\n\n    // Avoid unnecessary `nextTick`ing via an unnecessary `when`.\n    var promise = fulfilled || rejected || progress ?\n        this.then(fulfilled, rejected, progress) :\n        this;\n\n    if (typeof process === \"object\" && process && process.domain) {\n        onUnhandledError = process.domain.bind(onUnhandledError);\n    }\n\n    promise.then(void 0, onUnhandledError);\n};\n\n/**\n * Causes a promise to be rejected if it does not get fulfilled before\n * some milliseconds time out.\n * @param {Any*} promise\n * @param {Number} milliseconds timeout\n * @param {Any*} custom error message or Error object (optional)\n * @returns a promise for the resolution of the given promise if it is\n * fulfilled before the timeout, otherwise rejected.\n */\nQ.timeout = function (object, ms, error) {\n    return Q(object).timeout(ms, error);\n};\n\nPromise.prototype.timeout = function (ms, error) {\n    var deferred = defer();\n    var timeoutId = setTimeout(function () {\n        if (!error || \"string\" === typeof error) {\n            error = new Error(error || \"Timed out after \" + ms + \" ms\");\n            error.code = \"ETIMEDOUT\";\n        }\n        deferred.reject(error);\n    }, ms);\n\n    this.then(function (value) {\n        clearTimeout(timeoutId);\n        deferred.resolve(value);\n    }, function (exception) {\n        clearTimeout(timeoutId);\n        deferred.reject(exception);\n    }, deferred.notify);\n\n    return deferred.promise;\n};\n\n/**\n * Returns a promise for the given value (or promised value), some\n * milliseconds after it resolved. Passes rejections immediately.\n * @param {Any*} promise\n * @param {Number} milliseconds\n * @returns a promise for the resolution of the given promise after milliseconds\n * time has elapsed since the resolution of the given promise.\n * If the given promise rejects, that is passed immediately.\n */\nQ.delay = function (object, timeout) {\n    if (timeout === void 0) {\n        timeout = object;\n        object = void 0;\n    }\n    return Q(object).delay(timeout);\n};\n\nPromise.prototype.delay = function (timeout) {\n    return this.then(function (value) {\n        var deferred = defer();\n        setTimeout(function () {\n            deferred.resolve(value);\n        }, timeout);\n        return deferred.promise;\n    });\n};\n\n/**\n * Passes a continuation to a Node function, which is called with the given\n * arguments provided as an array, and returns a promise.\n *\n *      Q.nfapply(FS.readFile, [__filename])\n *      .then(function (content) {\n *      })\n *\n */\nQ.nfapply = function (callback, args) {\n    return Q(callback).nfapply(args);\n};\n\nPromise.prototype.nfapply = function (args) {\n    var deferred = defer();\n    var nodeArgs = array_slice(args);\n    nodeArgs.push(deferred.makeNodeResolver());\n    this.fapply(nodeArgs).fail(deferred.reject);\n    return deferred.promise;\n};\n\n/**\n * Passes a continuation to a Node function, which is called with the given\n * arguments provided individually, and returns a promise.\n * @example\n * Q.nfcall(FS.readFile, __filename)\n * .then(function (content) {\n * })\n *\n */\nQ.nfcall = function (callback /*...args*/) {\n    var args = array_slice(arguments, 1);\n    return Q(callback).nfapply(args);\n};\n\nPromise.prototype.nfcall = function (/*...args*/) {\n    var nodeArgs = array_slice(arguments);\n    var deferred = defer();\n    nodeArgs.push(deferred.makeNodeResolver());\n    this.fapply(nodeArgs).fail(deferred.reject);\n    return deferred.promise;\n};\n\n/**\n * Wraps a NodeJS continuation passing function and returns an equivalent\n * version that returns a promise.\n * @example\n * Q.nfbind(FS.readFile, __filename)(\"utf-8\")\n * .then(console.log)\n * .done()\n */\nQ.nfbind =\nQ.denodeify = function (callback /*...args*/) {\n    var baseArgs = array_slice(arguments, 1);\n    return function () {\n        var nodeArgs = baseArgs.concat(array_slice(arguments));\n        var deferred = defer();\n        nodeArgs.push(deferred.makeNodeResolver());\n        Q(callback).fapply(nodeArgs).fail(deferred.reject);\n        return deferred.promise;\n    };\n};\n\nPromise.prototype.nfbind =\nPromise.prototype.denodeify = function (/*...args*/) {\n    var args = array_slice(arguments);\n    args.unshift(this);\n    return Q.denodeify.apply(void 0, args);\n};\n\nQ.nbind = function (callback, thisp /*...args*/) {\n    var baseArgs = array_slice(arguments, 2);\n    return function () {\n        var nodeArgs = baseArgs.concat(array_slice(arguments));\n        var deferred = defer();\n        nodeArgs.push(deferred.makeNodeResolver());\n        function bound() {\n            return callback.apply(thisp, arguments);\n        }\n        Q(bound).fapply(nodeArgs).fail(deferred.reject);\n        return deferred.promise;\n    };\n};\n\nPromise.prototype.nbind = function (/*thisp, ...args*/) {\n    var args = array_slice(arguments, 0);\n    args.unshift(this);\n    return Q.nbind.apply(void 0, args);\n};\n\n/**\n * Calls a method of a Node-style object that accepts a Node-style\n * callback with a given array of arguments, plus a provided callback.\n * @param object an object that has the named method\n * @param {String} name name of the method of object\n * @param {Array} args arguments to pass to the method; the callback\n * will be provided by Q and appended to these arguments.\n * @returns a promise for the value or error\n */\nQ.nmapply = // XXX As proposed by \"Redsandro\"\nQ.npost = function (object, name, args) {\n    return Q(object).npost(name, args);\n};\n\nPromise.prototype.nmapply = // XXX As proposed by \"Redsandro\"\nPromise.prototype.npost = function (name, args) {\n    var nodeArgs = array_slice(args || []);\n    var deferred = defer();\n    nodeArgs.push(deferred.makeNodeResolver());\n    this.dispatch(\"post\", [name, nodeArgs]).fail(deferred.reject);\n    return deferred.promise;\n};\n\n/**\n * Calls a method of a Node-style object that accepts a Node-style\n * callback, forwarding the given variadic arguments, plus a provided\n * callback argument.\n * @param object an object that has the named method\n * @param {String} name name of the method of object\n * @param ...args arguments to pass to the method; the callback will\n * be provided by Q and appended to these arguments.\n * @returns a promise for the value or error\n */\nQ.nsend = // XXX Based on Mark Miller's proposed \"send\"\nQ.nmcall = // XXX Based on \"Redsandro's\" proposal\nQ.ninvoke = function (object, name /*...args*/) {\n    var nodeArgs = array_slice(arguments, 2);\n    var deferred = defer();\n    nodeArgs.push(deferred.makeNodeResolver());\n    Q(object).dispatch(\"post\", [name, nodeArgs]).fail(deferred.reject);\n    return deferred.promise;\n};\n\nPromise.prototype.nsend = // XXX Based on Mark Miller's proposed \"send\"\nPromise.prototype.nmcall = // XXX Based on \"Redsandro's\" proposal\nPromise.prototype.ninvoke = function (name /*...args*/) {\n    var nodeArgs = array_slice(arguments, 1);\n    var deferred = defer();\n    nodeArgs.push(deferred.makeNodeResolver());\n    this.dispatch(\"post\", [name, nodeArgs]).fail(deferred.reject);\n    return deferred.promise;\n};\n\n/**\n * If a function would like to support both Node continuation-passing-style and\n * promise-returning-style, it can end its internal promise chain with\n * `nodeify(nodeback)`, forwarding the optional nodeback argument.  If the user\n * elects to use a nodeback, the result will be sent there.  If they do not\n * pass a nodeback, they will receive the result promise.\n * @param object a result (or a promise for a result)\n * @param {Function} nodeback a Node.js-style callback\n * @returns either the promise or nothing\n */\nQ.nodeify = nodeify;\nfunction nodeify(object, nodeback) {\n    return Q(object).nodeify(nodeback);\n}\n\nPromise.prototype.nodeify = function (nodeback) {\n    if (nodeback) {\n        this.then(function (value) {\n            Q.nextTick(function () {\n                nodeback(null, value);\n            });\n        }, function (error) {\n            Q.nextTick(function () {\n                nodeback(error);\n            });\n        });\n    } else {\n        return this;\n    }\n};\n\nQ.noConflict = function() {\n    throw new Error(\"Q.noConflict only works when Q is used as a global\");\n};\n\n// All code before this point will be filtered from stack traces.\nvar qEndingLine = captureLine();\n\nreturn Q;\n\n});\n\n}).call(this,require('_process'))\n},{\"_process\":93}],135:[function(require,module,exports){\n'use strict';\n\nvar Stringify = require('./stringify');\nvar Parse = require('./parse');\n\nmodule.exports = {\n    stringify: Stringify,\n    parse: Parse\n};\n\n},{\"./parse\":136,\"./stringify\":137}],136:[function(require,module,exports){\n'use strict';\n\nvar Utils = require('./utils');\n\nvar internals = {\n    delimiter: '&',\n    depth: 5,\n    arrayLimit: 20,\n    parameterLimit: 1000,\n    strictNullHandling: false,\n    plainObjects: false,\n    allowPrototypes: false,\n    allowDots: false\n};\n\ninternals.parseValues = function (str, options) {\n    var obj = {};\n    var parts = str.split(options.delimiter, options.parameterLimit === Infinity ? undefined : options.parameterLimit);\n\n    for (var i = 0; i < parts.length; ++i) {\n        var part = parts[i];\n        var pos = part.indexOf(']=') === -1 ? part.indexOf('=') : part.indexOf(']=') + 1;\n\n        if (pos === -1) {\n            obj[Utils.decode(part)] = '';\n\n            if (options.strictNullHandling) {\n                obj[Utils.decode(part)] = null;\n            }\n        } else {\n            var key = Utils.decode(part.slice(0, pos));\n            var val = Utils.decode(part.slice(pos + 1));\n\n            if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                obj[key] = [].concat(obj[key]).concat(val);\n            } else {\n                obj[key] = val;\n            }\n        }\n    }\n\n    return obj;\n};\n\ninternals.parseObject = function (chain, val, options) {\n    if (!chain.length) {\n        return val;\n    }\n\n    var root = chain.shift();\n\n    var obj;\n    if (root === '[]') {\n        obj = [];\n        obj = obj.concat(internals.parseObject(chain, val, options));\n    } else {\n        obj = options.plainObjects ? Object.create(null) : {};\n        var cleanRoot = root[0] === '[' && root[root.length - 1] === ']' ? root.slice(1, root.length - 1) : root;\n        var index = parseInt(cleanRoot, 10);\n        if (\n            !isNaN(index) &&\n            root !== cleanRoot &&\n            String(index) === cleanRoot &&\n            index >= 0 &&\n            (options.parseArrays && index <= options.arrayLimit)\n        ) {\n            obj = [];\n            obj[index] = internals.parseObject(chain, val, options);\n        } else {\n            obj[cleanRoot] = internals.parseObject(chain, val, options);\n        }\n    }\n\n    return obj;\n};\n\ninternals.parseKeys = function (givenKey, val, options) {\n    if (!givenKey) {\n        return;\n    }\n\n    // Transform dot notation to bracket notation\n    var key = options.allowDots ? givenKey.replace(/\\.([^\\.\\[]+)/g, '[$1]') : givenKey;\n\n    // The regex chunks\n\n    var parent = /^([^\\[\\]]*)/;\n    var child = /(\\[[^\\[\\]]*\\])/g;\n\n    // Get the parent\n\n    var segment = parent.exec(key);\n\n    // Stash the parent if it exists\n\n    var keys = [];\n    if (segment[1]) {\n        // If we aren't using plain objects, optionally prefix keys\n        // that would overwrite object prototype properties\n        if (!options.plainObjects && Object.prototype.hasOwnProperty(segment[1])) {\n            if (!options.allowPrototypes) {\n                return;\n            }\n        }\n\n        keys.push(segment[1]);\n    }\n\n    // Loop through children appending to the array until we hit depth\n\n    var i = 0;\n    while ((segment = child.exec(key)) !== null && i < options.depth) {\n        i += 1;\n        if (!options.plainObjects && Object.prototype.hasOwnProperty(segment[1].replace(/\\[|\\]/g, ''))) {\n            if (!options.allowPrototypes) {\n                continue;\n            }\n        }\n        keys.push(segment[1]);\n    }\n\n    // If there's a remainder, just add whatever is left\n\n    if (segment) {\n        keys.push('[' + key.slice(segment.index) + ']');\n    }\n\n    return internals.parseObject(keys, val, options);\n};\n\nmodule.exports = function (str, opts) {\n    var options = opts || {};\n    options.delimiter = typeof options.delimiter === 'string' || Utils.isRegExp(options.delimiter) ? options.delimiter : internals.delimiter;\n    options.depth = typeof options.depth === 'number' ? options.depth : internals.depth;\n    options.arrayLimit = typeof options.arrayLimit === 'number' ? options.arrayLimit : internals.arrayLimit;\n    options.parseArrays = options.parseArrays !== false;\n    options.allowDots = typeof options.allowDots === 'boolean' ? options.allowDots : internals.allowDots;\n    options.plainObjects = typeof options.plainObjects === 'boolean' ? options.plainObjects : internals.plainObjects;\n    options.allowPrototypes = typeof options.allowPrototypes === 'boolean' ? options.allowPrototypes : internals.allowPrototypes;\n    options.parameterLimit = typeof options.parameterLimit === 'number' ? options.parameterLimit : internals.parameterLimit;\n    options.strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : internals.strictNullHandling;\n\n    if (\n        str === '' ||\n        str === null ||\n        typeof str === 'undefined'\n    ) {\n        return options.plainObjects ? Object.create(null) : {};\n    }\n\n    var tempObj = typeof str === 'string' ? internals.parseValues(str, options) : str;\n    var obj = options.plainObjects ? Object.create(null) : {};\n\n    // Iterate over the keys and setup the new object\n\n    var keys = Object.keys(tempObj);\n    for (var i = 0; i < keys.length; ++i) {\n        var key = keys[i];\n        var newObj = internals.parseKeys(key, tempObj[key], options);\n        obj = Utils.merge(obj, newObj, options);\n    }\n\n    return Utils.compact(obj);\n};\n\n},{\"./utils\":138}],137:[function(require,module,exports){\n'use strict';\n\nvar Utils = require('./utils');\n\nvar internals = {\n    delimiter: '&',\n    arrayPrefixGenerators: {\n        brackets: function (prefix) {\n            return prefix + '[]';\n        },\n        indices: function (prefix, key) {\n            return prefix + '[' + key + ']';\n        },\n        repeat: function (prefix) {\n            return prefix;\n        }\n    },\n    strictNullHandling: false,\n    skipNulls: false,\n    encode: true\n};\n\ninternals.stringify = function (object, prefix, generateArrayPrefix, strictNullHandling, skipNulls, encode, filter, sort, allowDots) {\n    var obj = object;\n    if (typeof filter === 'function') {\n        obj = filter(prefix, obj);\n    } else if (Utils.isBuffer(obj)) {\n        obj = String(obj);\n    } else if (obj instanceof Date) {\n        obj = obj.toISOString();\n    } else if (obj === null) {\n        if (strictNullHandling) {\n            return encode ? Utils.encode(prefix) : prefix;\n        }\n\n        obj = '';\n    }\n\n    if (typeof obj === 'string' || typeof obj === 'number' || typeof obj === 'boolean') {\n        if (encode) {\n            return [Utils.encode(prefix) + '=' + Utils.encode(obj)];\n        }\n        return [prefix + '=' + obj];\n    }\n\n    var values = [];\n\n    if (typeof obj === 'undefined') {\n        return values;\n    }\n\n    var objKeys;\n    if (Array.isArray(filter)) {\n        objKeys = filter;\n    } else {\n        var keys = Object.keys(obj);\n        objKeys = sort ? keys.sort(sort) : keys;\n    }\n\n    for (var i = 0; i < objKeys.length; ++i) {\n        var key = objKeys[i];\n\n        if (skipNulls && obj[key] === null) {\n            continue;\n        }\n\n        if (Array.isArray(obj)) {\n            values = values.concat(internals.stringify(obj[key], generateArrayPrefix(prefix, key), generateArrayPrefix, strictNullHandling, skipNulls, encode, filter, sort, allowDots));\n        } else {\n            values = values.concat(internals.stringify(obj[key], prefix + (allowDots ? '.' + key : '[' + key + ']'), generateArrayPrefix, strictNullHandling, skipNulls, encode, filter, sort, allowDots));\n        }\n    }\n\n    return values;\n};\n\nmodule.exports = function (object, opts) {\n    var obj = object;\n    var options = opts || {};\n    var delimiter = typeof options.delimiter === 'undefined' ? internals.delimiter : options.delimiter;\n    var strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : internals.strictNullHandling;\n    var skipNulls = typeof options.skipNulls === 'boolean' ? options.skipNulls : internals.skipNulls;\n    var encode = typeof options.encode === 'boolean' ? options.encode : internals.encode;\n    var sort = typeof options.sort === 'function' ? options.sort : null;\n    var allowDots = typeof options.allowDots === 'undefined' ? false : options.allowDots;\n    var objKeys;\n    var filter;\n    if (typeof options.filter === 'function') {\n        filter = options.filter;\n        obj = filter('', obj);\n    } else if (Array.isArray(options.filter)) {\n        objKeys = filter = options.filter;\n    }\n\n    var keys = [];\n\n    if (typeof obj !== 'object' || obj === null) {\n        return '';\n    }\n\n    var arrayFormat;\n    if (options.arrayFormat in internals.arrayPrefixGenerators) {\n        arrayFormat = options.arrayFormat;\n    } else if ('indices' in options) {\n        arrayFormat = options.indices ? 'indices' : 'repeat';\n    } else {\n        arrayFormat = 'indices';\n    }\n\n    var generateArrayPrefix = internals.arrayPrefixGenerators[arrayFormat];\n\n    if (!objKeys) {\n        objKeys = Object.keys(obj);\n    }\n\n    if (sort) {\n        objKeys.sort(sort);\n    }\n\n    for (var i = 0; i < objKeys.length; ++i) {\n        var key = objKeys[i];\n\n        if (skipNulls && obj[key] === null) {\n            continue;\n        }\n\n        keys = keys.concat(internals.stringify(obj[key], key, generateArrayPrefix, strictNullHandling, skipNulls, encode, filter, sort, allowDots));\n    }\n\n    return keys.join(delimiter);\n};\n\n},{\"./utils\":138}],138:[function(require,module,exports){\n'use strict';\n\nvar hexTable = (function () {\n    var array = new Array(256);\n    for (var i = 0; i < 256; ++i) {\n        array[i] = '%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase();\n    }\n\n    return array;\n}());\n\nexports.arrayToObject = function (source, options) {\n    var obj = options.plainObjects ? Object.create(null) : {};\n    for (var i = 0; i < source.length; ++i) {\n        if (typeof source[i] !== 'undefined') {\n            obj[i] = source[i];\n        }\n    }\n\n    return obj;\n};\n\nexports.merge = function (target, source, options) {\n    if (!source) {\n        return target;\n    }\n\n    if (typeof source !== 'object') {\n        if (Array.isArray(target)) {\n            target.push(source);\n        } else if (typeof target === 'object') {\n            target[source] = true;\n        } else {\n            return [target, source];\n        }\n\n        return target;\n    }\n\n    if (typeof target !== 'object') {\n        return [target].concat(source);\n    }\n\n    var mergeTarget = target;\n    if (Array.isArray(target) && !Array.isArray(source)) {\n        mergeTarget = exports.arrayToObject(target, options);\n    }\n\n\treturn Object.keys(source).reduce(function (acc, key) {\n        var value = source[key];\n\n        if (Object.prototype.hasOwnProperty.call(acc, key)) {\n            acc[key] = exports.merge(acc[key], value, options);\n        } else {\n            acc[key] = value;\n        }\n\t\treturn acc;\n    }, mergeTarget);\n};\n\nexports.decode = function (str) {\n    try {\n        return decodeURIComponent(str.replace(/\\+/g, ' '));\n    } catch (e) {\n        return str;\n    }\n};\n\nexports.encode = function (str) {\n    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.\n    // It has been adapted here for stricter adherence to RFC 3986\n    if (str.length === 0) {\n        return str;\n    }\n\n    var string = typeof str === 'string' ? str : String(str);\n\n    var out = '';\n    for (var i = 0; i < string.length; ++i) {\n        var c = string.charCodeAt(i);\n\n        if (\n            c === 0x2D || // -\n            c === 0x2E || // .\n            c === 0x5F || // _\n            c === 0x7E || // ~\n            (c >= 0x30 && c <= 0x39) || // 0-9\n            (c >= 0x41 && c <= 0x5A) || // a-z\n            (c >= 0x61 && c <= 0x7A) // A-Z\n        ) {\n            out += string.charAt(i);\n            continue;\n        }\n\n        if (c < 0x80) {\n            out = out + hexTable[c];\n            continue;\n        }\n\n        if (c < 0x800) {\n            out = out + (hexTable[0xC0 | (c >> 6)] + hexTable[0x80 | (c & 0x3F)]);\n            continue;\n        }\n\n        if (c < 0xD800 || c >= 0xE000) {\n            out = out + (hexTable[0xE0 | (c >> 12)] + hexTable[0x80 | ((c >> 6) & 0x3F)] + hexTable[0x80 | (c & 0x3F)]);\n            continue;\n        }\n\n        i += 1;\n        c = 0x10000 + (((c & 0x3FF) << 10) | (string.charCodeAt(i) & 0x3FF));\n        out += (hexTable[0xF0 | (c >> 18)] + hexTable[0x80 | ((c >> 12) & 0x3F)] + hexTable[0x80 | ((c >> 6) & 0x3F)] + hexTable[0x80 | (c & 0x3F)]);\n    }\n\n    return out;\n};\n\nexports.compact = function (obj, references) {\n    if (typeof obj !== 'object' || obj === null) {\n        return obj;\n    }\n\n    var refs = references || [];\n    var lookup = refs.indexOf(obj);\n    if (lookup !== -1) {\n        return refs[lookup];\n    }\n\n    refs.push(obj);\n\n    if (Array.isArray(obj)) {\n        var compacted = [];\n\n        for (var i = 0; i < obj.length; ++i) {\n            if (typeof obj[i] !== 'undefined') {\n                compacted.push(obj[i]);\n            }\n        }\n\n        return compacted;\n    }\n\n    var keys = Object.keys(obj);\n    for (var j = 0; j < keys.length; ++j) {\n        var key = keys[j];\n        obj[key] = exports.compact(obj[key], refs);\n    }\n\n    return obj;\n};\n\nexports.isRegExp = function (obj) {\n    return Object.prototype.toString.call(obj) === '[object RegExp]';\n};\n\nexports.isBuffer = function (obj) {\n    if (obj === null || typeof obj === 'undefined') {\n        return false;\n    }\n\n    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));\n};\n\n},{}],139:[function(require,module,exports){\n/*!\n * URI.js - Mutating URLs\n * IPv6 Support\n *\n * Version: 1.16.1\n *\n * Author: Rodney Rehm\n * Web: http://medialize.github.io/URI.js/\n *\n * Licensed under\n *   MIT License http://www.opensource.org/licenses/mit-license\n *   GPL v3 http://opensource.org/licenses/GPL-3.0\n *\n */\n\n(function (root, factory) {\n  'use strict';\n  // https://github.com/umdjs/umd/blob/master/returnExports.js\n  if (typeof exports === 'object') {\n    // Node\n    module.exports = factory();\n  } else if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define(factory);\n  } else {\n    // Browser globals (root is window)\n    root.IPv6 = factory(root);\n  }\n}(this, function (root) {\n  'use strict';\n\n  /*\n  var _in = \"fe80:0000:0000:0000:0204:61ff:fe9d:f156\";\n  var _out = IPv6.best(_in);\n  var _expected = \"fe80::204:61ff:fe9d:f156\";\n\n  console.log(_in, _out, _expected, _out === _expected);\n  */\n\n  // save current IPv6 variable, if any\n  var _IPv6 = root && root.IPv6;\n\n  function bestPresentation(address) {\n    // based on:\n    // Javascript to test an IPv6 address for proper format, and to\n    // present the \"best text representation\" according to IETF Draft RFC at\n    // http://tools.ietf.org/html/draft-ietf-6man-text-addr-representation-04\n    // 8 Feb 2010 Rich Brown, Dartware, LLC\n    // Please feel free to use this code as long as you provide a link to\n    // http://www.intermapper.com\n    // http://intermapper.com/support/tools/IPV6-Validator.aspx\n    // http://download.dartware.com/thirdparty/ipv6validator.js\n\n    var _address = address.toLowerCase();\n    var segments = _address.split(':');\n    var length = segments.length;\n    var total = 8;\n\n    // trim colons (:: or ::a:b:c or a:b:c::)\n    if (segments[0] === '' && segments[1] === '' && segments[2] === '') {\n      // must have been ::\n      // remove first two items\n      segments.shift();\n      segments.shift();\n    } else if (segments[0] === '' && segments[1] === '') {\n      // must have been ::xxxx\n      // remove the first item\n      segments.shift();\n    } else if (segments[length - 1] === '' && segments[length - 2] === '') {\n      // must have been xxxx::\n      segments.pop();\n    }\n\n    length = segments.length;\n\n    // adjust total segments for IPv4 trailer\n    if (segments[length - 1].indexOf('.') !== -1) {\n      // found a \".\" which means IPv4\n      total = 7;\n    }\n\n    // fill empty segments them with \"0000\"\n    var pos;\n    for (pos = 0; pos < length; pos++) {\n      if (segments[pos] === '') {\n        break;\n      }\n    }\n\n    if (pos < total) {\n      segments.splice(pos, 1, '0000');\n      while (segments.length < total) {\n        segments.splice(pos, 0, '0000');\n      }\n\n      length = segments.length;\n    }\n\n    // strip leading zeros\n    var _segments;\n    for (var i = 0; i < total; i++) {\n      _segments = segments[i].split('');\n      for (var j = 0; j < 3 ; j++) {\n        if (_segments[0] === '0' && _segments.length > 1) {\n          _segments.splice(0,1);\n        } else {\n          break;\n        }\n      }\n\n      segments[i] = _segments.join('');\n    }\n\n    // find longest sequence of zeroes and coalesce them into one segment\n    var best = -1;\n    var _best = 0;\n    var _current = 0;\n    var current = -1;\n    var inzeroes = false;\n    // i; already declared\n\n    for (i = 0; i < total; i++) {\n      if (inzeroes) {\n        if (segments[i] === '0') {\n          _current += 1;\n        } else {\n          inzeroes = false;\n          if (_current > _best) {\n            best = current;\n            _best = _current;\n          }\n        }\n      } else {\n        if (segments[i] === '0') {\n          inzeroes = true;\n          current = i;\n          _current = 1;\n        }\n      }\n    }\n\n    if (_current > _best) {\n      best = current;\n      _best = _current;\n    }\n\n    if (_best > 1) {\n      segments.splice(best, _best, '');\n    }\n\n    length = segments.length;\n\n    // assemble remaining segments\n    var result = '';\n    if (segments[0] === '')  {\n      result = ':';\n    }\n\n    for (i = 0; i < length; i++) {\n      result += segments[i];\n      if (i === length - 1) {\n        break;\n      }\n\n      result += ':';\n    }\n\n    if (segments[length - 1] === '') {\n      result += ':';\n    }\n\n    return result;\n  }\n\n  function noConflict() {\n    /*jshint validthis: true */\n    if (root.IPv6 === this) {\n      root.IPv6 = _IPv6;\n    }\n  \n    return this;\n  }\n\n  return {\n    best: bestPresentation,\n    noConflict: noConflict\n  };\n}));\n\n},{}],140:[function(require,module,exports){\n/*!\n * URI.js - Mutating URLs\n * Second Level Domain (SLD) Support\n *\n * Version: 1.16.1\n *\n * Author: Rodney Rehm\n * Web: http://medialize.github.io/URI.js/\n *\n * Licensed under\n *   MIT License http://www.opensource.org/licenses/mit-license\n *   GPL v3 http://opensource.org/licenses/GPL-3.0\n *\n */\n\n(function (root, factory) {\n  'use strict';\n  // https://github.com/umdjs/umd/blob/master/returnExports.js\n  if (typeof exports === 'object') {\n    // Node\n    module.exports = factory();\n  } else if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define(factory);\n  } else {\n    // Browser globals (root is window)\n    root.SecondLevelDomains = factory(root);\n  }\n}(this, function (root) {\n  'use strict';\n\n  // save current SecondLevelDomains variable, if any\n  var _SecondLevelDomains = root && root.SecondLevelDomains;\n\n  var SLD = {\n    // list of known Second Level Domains\n    // converted list of SLDs from https://github.com/gavingmiller/second-level-domains\n    // ----\n    // publicsuffix.org is more current and actually used by a couple of browsers internally.\n    // downside is it also contains domains like \"dyndns.org\" - which is fine for the security\n    // issues browser have to deal with (SOP for cookies, etc) - but is way overboard for URI.js\n    // ----\n    list: {\n      'ac':' com gov mil net org ',\n      'ae':' ac co gov mil name net org pro sch ',\n      'af':' com edu gov net org ',\n      'al':' com edu gov mil net org ',\n      'ao':' co ed gv it og pb ',\n      'ar':' com edu gob gov int mil net org tur ',\n      'at':' ac co gv or ',\n      'au':' asn com csiro edu gov id net org ',\n      'ba':' co com edu gov mil net org rs unbi unmo unsa untz unze ',\n      'bb':' biz co com edu gov info net org store tv ',\n      'bh':' biz cc com edu gov info net org ',\n      'bn':' com edu gov net org ',\n      'bo':' com edu gob gov int mil net org tv ',\n      'br':' adm adv agr am arq art ato b bio blog bmd cim cng cnt com coop ecn edu eng esp etc eti far flog fm fnd fot fst g12 ggf gov imb ind inf jor jus lel mat med mil mus net nom not ntr odo org ppg pro psc psi qsl rec slg srv tmp trd tur tv vet vlog wiki zlg ',\n      'bs':' com edu gov net org ',\n      'bz':' du et om ov rg ',\n      'ca':' ab bc mb nb nf nl ns nt nu on pe qc sk yk ',\n      'ck':' biz co edu gen gov info net org ',\n      'cn':' ac ah bj com cq edu fj gd gov gs gx gz ha hb he hi hl hn jl js jx ln mil net nm nx org qh sc sd sh sn sx tj tw xj xz yn zj ',\n      'co':' com edu gov mil net nom org ',\n      'cr':' ac c co ed fi go or sa ',\n      'cy':' ac biz com ekloges gov ltd name net org parliament press pro tm ',\n      'do':' art com edu gob gov mil net org sld web ',\n      'dz':' art asso com edu gov net org pol ',\n      'ec':' com edu fin gov info med mil net org pro ',\n      'eg':' com edu eun gov mil name net org sci ',\n      'er':' com edu gov ind mil net org rochest w ',\n      'es':' com edu gob nom org ',\n      'et':' biz com edu gov info name net org ',\n      'fj':' ac biz com info mil name net org pro ',\n      'fk':' ac co gov net nom org ',\n      'fr':' asso com f gouv nom prd presse tm ',\n      'gg':' co net org ',\n      'gh':' com edu gov mil org ',\n      'gn':' ac com gov net org ',\n      'gr':' com edu gov mil net org ',\n      'gt':' com edu gob ind mil net org ',\n      'gu':' com edu gov net org ',\n      'hk':' com edu gov idv net org ',\n      'hu':' 2000 agrar bolt casino city co erotica erotika film forum games hotel info ingatlan jogasz konyvelo lakas media news org priv reklam sex shop sport suli szex tm tozsde utazas video ',\n      'id':' ac co go mil net or sch web ',\n      'il':' ac co gov idf k12 muni net org ',\n      'in':' ac co edu ernet firm gen gov i ind mil net nic org res ',\n      'iq':' com edu gov i mil net org ',\n      'ir':' ac co dnssec gov i id net org sch ',\n      'it':' edu gov ',\n      'je':' co net org ',\n      'jo':' com edu gov mil name net org sch ',\n      'jp':' ac ad co ed go gr lg ne or ',\n      'ke':' ac co go info me mobi ne or sc ',\n      'kh':' com edu gov mil net org per ',\n      'ki':' biz com de edu gov info mob net org tel ',\n      'km':' asso com coop edu gouv k medecin mil nom notaires pharmaciens presse tm veterinaire ',\n      'kn':' edu gov net org ',\n      'kr':' ac busan chungbuk chungnam co daegu daejeon es gangwon go gwangju gyeongbuk gyeonggi gyeongnam hs incheon jeju jeonbuk jeonnam k kg mil ms ne or pe re sc seoul ulsan ',\n      'kw':' com edu gov net org ',\n      'ky':' com edu gov net org ',\n      'kz':' com edu gov mil net org ',\n      'lb':' com edu gov net org ',\n      'lk':' assn com edu gov grp hotel int ltd net ngo org sch soc web ',\n      'lr':' com edu gov net org ',\n      'lv':' asn com conf edu gov id mil net org ',\n      'ly':' com edu gov id med net org plc sch ',\n      'ma':' ac co gov m net org press ',\n      'mc':' asso tm ',\n      'me':' ac co edu gov its net org priv ',\n      'mg':' com edu gov mil nom org prd tm ',\n      'mk':' com edu gov inf name net org pro ',\n      'ml':' com edu gov net org presse ',\n      'mn':' edu gov org ',\n      'mo':' com edu gov net org ',\n      'mt':' com edu gov net org ',\n      'mv':' aero biz com coop edu gov info int mil museum name net org pro ',\n      'mw':' ac co com coop edu gov int museum net org ',\n      'mx':' com edu gob net org ',\n      'my':' com edu gov mil name net org sch ',\n      'nf':' arts com firm info net other per rec store web ',\n      'ng':' biz com edu gov mil mobi name net org sch ',\n      'ni':' ac co com edu gob mil net nom org ',\n      'np':' com edu gov mil net org ',\n      'nr':' biz com edu gov info net org ',\n      'om':' ac biz co com edu gov med mil museum net org pro sch ',\n      'pe':' com edu gob mil net nom org sld ',\n      'ph':' com edu gov i mil net ngo org ',\n      'pk':' biz com edu fam gob gok gon gop gos gov net org web ',\n      'pl':' art bialystok biz com edu gda gdansk gorzow gov info katowice krakow lodz lublin mil net ngo olsztyn org poznan pwr radom slupsk szczecin torun warszawa waw wroc wroclaw zgora ',\n      'pr':' ac biz com edu est gov info isla name net org pro prof ',\n      'ps':' com edu gov net org plo sec ',\n      'pw':' belau co ed go ne or ',\n      'ro':' arts com firm info nom nt org rec store tm www ',\n      'rs':' ac co edu gov in org ',\n      'sb':' com edu gov net org ',\n      'sc':' com edu gov net org ',\n      'sh':' co com edu gov net nom org ',\n      'sl':' com edu gov net org ',\n      'st':' co com consulado edu embaixada gov mil net org principe saotome store ',\n      'sv':' com edu gob org red ',\n      'sz':' ac co org ',\n      'tr':' av bbs bel biz com dr edu gen gov info k12 name net org pol tel tsk tv web ',\n      'tt':' aero biz cat co com coop edu gov info int jobs mil mobi museum name net org pro tel travel ',\n      'tw':' club com ebiz edu game gov idv mil net org ',\n      'mu':' ac co com gov net or org ',\n      'mz':' ac co edu gov org ',\n      'na':' co com ',\n      'nz':' ac co cri geek gen govt health iwi maori mil net org parliament school ',\n      'pa':' abo ac com edu gob ing med net nom org sld ',\n      'pt':' com edu gov int net nome org publ ',\n      'py':' com edu gov mil net org ',\n      'qa':' com edu gov mil net org ',\n      're':' asso com nom ',\n      'ru':' ac adygeya altai amur arkhangelsk astrakhan bashkiria belgorod bir bryansk buryatia cbg chel chelyabinsk chita chukotka chuvashia com dagestan e-burg edu gov grozny int irkutsk ivanovo izhevsk jar joshkar-ola kalmykia kaluga kamchatka karelia kazan kchr kemerovo khabarovsk khakassia khv kirov koenig komi kostroma kranoyarsk kuban kurgan kursk lipetsk magadan mari mari-el marine mil mordovia mosreg msk murmansk nalchik net nnov nov novosibirsk nsk omsk orenburg org oryol penza perm pp pskov ptz rnd ryazan sakhalin samara saratov simbirsk smolensk spb stavropol stv surgut tambov tatarstan tom tomsk tsaritsyn tsk tula tuva tver tyumen udm udmurtia ulan-ude vladikavkaz vladimir vladivostok volgograd vologda voronezh vrn vyatka yakutia yamal yekaterinburg yuzhno-sakhalinsk ',\n      'rw':' ac co com edu gouv gov int mil net ',\n      'sa':' com edu gov med net org pub sch ',\n      'sd':' com edu gov info med net org tv ',\n      'se':' a ac b bd c d e f g h i k l m n o org p parti pp press r s t tm u w x y z ',\n      'sg':' com edu gov idn net org per ',\n      'sn':' art com edu gouv org perso univ ',\n      'sy':' com edu gov mil net news org ',\n      'th':' ac co go in mi net or ',\n      'tj':' ac biz co com edu go gov info int mil name net nic org test web ',\n      'tn':' agrinet com defense edunet ens fin gov ind info intl mincom nat net org perso rnrt rns rnu tourism ',\n      'tz':' ac co go ne or ',\n      'ua':' biz cherkassy chernigov chernovtsy ck cn co com crimea cv dn dnepropetrovsk donetsk dp edu gov if in ivano-frankivsk kh kharkov kherson khmelnitskiy kiev kirovograd km kr ks kv lg lugansk lutsk lviv me mk net nikolaev od odessa org pl poltava pp rovno rv sebastopol sumy te ternopil uzhgorod vinnica vn zaporizhzhe zhitomir zp zt ',\n      'ug':' ac co go ne or org sc ',\n      'uk':' ac bl british-library co cym gov govt icnet jet lea ltd me mil mod national-library-scotland nel net nhs nic nls org orgn parliament plc police sch scot soc ',\n      'us':' dni fed isa kids nsn ',\n      'uy':' com edu gub mil net org ',\n      've':' co com edu gob info mil net org web ',\n      'vi':' co com k12 net org ',\n      'vn':' ac biz com edu gov health info int name net org pro ',\n      'ye':' co com gov ltd me net org plc ',\n      'yu':' ac co edu gov org ',\n      'za':' ac agric alt bourse city co cybernet db edu gov grondar iaccess imt inca landesign law mil net ngo nis nom olivetti org pix school tm web ',\n      'zm':' ac co com edu gov net org sch '\n    },\n    // gorhill 2013-10-25: Using indexOf() instead Regexp(). Significant boost\n    // in both performance and memory footprint. No initialization required.\n    // http://jsperf.com/uri-js-sld-regex-vs-binary-search/4\n    // Following methods use lastIndexOf() rather than array.split() in order\n    // to avoid any memory allocations.\n    has: function(domain) {\n      var tldOffset = domain.lastIndexOf('.');\n      if (tldOffset <= 0 || tldOffset >= (domain.length-1)) {\n        return false;\n      }\n      var sldOffset = domain.lastIndexOf('.', tldOffset-1);\n      if (sldOffset <= 0 || sldOffset >= (tldOffset-1)) {\n        return false;\n      }\n      var sldList = SLD.list[domain.slice(tldOffset+1)];\n      if (!sldList) {\n        return false;\n      }\n      return sldList.indexOf(' ' + domain.slice(sldOffset+1, tldOffset) + ' ') >= 0;\n    },\n    is: function(domain) {\n      var tldOffset = domain.lastIndexOf('.');\n      if (tldOffset <= 0 || tldOffset >= (domain.length-1)) {\n        return false;\n      }\n      var sldOffset = domain.lastIndexOf('.', tldOffset-1);\n      if (sldOffset >= 0) {\n        return false;\n      }\n      var sldList = SLD.list[domain.slice(tldOffset+1)];\n      if (!sldList) {\n        return false;\n      }\n      return sldList.indexOf(' ' + domain.slice(0, tldOffset) + ' ') >= 0;\n    },\n    get: function(domain) {\n      var tldOffset = domain.lastIndexOf('.');\n      if (tldOffset <= 0 || tldOffset >= (domain.length-1)) {\n        return null;\n      }\n      var sldOffset = domain.lastIndexOf('.', tldOffset-1);\n      if (sldOffset <= 0 || sldOffset >= (tldOffset-1)) {\n        return null;\n      }\n      var sldList = SLD.list[domain.slice(tldOffset+1)];\n      if (!sldList) {\n        return null;\n      }\n      if (sldList.indexOf(' ' + domain.slice(sldOffset+1, tldOffset) + ' ') < 0) {\n        return null;\n      }\n      return domain.slice(sldOffset+1);\n    },\n    noConflict: function(){\n      if (root.SecondLevelDomains === this) {\n        root.SecondLevelDomains = _SecondLevelDomains;\n      }\n      return this;\n    }\n  };\n\n  return SLD;\n}));\n\n},{}],141:[function(require,module,exports){\n/*!\n * URI.js - Mutating URLs\n *\n * Version: 1.16.1\n *\n * Author: Rodney Rehm\n * Web: http://medialize.github.io/URI.js/\n *\n * Licensed under\n *   MIT License http://www.opensource.org/licenses/mit-license\n *   GPL v3 http://opensource.org/licenses/GPL-3.0\n *\n */\n(function (root, factory) {\n  'use strict';\n  // https://github.com/umdjs/umd/blob/master/returnExports.js\n  if (typeof exports === 'object') {\n    // Node\n    module.exports = factory(require('./punycode'), require('./IPv6'), require('./SecondLevelDomains'));\n  } else if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define(['./punycode', './IPv6', './SecondLevelDomains'], factory);\n  } else {\n    // Browser globals (root is window)\n    root.URI = factory(root.punycode, root.IPv6, root.SecondLevelDomains, root);\n  }\n}(this, function (punycode, IPv6, SLD, root) {\n  'use strict';\n  /*global location, escape, unescape */\n  // FIXME: v2.0.0 renamce non-camelCase properties to uppercase\n  /*jshint camelcase: false */\n\n  // save current URI variable, if any\n  var _URI = root && root.URI;\n\n  function URI(url, base) {\n    var _urlSupplied = arguments.length >= 1;\n    var _baseSupplied = arguments.length >= 2;\n\n    // Allow instantiation without the 'new' keyword\n    if (!(this instanceof URI)) {\n      if (_urlSupplied) {\n        if (_baseSupplied) {\n          return new URI(url, base);\n        }\n\n        return new URI(url);\n      }\n\n      return new URI();\n    }\n\n    if (url === undefined) {\n      if (_urlSupplied) {\n        throw new TypeError('undefined is not a valid argument for URI');\n      }\n\n      if (typeof location !== 'undefined') {\n        url = location.href + '';\n      } else {\n        url = '';\n      }\n    }\n\n    this.href(url);\n\n    // resolve to base according to http://dvcs.w3.org/hg/url/raw-file/tip/Overview.html#constructor\n    if (base !== undefined) {\n      return this.absoluteTo(base);\n    }\n\n    return this;\n  }\n\n  URI.version = '1.16.1';\n\n  var p = URI.prototype;\n  var hasOwn = Object.prototype.hasOwnProperty;\n\n  function escapeRegEx(string) {\n    // https://github.com/medialize/URI.js/commit/85ac21783c11f8ccab06106dba9735a31a86924d#commitcomment-821963\n    return string.replace(/([.*+?^=!:${}()|[\\]\\/\\\\])/g, '\\\\$1');\n  }\n\n  function getType(value) {\n    // IE8 doesn't return [Object Undefined] but [Object Object] for undefined value\n    if (value === undefined) {\n      return 'Undefined';\n    }\n\n    return String(Object.prototype.toString.call(value)).slice(8, -1);\n  }\n\n  function isArray(obj) {\n    return getType(obj) === 'Array';\n  }\n\n  function filterArrayValues(data, value) {\n    var lookup = {};\n    var i, length;\n\n    if (getType(value) === 'RegExp') {\n      lookup = null;\n    } else if (isArray(value)) {\n      for (i = 0, length = value.length; i < length; i++) {\n        lookup[value[i]] = true;\n      }\n    } else {\n      lookup[value] = true;\n    }\n\n    for (i = 0, length = data.length; i < length; i++) {\n      /*jshint laxbreak: true */\n      var _match = lookup && lookup[data[i]] !== undefined\n        || !lookup && value.test(data[i]);\n      /*jshint laxbreak: false */\n      if (_match) {\n        data.splice(i, 1);\n        length--;\n        i--;\n      }\n    }\n\n    return data;\n  }\n\n  function arrayContains(list, value) {\n    var i, length;\n\n    // value may be string, number, array, regexp\n    if (isArray(value)) {\n      // Note: this can be optimized to O(n) (instead of current O(m * n))\n      for (i = 0, length = value.length; i < length; i++) {\n        if (!arrayContains(list, value[i])) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    var _type = getType(value);\n    for (i = 0, length = list.length; i < length; i++) {\n      if (_type === 'RegExp') {\n        if (typeof list[i] === 'string' && list[i].match(value)) {\n          return true;\n        }\n      } else if (list[i] === value) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  function arraysEqual(one, two) {\n    if (!isArray(one) || !isArray(two)) {\n      return false;\n    }\n\n    // arrays can't be equal if they have different amount of content\n    if (one.length !== two.length) {\n      return false;\n    }\n\n    one.sort();\n    two.sort();\n\n    for (var i = 0, l = one.length; i < l; i++) {\n      if (one[i] !== two[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  URI._parts = function() {\n    return {\n      protocol: null,\n      username: null,\n      password: null,\n      hostname: null,\n      urn: null,\n      port: null,\n      path: null,\n      query: null,\n      fragment: null,\n      // state\n      duplicateQueryParameters: URI.duplicateQueryParameters,\n      escapeQuerySpace: URI.escapeQuerySpace\n    };\n  };\n  // state: allow duplicate query parameters (a=1&a=1)\n  URI.duplicateQueryParameters = false;\n  // state: replaces + with %20 (space in query strings)\n  URI.escapeQuerySpace = true;\n  // static properties\n  URI.protocol_expression = /^[a-z][a-z0-9.+-]*$/i;\n  URI.idn_expression = /[^a-z0-9\\.-]/i;\n  URI.punycode_expression = /(xn--)/i;\n  // well, 333.444.555.666 matches, but it sure ain't no IPv4 - do we care?\n  URI.ip4_expression = /^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$/;\n  // credits to Rich Brown\n  // source: http://forums.intermapper.com/viewtopic.php?p=1096#1096\n  // specification: http://www.ietf.org/rfc/rfc4291.txt\n  URI.ip6_expression = /^\\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))(%.+)?\\s*$/;\n  // expression used is \"gruber revised\" (@gruber v2) determined to be the\n  // best solution in a regex-golf we did a couple of ages ago at\n  // * http://mathiasbynens.be/demo/url-regex\n  // * http://rodneyrehm.de/t/url-regex.html\n  URI.find_uri_expression = /\\b((?:[a-z][\\w-]+:(?:\\/{1,3}|[a-z0-9%])|www\\d{0,3}[.]|[a-z0-9.\\-]+[.][a-z]{2,4}\\/)(?:[^\\s()<>]+|\\(([^\\s()<>]+|(\\([^\\s()<>]+\\)))*\\))+(?:\\(([^\\s()<>]+|(\\([^\\s()<>]+\\)))*\\)|[^\\s`!()\\[\\]{};:'\".,<>?]))/ig;\n  URI.findUri = {\n    // valid \"scheme://\" or \"www.\"\n    start: /\\b(?:([a-z][a-z0-9.+-]*:\\/\\/)|www\\.)/gi,\n    // everything up to the next whitespace\n    end: /[\\s\\r\\n]|$/,\n    // trim trailing punctuation captured by end RegExp\n    trim: /[`!()\\[\\]{};:'\".,<>?]+$/\n  };\n  // http://www.iana.org/assignments/uri-schemes.html\n  // http://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#Well-known_ports\n  URI.defaultPorts = {\n    http: '80',\n    https: '443',\n    ftp: '21',\n    gopher: '70',\n    ws: '80',\n    wss: '443'\n  };\n  // allowed hostname characters according to RFC 3986\n  // ALPHA DIGIT \"-\" \".\" \"_\" \"~\" \"!\" \"$\" \"&\" \"'\" \"(\" \")\" \"*\" \"+\" \",\" \";\" \"=\" %encoded\n  // I've never seen a (non-IDN) hostname other than: ALPHA DIGIT . -\n  URI.invalid_hostname_characters = /[^a-zA-Z0-9\\.-]/;\n  // map DOM Elements to their URI attribute\n  URI.domAttributes = {\n    'a': 'href',\n    'blockquote': 'cite',\n    'link': 'href',\n    'base': 'href',\n    'script': 'src',\n    'form': 'action',\n    'img': 'src',\n    'area': 'href',\n    'iframe': 'src',\n    'embed': 'src',\n    'source': 'src',\n    'track': 'src',\n    'input': 'src', // but only if type=\"image\"\n    'audio': 'src',\n    'video': 'src'\n  };\n  URI.getDomAttribute = function(node) {\n    if (!node || !node.nodeName) {\n      return undefined;\n    }\n\n    var nodeName = node.nodeName.toLowerCase();\n    // <input> should only expose src for type=\"image\"\n    if (nodeName === 'input' && node.type !== 'image') {\n      return undefined;\n    }\n\n    return URI.domAttributes[nodeName];\n  };\n\n  function escapeForDumbFirefox36(value) {\n    // https://github.com/medialize/URI.js/issues/91\n    return escape(value);\n  }\n\n  // encoding / decoding according to RFC3986\n  function strictEncodeURIComponent(string) {\n    // see https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/encodeURIComponent\n    return encodeURIComponent(string)\n      .replace(/[!'()*]/g, escapeForDumbFirefox36)\n      .replace(/\\*/g, '%2A');\n  }\n  URI.encode = strictEncodeURIComponent;\n  URI.decode = decodeURIComponent;\n  URI.iso8859 = function() {\n    URI.encode = escape;\n    URI.decode = unescape;\n  };\n  URI.unicode = function() {\n    URI.encode = strictEncodeURIComponent;\n    URI.decode = decodeURIComponent;\n  };\n  URI.characters = {\n    pathname: {\n      encode: {\n        // RFC3986 2.1: For consistency, URI producers and normalizers should\n        // use uppercase hexadecimal digits for all percent-encodings.\n        expression: /%(24|26|2B|2C|3B|3D|3A|40)/ig,\n        map: {\n          // -._~!'()*\n          '%24': '$',\n          '%26': '&',\n          '%2B': '+',\n          '%2C': ',',\n          '%3B': ';',\n          '%3D': '=',\n          '%3A': ':',\n          '%40': '@'\n        }\n      },\n      decode: {\n        expression: /[\\/\\?#]/g,\n        map: {\n          '/': '%2F',\n          '?': '%3F',\n          '#': '%23'\n        }\n      }\n    },\n    reserved: {\n      encode: {\n        // RFC3986 2.1: For consistency, URI producers and normalizers should\n        // use uppercase hexadecimal digits for all percent-encodings.\n        expression: /%(21|23|24|26|27|28|29|2A|2B|2C|2F|3A|3B|3D|3F|40|5B|5D)/ig,\n        map: {\n          // gen-delims\n          '%3A': ':',\n          '%2F': '/',\n          '%3F': '?',\n          '%23': '#',\n          '%5B': '[',\n          '%5D': ']',\n          '%40': '@',\n          // sub-delims\n          '%21': '!',\n          '%24': '$',\n          '%26': '&',\n          '%27': '\\'',\n          '%28': '(',\n          '%29': ')',\n          '%2A': '*',\n          '%2B': '+',\n          '%2C': ',',\n          '%3B': ';',\n          '%3D': '='\n        }\n      }\n    },\n    urnpath: {\n      // The characters under `encode` are the characters called out by RFC 2141 as being acceptable\n      // for usage in a URN. RFC2141 also calls out \"-\", \".\", and \"_\" as acceptable characters, but\n      // these aren't encoded by encodeURIComponent, so we don't have to call them out here. Also\n      // note that the colon character is not featured in the encoding map; this is because URI.js\n      // gives the colons in URNs semantic meaning as the delimiters of path segements, and so it\n      // should not appear unencoded in a segment itself.\n      // See also the note above about RFC3986 and capitalalized hex digits.\n      encode: {\n        expression: /%(21|24|27|28|29|2A|2B|2C|3B|3D|40)/ig,\n        map: {\n          '%21': '!',\n          '%24': '$',\n          '%27': '\\'',\n          '%28': '(',\n          '%29': ')',\n          '%2A': '*',\n          '%2B': '+',\n          '%2C': ',',\n          '%3B': ';',\n          '%3D': '=',\n          '%40': '@'\n        }\n      },\n      // These characters are the characters called out by RFC2141 as \"reserved\" characters that\n      // should never appear in a URN, plus the colon character (see note above).\n      decode: {\n        expression: /[\\/\\?#:]/g,\n        map: {\n          '/': '%2F',\n          '?': '%3F',\n          '#': '%23',\n          ':': '%3A'\n        }\n      }\n    }\n  };\n  URI.encodeQuery = function(string, escapeQuerySpace) {\n    var escaped = URI.encode(string + '');\n    if (escapeQuerySpace === undefined) {\n      escapeQuerySpace = URI.escapeQuerySpace;\n    }\n\n    return escapeQuerySpace ? escaped.replace(/%20/g, '+') : escaped;\n  };\n  URI.decodeQuery = function(string, escapeQuerySpace) {\n    string += '';\n    if (escapeQuerySpace === undefined) {\n      escapeQuerySpace = URI.escapeQuerySpace;\n    }\n\n    try {\n      return URI.decode(escapeQuerySpace ? string.replace(/\\+/g, '%20') : string);\n    } catch(e) {\n      // we're not going to mess with weird encodings,\n      // give up and return the undecoded original string\n      // see https://github.com/medialize/URI.js/issues/87\n      // see https://github.com/medialize/URI.js/issues/92\n      return string;\n    }\n  };\n  // generate encode/decode path functions\n  var _parts = {'encode':'encode', 'decode':'decode'};\n  var _part;\n  var generateAccessor = function(_group, _part) {\n    return function(string) {\n      try {\n        return URI[_part](string + '').replace(URI.characters[_group][_part].expression, function(c) {\n          return URI.characters[_group][_part].map[c];\n        });\n      } catch (e) {\n        // we're not going to mess with weird encodings,\n        // give up and return the undecoded original string\n        // see https://github.com/medialize/URI.js/issues/87\n        // see https://github.com/medialize/URI.js/issues/92\n        return string;\n      }\n    };\n  };\n\n  for (_part in _parts) {\n    URI[_part + 'PathSegment'] = generateAccessor('pathname', _parts[_part]);\n    URI[_part + 'UrnPathSegment'] = generateAccessor('urnpath', _parts[_part]);\n  }\n\n  var generateSegmentedPathFunction = function(_sep, _codingFuncName, _innerCodingFuncName) {\n    return function(string) {\n      // Why pass in names of functions, rather than the function objects themselves? The\n      // definitions of some functions (but in particular, URI.decode) will occasionally change due\n      // to URI.js having ISO8859 and Unicode modes. Passing in the name and getting it will ensure\n      // that the functions we use here are \"fresh\".\n      var actualCodingFunc;\n      if (!_innerCodingFuncName) {\n        actualCodingFunc = URI[_codingFuncName];\n      } else {\n        actualCodingFunc = function(string) {\n          return URI[_codingFuncName](URI[_innerCodingFuncName](string));\n        };\n      }\n\n      var segments = (string + '').split(_sep);\n\n      for (var i = 0, length = segments.length; i < length; i++) {\n        segments[i] = actualCodingFunc(segments[i]);\n      }\n\n      return segments.join(_sep);\n    };\n  };\n\n  // This takes place outside the above loop because we don't want, e.g., encodeUrnPath functions.\n  URI.decodePath = generateSegmentedPathFunction('/', 'decodePathSegment');\n  URI.decodeUrnPath = generateSegmentedPathFunction(':', 'decodeUrnPathSegment');\n  URI.recodePath = generateSegmentedPathFunction('/', 'encodePathSegment', 'decode');\n  URI.recodeUrnPath = generateSegmentedPathFunction(':', 'encodeUrnPathSegment', 'decode');\n\n  URI.encodeReserved = generateAccessor('reserved', 'encode');\n\n  URI.parse = function(string, parts) {\n    var pos;\n    if (!parts) {\n      parts = {};\n    }\n    // [protocol\"://\"[username[\":\"password]\"@\"]hostname[\":\"port]\"/\"?][path][\"?\"querystring][\"#\"fragment]\n\n    // extract fragment\n    pos = string.indexOf('#');\n    if (pos > -1) {\n      // escaping?\n      parts.fragment = string.substring(pos + 1) || null;\n      string = string.substring(0, pos);\n    }\n\n    // extract query\n    pos = string.indexOf('?');\n    if (pos > -1) {\n      // escaping?\n      parts.query = string.substring(pos + 1) || null;\n      string = string.substring(0, pos);\n    }\n\n    // extract protocol\n    if (string.substring(0, 2) === '//') {\n      // relative-scheme\n      parts.protocol = null;\n      string = string.substring(2);\n      // extract \"user:pass@host:port\"\n      string = URI.parseAuthority(string, parts);\n    } else {\n      pos = string.indexOf(':');\n      if (pos > -1) {\n        parts.protocol = string.substring(0, pos) || null;\n        if (parts.protocol && !parts.protocol.match(URI.protocol_expression)) {\n          // : may be within the path\n          parts.protocol = undefined;\n        } else if (string.substring(pos + 1, pos + 3) === '//') {\n          string = string.substring(pos + 3);\n\n          // extract \"user:pass@host:port\"\n          string = URI.parseAuthority(string, parts);\n        } else {\n          string = string.substring(pos + 1);\n          parts.urn = true;\n        }\n      }\n    }\n\n    // what's left must be the path\n    parts.path = string;\n\n    // and we're done\n    return parts;\n  };\n  URI.parseHost = function(string, parts) {\n    // Copy chrome, IE, opera backslash-handling behavior.\n    // Back slashes before the query string get converted to forward slashes\n    // See: https://github.com/joyent/node/blob/386fd24f49b0e9d1a8a076592a404168faeecc34/lib/url.js#L115-L124\n    // See: https://code.google.com/p/chromium/issues/detail?id=25916\n    // https://github.com/medialize/URI.js/pull/233\n    string = string.replace(/\\\\/g, '/');\n\n    // extract host:port\n    var pos = string.indexOf('/');\n    var bracketPos;\n    var t;\n\n    if (pos === -1) {\n      pos = string.length;\n    }\n\n    if (string.charAt(0) === '[') {\n      // IPv6 host - http://tools.ietf.org/html/draft-ietf-6man-text-addr-representation-04#section-6\n      // I claim most client software breaks on IPv6 anyways. To simplify things, URI only accepts\n      // IPv6+port in the format [2001:db8::1]:80 (for the time being)\n      bracketPos = string.indexOf(']');\n      parts.hostname = string.substring(1, bracketPos) || null;\n      parts.port = string.substring(bracketPos + 2, pos) || null;\n      if (parts.port === '/') {\n        parts.port = null;\n      }\n    } else {\n      var firstColon = string.indexOf(':');\n      var firstSlash = string.indexOf('/');\n      var nextColon = string.indexOf(':', firstColon + 1);\n      if (nextColon !== -1 && (firstSlash === -1 || nextColon < firstSlash)) {\n        // IPv6 host contains multiple colons - but no port\n        // this notation is actually not allowed by RFC 3986, but we're a liberal parser\n        parts.hostname = string.substring(0, pos) || null;\n        parts.port = null;\n      } else {\n        t = string.substring(0, pos).split(':');\n        parts.hostname = t[0] || null;\n        parts.port = t[1] || null;\n      }\n    }\n\n    if (parts.hostname && string.substring(pos).charAt(0) !== '/') {\n      pos++;\n      string = '/' + string;\n    }\n\n    return string.substring(pos) || '/';\n  };\n  URI.parseAuthority = function(string, parts) {\n    string = URI.parseUserinfo(string, parts);\n    return URI.parseHost(string, parts);\n  };\n  URI.parseUserinfo = function(string, parts) {\n    // extract username:password\n    var firstSlash = string.indexOf('/');\n    var pos = string.lastIndexOf('@', firstSlash > -1 ? firstSlash : string.length - 1);\n    var t;\n\n    // authority@ must come before /path\n    if (pos > -1 && (firstSlash === -1 || pos < firstSlash)) {\n      t = string.substring(0, pos).split(':');\n      parts.username = t[0] ? URI.decode(t[0]) : null;\n      t.shift();\n      parts.password = t[0] ? URI.decode(t.join(':')) : null;\n      string = string.substring(pos + 1);\n    } else {\n      parts.username = null;\n      parts.password = null;\n    }\n\n    return string;\n  };\n  URI.parseQuery = function(string, escapeQuerySpace) {\n    if (!string) {\n      return {};\n    }\n\n    // throw out the funky business - \"?\"[name\"=\"value\"&\"]+\n    string = string.replace(/&+/g, '&').replace(/^\\?*&*|&+$/g, '');\n\n    if (!string) {\n      return {};\n    }\n\n    var items = {};\n    var splits = string.split('&');\n    var length = splits.length;\n    var v, name, value;\n\n    for (var i = 0; i < length; i++) {\n      v = splits[i].split('=');\n      name = URI.decodeQuery(v.shift(), escapeQuerySpace);\n      // no \"=\" is null according to http://dvcs.w3.org/hg/url/raw-file/tip/Overview.html#collect-url-parameters\n      value = v.length ? URI.decodeQuery(v.join('='), escapeQuerySpace) : null;\n\n      if (hasOwn.call(items, name)) {\n        if (typeof items[name] === 'string' || items[name] === null) {\n          items[name] = [items[name]];\n        }\n\n        items[name].push(value);\n      } else {\n        items[name] = value;\n      }\n    }\n\n    return items;\n  };\n\n  URI.build = function(parts) {\n    var t = '';\n\n    if (parts.protocol) {\n      t += parts.protocol + ':';\n    }\n\n    if (!parts.urn && (t || parts.hostname)) {\n      t += '//';\n    }\n\n    t += (URI.buildAuthority(parts) || '');\n\n    if (typeof parts.path === 'string') {\n      if (parts.path.charAt(0) !== '/' && typeof parts.hostname === 'string') {\n        t += '/';\n      }\n\n      t += parts.path;\n    }\n\n    if (typeof parts.query === 'string' && parts.query) {\n      t += '?' + parts.query;\n    }\n\n    if (typeof parts.fragment === 'string' && parts.fragment) {\n      t += '#' + parts.fragment;\n    }\n    return t;\n  };\n  URI.buildHost = function(parts) {\n    var t = '';\n\n    if (!parts.hostname) {\n      return '';\n    } else if (URI.ip6_expression.test(parts.hostname)) {\n      t += '[' + parts.hostname + ']';\n    } else {\n      t += parts.hostname;\n    }\n\n    if (parts.port) {\n      t += ':' + parts.port;\n    }\n\n    return t;\n  };\n  URI.buildAuthority = function(parts) {\n    return URI.buildUserinfo(parts) + URI.buildHost(parts);\n  };\n  URI.buildUserinfo = function(parts) {\n    var t = '';\n\n    if (parts.username) {\n      t += URI.encode(parts.username);\n\n      if (parts.password) {\n        t += ':' + URI.encode(parts.password);\n      }\n\n      t += '@';\n    }\n\n    return t;\n  };\n  URI.buildQuery = function(data, duplicateQueryParameters, escapeQuerySpace) {\n    // according to http://tools.ietf.org/html/rfc3986 or http://labs.apache.org/webarch/uri/rfc/rfc3986.html\n    // being -._~!$&'()*+,;=:@/? %HEX and alnum are allowed\n    // the RFC explicitly states ?/foo being a valid use case, no mention of parameter syntax!\n    // URI.js treats the query string as being application/x-www-form-urlencoded\n    // see http://www.w3.org/TR/REC-html40/interact/forms.html#form-content-type\n\n    var t = '';\n    var unique, key, i, length;\n    for (key in data) {\n      if (hasOwn.call(data, key) && key) {\n        if (isArray(data[key])) {\n          unique = {};\n          for (i = 0, length = data[key].length; i < length; i++) {\n            if (data[key][i] !== undefined && unique[data[key][i] + ''] === undefined) {\n              t += '&' + URI.buildQueryParameter(key, data[key][i], escapeQuerySpace);\n              if (duplicateQueryParameters !== true) {\n                unique[data[key][i] + ''] = true;\n              }\n            }\n          }\n        } else if (data[key] !== undefined) {\n          t += '&' + URI.buildQueryParameter(key, data[key], escapeQuerySpace);\n        }\n      }\n    }\n\n    return t.substring(1);\n  };\n  URI.buildQueryParameter = function(name, value, escapeQuerySpace) {\n    // http://www.w3.org/TR/REC-html40/interact/forms.html#form-content-type -- application/x-www-form-urlencoded\n    // don't append \"=\" for null values, according to http://dvcs.w3.org/hg/url/raw-file/tip/Overview.html#url-parameter-serialization\n    return URI.encodeQuery(name, escapeQuerySpace) + (value !== null ? '=' + URI.encodeQuery(value, escapeQuerySpace) : '');\n  };\n\n  URI.addQuery = function(data, name, value) {\n    if (typeof name === 'object') {\n      for (var key in name) {\n        if (hasOwn.call(name, key)) {\n          URI.addQuery(data, key, name[key]);\n        }\n      }\n    } else if (typeof name === 'string') {\n      if (data[name] === undefined) {\n        data[name] = value;\n        return;\n      } else if (typeof data[name] === 'string') {\n        data[name] = [data[name]];\n      }\n\n      if (!isArray(value)) {\n        value = [value];\n      }\n\n      data[name] = (data[name] || []).concat(value);\n    } else {\n      throw new TypeError('URI.addQuery() accepts an object, string as the name parameter');\n    }\n  };\n  URI.removeQuery = function(data, name, value) {\n    var i, length, key;\n\n    if (isArray(name)) {\n      for (i = 0, length = name.length; i < length; i++) {\n        data[name[i]] = undefined;\n      }\n    } else if (getType(name) === 'RegExp') {\n      for (key in data) {\n        if (name.test(key)) {\n          data[key] = undefined;\n        }\n      }\n    } else if (typeof name === 'object') {\n      for (key in name) {\n        if (hasOwn.call(name, key)) {\n          URI.removeQuery(data, key, name[key]);\n        }\n      }\n    } else if (typeof name === 'string') {\n      if (value !== undefined) {\n        if (getType(value) === 'RegExp') {\n          if (!isArray(data[name]) && value.test(data[name])) {\n            data[name] = undefined;\n          } else {\n            data[name] = filterArrayValues(data[name], value);\n          }\n        } else if (data[name] === value) {\n          data[name] = undefined;\n        } else if (isArray(data[name])) {\n          data[name] = filterArrayValues(data[name], value);\n        }\n      } else {\n        data[name] = undefined;\n      }\n    } else {\n      throw new TypeError('URI.removeQuery() accepts an object, string, RegExp as the first parameter');\n    }\n  };\n  URI.hasQuery = function(data, name, value, withinArray) {\n    if (typeof name === 'object') {\n      for (var key in name) {\n        if (hasOwn.call(name, key)) {\n          if (!URI.hasQuery(data, key, name[key])) {\n            return false;\n          }\n        }\n      }\n\n      return true;\n    } else if (typeof name !== 'string') {\n      throw new TypeError('URI.hasQuery() accepts an object, string as the name parameter');\n    }\n\n    switch (getType(value)) {\n      case 'Undefined':\n        // true if exists (but may be empty)\n        return name in data; // data[name] !== undefined;\n\n      case 'Boolean':\n        // true if exists and non-empty\n        var _booly = Boolean(isArray(data[name]) ? data[name].length : data[name]);\n        return value === _booly;\n\n      case 'Function':\n        // allow complex comparison\n        return !!value(data[name], name, data);\n\n      case 'Array':\n        if (!isArray(data[name])) {\n          return false;\n        }\n\n        var op = withinArray ? arrayContains : arraysEqual;\n        return op(data[name], value);\n\n      case 'RegExp':\n        if (!isArray(data[name])) {\n          return Boolean(data[name] && data[name].match(value));\n        }\n\n        if (!withinArray) {\n          return false;\n        }\n\n        return arrayContains(data[name], value);\n\n      case 'Number':\n        value = String(value);\n        /* falls through */\n      case 'String':\n        if (!isArray(data[name])) {\n          return data[name] === value;\n        }\n\n        if (!withinArray) {\n          return false;\n        }\n\n        return arrayContains(data[name], value);\n\n      default:\n        throw new TypeError('URI.hasQuery() accepts undefined, boolean, string, number, RegExp, Function as the value parameter');\n    }\n  };\n\n\n  URI.commonPath = function(one, two) {\n    var length = Math.min(one.length, two.length);\n    var pos;\n\n    // find first non-matching character\n    for (pos = 0; pos < length; pos++) {\n      if (one.charAt(pos) !== two.charAt(pos)) {\n        pos--;\n        break;\n      }\n    }\n\n    if (pos < 1) {\n      return one.charAt(0) === two.charAt(0) && one.charAt(0) === '/' ? '/' : '';\n    }\n\n    // revert to last /\n    if (one.charAt(pos) !== '/' || two.charAt(pos) !== '/') {\n      pos = one.substring(0, pos).lastIndexOf('/');\n    }\n\n    return one.substring(0, pos + 1);\n  };\n\n  URI.withinString = function(string, callback, options) {\n    options || (options = {});\n    var _start = options.start || URI.findUri.start;\n    var _end = options.end || URI.findUri.end;\n    var _trim = options.trim || URI.findUri.trim;\n    var _attributeOpen = /[a-z0-9-]=[\"']?$/i;\n\n    _start.lastIndex = 0;\n    while (true) {\n      var match = _start.exec(string);\n      if (!match) {\n        break;\n      }\n\n      var start = match.index;\n      if (options.ignoreHtml) {\n        // attribut(e=[\"']?$)\n        var attributeOpen = string.slice(Math.max(start - 3, 0), start);\n        if (attributeOpen && _attributeOpen.test(attributeOpen)) {\n          continue;\n        }\n      }\n\n      var end = start + string.slice(start).search(_end);\n      var slice = string.slice(start, end).replace(_trim, '');\n      if (options.ignore && options.ignore.test(slice)) {\n        continue;\n      }\n\n      end = start + slice.length;\n      var result = callback(slice, start, end, string);\n      string = string.slice(0, start) + result + string.slice(end);\n      _start.lastIndex = start + result.length;\n    }\n\n    _start.lastIndex = 0;\n    return string;\n  };\n\n  URI.ensureValidHostname = function(v) {\n    // Theoretically URIs allow percent-encoding in Hostnames (according to RFC 3986)\n    // they are not part of DNS and therefore ignored by URI.js\n\n    if (v.match(URI.invalid_hostname_characters)) {\n      // test punycode\n      if (!punycode) {\n        throw new TypeError('Hostname \"' + v + '\" contains characters other than [A-Z0-9.-] and Punycode.js is not available');\n      }\n\n      if (punycode.toASCII(v).match(URI.invalid_hostname_characters)) {\n        throw new TypeError('Hostname \"' + v + '\" contains characters other than [A-Z0-9.-]');\n      }\n    }\n  };\n\n  // noConflict\n  URI.noConflict = function(removeAll) {\n    if (removeAll) {\n      var unconflicted = {\n        URI: this.noConflict()\n      };\n\n      if (root.URITemplate && typeof root.URITemplate.noConflict === 'function') {\n        unconflicted.URITemplate = root.URITemplate.noConflict();\n      }\n\n      if (root.IPv6 && typeof root.IPv6.noConflict === 'function') {\n        unconflicted.IPv6 = root.IPv6.noConflict();\n      }\n\n      if (root.SecondLevelDomains && typeof root.SecondLevelDomains.noConflict === 'function') {\n        unconflicted.SecondLevelDomains = root.SecondLevelDomains.noConflict();\n      }\n\n      return unconflicted;\n    } else if (root.URI === this) {\n      root.URI = _URI;\n    }\n\n    return this;\n  };\n\n  p.build = function(deferBuild) {\n    if (deferBuild === true) {\n      this._deferred_build = true;\n    } else if (deferBuild === undefined || this._deferred_build) {\n      this._string = URI.build(this._parts);\n      this._deferred_build = false;\n    }\n\n    return this;\n  };\n\n  p.clone = function() {\n    return new URI(this);\n  };\n\n  p.valueOf = p.toString = function() {\n    return this.build(false)._string;\n  };\n\n\n  function generateSimpleAccessor(_part){\n    return function(v, build) {\n      if (v === undefined) {\n        return this._parts[_part] || '';\n      } else {\n        this._parts[_part] = v || null;\n        this.build(!build);\n        return this;\n      }\n    };\n  }\n\n  function generatePrefixAccessor(_part, _key){\n    return function(v, build) {\n      if (v === undefined) {\n        return this._parts[_part] || '';\n      } else {\n        if (v !== null) {\n          v = v + '';\n          if (v.charAt(0) === _key) {\n            v = v.substring(1);\n          }\n        }\n\n        this._parts[_part] = v;\n        this.build(!build);\n        return this;\n      }\n    };\n  }\n\n  p.protocol = generateSimpleAccessor('protocol');\n  p.username = generateSimpleAccessor('username');\n  p.password = generateSimpleAccessor('password');\n  p.hostname = generateSimpleAccessor('hostname');\n  p.port = generateSimpleAccessor('port');\n  p.query = generatePrefixAccessor('query', '?');\n  p.fragment = generatePrefixAccessor('fragment', '#');\n\n  p.search = function(v, build) {\n    var t = this.query(v, build);\n    return typeof t === 'string' && t.length ? ('?' + t) : t;\n  };\n  p.hash = function(v, build) {\n    var t = this.fragment(v, build);\n    return typeof t === 'string' && t.length ? ('#' + t) : t;\n  };\n\n  p.pathname = function(v, build) {\n    if (v === undefined || v === true) {\n      var res = this._parts.path || (this._parts.hostname ? '/' : '');\n      return v ? (this._parts.urn ? URI.decodeUrnPath : URI.decodePath)(res) : res;\n    } else {\n      if (this._parts.urn) {\n        this._parts.path = v ? URI.recodeUrnPath(v) : '';\n      } else {\n        this._parts.path = v ? URI.recodePath(v) : '/';\n      }\n      this.build(!build);\n      return this;\n    }\n  };\n  p.path = p.pathname;\n  p.href = function(href, build) {\n    var key;\n\n    if (href === undefined) {\n      return this.toString();\n    }\n\n    this._string = '';\n    this._parts = URI._parts();\n\n    var _URI = href instanceof URI;\n    var _object = typeof href === 'object' && (href.hostname || href.path || href.pathname);\n    if (href.nodeName) {\n      var attribute = URI.getDomAttribute(href);\n      href = href[attribute] || '';\n      _object = false;\n    }\n\n    // window.location is reported to be an object, but it's not the sort\n    // of object we're looking for:\n    // * location.protocol ends with a colon\n    // * location.query != object.search\n    // * location.hash != object.fragment\n    // simply serializing the unknown object should do the trick\n    // (for location, not for everything...)\n    if (!_URI && _object && href.pathname !== undefined) {\n      href = href.toString();\n    }\n\n    if (typeof href === 'string' || href instanceof String) {\n      this._parts = URI.parse(String(href), this._parts);\n    } else if (_URI || _object) {\n      var src = _URI ? href._parts : href;\n      for (key in src) {\n        if (hasOwn.call(this._parts, key)) {\n          this._parts[key] = src[key];\n        }\n      }\n    } else {\n      throw new TypeError('invalid input');\n    }\n\n    this.build(!build);\n    return this;\n  };\n\n  // identification accessors\n  p.is = function(what) {\n    var ip = false;\n    var ip4 = false;\n    var ip6 = false;\n    var name = false;\n    var sld = false;\n    var idn = false;\n    var punycode = false;\n    var relative = !this._parts.urn;\n\n    if (this._parts.hostname) {\n      relative = false;\n      ip4 = URI.ip4_expression.test(this._parts.hostname);\n      ip6 = URI.ip6_expression.test(this._parts.hostname);\n      ip = ip4 || ip6;\n      name = !ip;\n      sld = name && SLD && SLD.has(this._parts.hostname);\n      idn = name && URI.idn_expression.test(this._parts.hostname);\n      punycode = name && URI.punycode_expression.test(this._parts.hostname);\n    }\n\n    switch (what.toLowerCase()) {\n      case 'relative':\n        return relative;\n\n      case 'absolute':\n        return !relative;\n\n      // hostname identification\n      case 'domain':\n      case 'name':\n        return name;\n\n      case 'sld':\n        return sld;\n\n      case 'ip':\n        return ip;\n\n      case 'ip4':\n      case 'ipv4':\n      case 'inet4':\n        return ip4;\n\n      case 'ip6':\n      case 'ipv6':\n      case 'inet6':\n        return ip6;\n\n      case 'idn':\n        return idn;\n\n      case 'url':\n        return !this._parts.urn;\n\n      case 'urn':\n        return !!this._parts.urn;\n\n      case 'punycode':\n        return punycode;\n    }\n\n    return null;\n  };\n\n  // component specific input validation\n  var _protocol = p.protocol;\n  var _port = p.port;\n  var _hostname = p.hostname;\n\n  p.protocol = function(v, build) {\n    if (v !== undefined) {\n      if (v) {\n        // accept trailing ://\n        v = v.replace(/:(\\/\\/)?$/, '');\n\n        if (!v.match(URI.protocol_expression)) {\n          throw new TypeError('Protocol \"' + v + '\" contains characters other than [A-Z0-9.+-] or doesn\\'t start with [A-Z]');\n        }\n      }\n    }\n    return _protocol.call(this, v, build);\n  };\n  p.scheme = p.protocol;\n  p.port = function(v, build) {\n    if (this._parts.urn) {\n      return v === undefined ? '' : this;\n    }\n\n    if (v !== undefined) {\n      if (v === 0) {\n        v = null;\n      }\n\n      if (v) {\n        v += '';\n        if (v.charAt(0) === ':') {\n          v = v.substring(1);\n        }\n\n        if (v.match(/[^0-9]/)) {\n          throw new TypeError('Port \"' + v + '\" contains characters other than [0-9]');\n        }\n      }\n    }\n    return _port.call(this, v, build);\n  };\n  p.hostname = function(v, build) {\n    if (this._parts.urn) {\n      return v === undefined ? '' : this;\n    }\n\n    if (v !== undefined) {\n      var x = {};\n      var res = URI.parseHost(v, x);\n      if (res !== '/') {\n        throw new TypeError('Hostname \"' + v + '\" contains characters other than [A-Z0-9.-]');\n      }\n\n      v = x.hostname;\n    }\n    return _hostname.call(this, v, build);\n  };\n\n  // compound accessors\n  p.host = function(v, build) {\n    if (this._parts.urn) {\n      return v === undefined ? '' : this;\n    }\n\n    if (v === undefined) {\n      return this._parts.hostname ? URI.buildHost(this._parts) : '';\n    } else {\n      var res = URI.parseHost(v, this._parts);\n      if (res !== '/') {\n        throw new TypeError('Hostname \"' + v + '\" contains characters other than [A-Z0-9.-]');\n      }\n\n      this.build(!build);\n      return this;\n    }\n  };\n  p.authority = function(v, build) {\n    if (this._parts.urn) {\n      return v === undefined ? '' : this;\n    }\n\n    if (v === undefined) {\n      return this._parts.hostname ? URI.buildAuthority(this._parts) : '';\n    } else {\n      var res = URI.parseAuthority(v, this._parts);\n      if (res !== '/') {\n        throw new TypeError('Hostname \"' + v + '\" contains characters other than [A-Z0-9.-]');\n      }\n\n      this.build(!build);\n      return this;\n    }\n  };\n  p.userinfo = function(v, build) {\n    if (this._parts.urn) {\n      return v === undefined ? '' : this;\n    }\n\n    if (v === undefined) {\n      if (!this._parts.username) {\n        return '';\n      }\n\n      var t = URI.buildUserinfo(this._parts);\n      return t.substring(0, t.length -1);\n    } else {\n      if (v[v.length-1] !== '@') {\n        v += '@';\n      }\n\n      URI.parseUserinfo(v, this._parts);\n      this.build(!build);\n      return this;\n    }\n  };\n  p.resource = function(v, build) {\n    var parts;\n\n    if (v === undefined) {\n      return this.path() + this.search() + this.hash();\n    }\n\n    parts = URI.parse(v);\n    this._parts.path = parts.path;\n    this._parts.query = parts.query;\n    this._parts.fragment = parts.fragment;\n    this.build(!build);\n    return this;\n  };\n\n  // fraction accessors\n  p.subdomain = function(v, build) {\n    if (this._parts.urn) {\n      return v === undefined ? '' : this;\n    }\n\n    // convenience, return \"www\" from \"www.example.org\"\n    if (v === undefined) {\n      if (!this._parts.hostname || this.is('IP')) {\n        return '';\n      }\n\n      // grab domain and add another segment\n      var end = this._parts.hostname.length - this.domain().length - 1;\n      return this._parts.hostname.substring(0, end) || '';\n    } else {\n      var e = this._parts.hostname.length - this.domain().length;\n      var sub = this._parts.hostname.substring(0, e);\n      var replace = new RegExp('^' + escapeRegEx(sub));\n\n      if (v && v.charAt(v.length - 1) !== '.') {\n        v += '.';\n      }\n\n      if (v) {\n        URI.ensureValidHostname(v);\n      }\n\n      this._parts.hostname = this._parts.hostname.replace(replace, v);\n      this.build(!build);\n      return this;\n    }\n  };\n  p.domain = function(v, build) {\n    if (this._parts.urn) {\n      return v === undefined ? '' : this;\n    }\n\n    if (typeof v === 'boolean') {\n      build = v;\n      v = undefined;\n    }\n\n    // convenience, return \"example.org\" from \"www.example.org\"\n    if (v === undefined) {\n      if (!this._parts.hostname || this.is('IP')) {\n        return '';\n      }\n\n      // if hostname consists of 1 or 2 segments, it must be the domain\n      var t = this._parts.hostname.match(/\\./g);\n      if (t && t.length < 2) {\n        return this._parts.hostname;\n      }\n\n      // grab tld and add another segment\n      var end = this._parts.hostname.length - this.tld(build).length - 1;\n      end = this._parts.hostname.lastIndexOf('.', end -1) + 1;\n      return this._parts.hostname.substring(end) || '';\n    } else {\n      if (!v) {\n        throw new TypeError('cannot set domain empty');\n      }\n\n      URI.ensureValidHostname(v);\n\n      if (!this._parts.hostname || this.is('IP')) {\n        this._parts.hostname = v;\n      } else {\n        var replace = new RegExp(escapeRegEx(this.domain()) + '$');\n        this._parts.hostname = this._parts.hostname.replace(replace, v);\n      }\n\n      this.build(!build);\n      return this;\n    }\n  };\n  p.tld = function(v, build) {\n    if (this._parts.urn) {\n      return v === undefined ? '' : this;\n    }\n\n    if (typeof v === 'boolean') {\n      build = v;\n      v = undefined;\n    }\n\n    // return \"org\" from \"www.example.org\"\n    if (v === undefined) {\n      if (!this._parts.hostname || this.is('IP')) {\n        return '';\n      }\n\n      var pos = this._parts.hostname.lastIndexOf('.');\n      var tld = this._parts.hostname.substring(pos + 1);\n\n      if (build !== true && SLD && SLD.list[tld.toLowerCase()]) {\n        return SLD.get(this._parts.hostname) || tld;\n      }\n\n      return tld;\n    } else {\n      var replace;\n\n      if (!v) {\n        throw new TypeError('cannot set TLD empty');\n      } else if (v.match(/[^a-zA-Z0-9-]/)) {\n        if (SLD && SLD.is(v)) {\n          replace = new RegExp(escapeRegEx(this.tld()) + '$');\n          this._parts.hostname = this._parts.hostname.replace(replace, v);\n        } else {\n          throw new TypeError('TLD \"' + v + '\" contains characters other than [A-Z0-9]');\n        }\n      } else if (!this._parts.hostname || this.is('IP')) {\n        throw new ReferenceError('cannot set TLD on non-domain host');\n      } else {\n        replace = new RegExp(escapeRegEx(this.tld()) + '$');\n        this._parts.hostname = this._parts.hostname.replace(replace, v);\n      }\n\n      this.build(!build);\n      return this;\n    }\n  };\n  p.directory = function(v, build) {\n    if (this._parts.urn) {\n      return v === undefined ? '' : this;\n    }\n\n    if (v === undefined || v === true) {\n      if (!this._parts.path && !this._parts.hostname) {\n        return '';\n      }\n\n      if (this._parts.path === '/') {\n        return '/';\n      }\n\n      var end = this._parts.path.length - this.filename().length - 1;\n      var res = this._parts.path.substring(0, end) || (this._parts.hostname ? '/' : '');\n\n      return v ? URI.decodePath(res) : res;\n\n    } else {\n      var e = this._parts.path.length - this.filename().length;\n      var directory = this._parts.path.substring(0, e);\n      var replace = new RegExp('^' + escapeRegEx(directory));\n\n      // fully qualifier directories begin with a slash\n      if (!this.is('relative')) {\n        if (!v) {\n          v = '/';\n        }\n\n        if (v.charAt(0) !== '/') {\n          v = '/' + v;\n        }\n      }\n\n      // directories always end with a slash\n      if (v && v.charAt(v.length - 1) !== '/') {\n        v += '/';\n      }\n\n      v = URI.recodePath(v);\n      this._parts.path = this._parts.path.replace(replace, v);\n      this.build(!build);\n      return this;\n    }\n  };\n  p.filename = function(v, build) {\n    if (this._parts.urn) {\n      return v === undefined ? '' : this;\n    }\n\n    if (v === undefined || v === true) {\n      if (!this._parts.path || this._parts.path === '/') {\n        return '';\n      }\n\n      var pos = this._parts.path.lastIndexOf('/');\n      var res = this._parts.path.substring(pos+1);\n\n      return v ? URI.decodePathSegment(res) : res;\n    } else {\n      var mutatedDirectory = false;\n\n      if (v.charAt(0) === '/') {\n        v = v.substring(1);\n      }\n\n      if (v.match(/\\.?\\//)) {\n        mutatedDirectory = true;\n      }\n\n      var replace = new RegExp(escapeRegEx(this.filename()) + '$');\n      v = URI.recodePath(v);\n      this._parts.path = this._parts.path.replace(replace, v);\n\n      if (mutatedDirectory) {\n        this.normalizePath(build);\n      } else {\n        this.build(!build);\n      }\n\n      return this;\n    }\n  };\n  p.suffix = function(v, build) {\n    if (this._parts.urn) {\n      return v === undefined ? '' : this;\n    }\n\n    if (v === undefined || v === true) {\n      if (!this._parts.path || this._parts.path === '/') {\n        return '';\n      }\n\n      var filename = this.filename();\n      var pos = filename.lastIndexOf('.');\n      var s, res;\n\n      if (pos === -1) {\n        return '';\n      }\n\n      // suffix may only contain alnum characters (yup, I made this up.)\n      s = filename.substring(pos+1);\n      res = (/^[a-z0-9%]+$/i).test(s) ? s : '';\n      return v ? URI.decodePathSegment(res) : res;\n    } else {\n      if (v.charAt(0) === '.') {\n        v = v.substring(1);\n      }\n\n      var suffix = this.suffix();\n      var replace;\n\n      if (!suffix) {\n        if (!v) {\n          return this;\n        }\n\n        this._parts.path += '.' + URI.recodePath(v);\n      } else if (!v) {\n        replace = new RegExp(escapeRegEx('.' + suffix) + '$');\n      } else {\n        replace = new RegExp(escapeRegEx(suffix) + '$');\n      }\n\n      if (replace) {\n        v = URI.recodePath(v);\n        this._parts.path = this._parts.path.replace(replace, v);\n      }\n\n      this.build(!build);\n      return this;\n    }\n  };\n  p.segment = function(segment, v, build) {\n    var separator = this._parts.urn ? ':' : '/';\n    var path = this.path();\n    var absolute = path.substring(0, 1) === '/';\n    var segments = path.split(separator);\n\n    if (segment !== undefined && typeof segment !== 'number') {\n      build = v;\n      v = segment;\n      segment = undefined;\n    }\n\n    if (segment !== undefined && typeof segment !== 'number') {\n      throw new Error('Bad segment \"' + segment + '\", must be 0-based integer');\n    }\n\n    if (absolute) {\n      segments.shift();\n    }\n\n    if (segment < 0) {\n      // allow negative indexes to address from the end\n      segment = Math.max(segments.length + segment, 0);\n    }\n\n    if (v === undefined) {\n      /*jshint laxbreak: true */\n      return segment === undefined\n        ? segments\n        : segments[segment];\n      /*jshint laxbreak: false */\n    } else if (segment === null || segments[segment] === undefined) {\n      if (isArray(v)) {\n        segments = [];\n        // collapse empty elements within array\n        for (var i=0, l=v.length; i < l; i++) {\n          if (!v[i].length && (!segments.length || !segments[segments.length -1].length)) {\n            continue;\n          }\n\n          if (segments.length && !segments[segments.length -1].length) {\n            segments.pop();\n          }\n\n          segments.push(v[i]);\n        }\n      } else if (v || typeof v === 'string') {\n        if (segments[segments.length -1] === '') {\n          // empty trailing elements have to be overwritten\n          // to prevent results such as /foo//bar\n          segments[segments.length -1] = v;\n        } else {\n          segments.push(v);\n        }\n      }\n    } else {\n      if (v) {\n        segments[segment] = v;\n      } else {\n        segments.splice(segment, 1);\n      }\n    }\n\n    if (absolute) {\n      segments.unshift('');\n    }\n\n    return this.path(segments.join(separator), build);\n  };\n  p.segmentCoded = function(segment, v, build) {\n    var segments, i, l;\n\n    if (typeof segment !== 'number') {\n      build = v;\n      v = segment;\n      segment = undefined;\n    }\n\n    if (v === undefined) {\n      segments = this.segment(segment, v, build);\n      if (!isArray(segments)) {\n        segments = segments !== undefined ? URI.decode(segments) : undefined;\n      } else {\n        for (i = 0, l = segments.length; i < l; i++) {\n          segments[i] = URI.decode(segments[i]);\n        }\n      }\n\n      return segments;\n    }\n\n    if (!isArray(v)) {\n      v = (typeof v === 'string' || v instanceof String) ? URI.encode(v) : v;\n    } else {\n      for (i = 0, l = v.length; i < l; i++) {\n        v[i] = URI.encode(v[i]);\n      }\n    }\n\n    return this.segment(segment, v, build);\n  };\n\n  // mutating query string\n  var q = p.query;\n  p.query = function(v, build) {\n    if (v === true) {\n      return URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);\n    } else if (typeof v === 'function') {\n      var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);\n      var result = v.call(this, data);\n      this._parts.query = URI.buildQuery(result || data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);\n      this.build(!build);\n      return this;\n    } else if (v !== undefined && typeof v !== 'string') {\n      this._parts.query = URI.buildQuery(v, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);\n      this.build(!build);\n      return this;\n    } else {\n      return q.call(this, v, build);\n    }\n  };\n  p.setQuery = function(name, value, build) {\n    var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);\n\n    if (typeof name === 'string' || name instanceof String) {\n      data[name] = value !== undefined ? value : null;\n    } else if (typeof name === 'object') {\n      for (var key in name) {\n        if (hasOwn.call(name, key)) {\n          data[key] = name[key];\n        }\n      }\n    } else {\n      throw new TypeError('URI.addQuery() accepts an object, string as the name parameter');\n    }\n\n    this._parts.query = URI.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);\n    if (typeof name !== 'string') {\n      build = value;\n    }\n\n    this.build(!build);\n    return this;\n  };\n  p.addQuery = function(name, value, build) {\n    var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);\n    URI.addQuery(data, name, value === undefined ? null : value);\n    this._parts.query = URI.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);\n    if (typeof name !== 'string') {\n      build = value;\n    }\n\n    this.build(!build);\n    return this;\n  };\n  p.removeQuery = function(name, value, build) {\n    var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);\n    URI.removeQuery(data, name, value);\n    this._parts.query = URI.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);\n    if (typeof name !== 'string') {\n      build = value;\n    }\n\n    this.build(!build);\n    return this;\n  };\n  p.hasQuery = function(name, value, withinArray) {\n    var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);\n    return URI.hasQuery(data, name, value, withinArray);\n  };\n  p.setSearch = p.setQuery;\n  p.addSearch = p.addQuery;\n  p.removeSearch = p.removeQuery;\n  p.hasSearch = p.hasQuery;\n\n  // sanitizing URLs\n  p.normalize = function() {\n    if (this._parts.urn) {\n      return this\n        .normalizeProtocol(false)\n        .normalizePath(false)\n        .normalizeQuery(false)\n        .normalizeFragment(false)\n        .build();\n    }\n\n    return this\n      .normalizeProtocol(false)\n      .normalizeHostname(false)\n      .normalizePort(false)\n      .normalizePath(false)\n      .normalizeQuery(false)\n      .normalizeFragment(false)\n      .build();\n  };\n  p.normalizeProtocol = function(build) {\n    if (typeof this._parts.protocol === 'string') {\n      this._parts.protocol = this._parts.protocol.toLowerCase();\n      this.build(!build);\n    }\n\n    return this;\n  };\n  p.normalizeHostname = function(build) {\n    if (this._parts.hostname) {\n      if (this.is('IDN') && punycode) {\n        this._parts.hostname = punycode.toASCII(this._parts.hostname);\n      } else if (this.is('IPv6') && IPv6) {\n        this._parts.hostname = IPv6.best(this._parts.hostname);\n      }\n\n      this._parts.hostname = this._parts.hostname.toLowerCase();\n      this.build(!build);\n    }\n\n    return this;\n  };\n  p.normalizePort = function(build) {\n    // remove port of it's the protocol's default\n    if (typeof this._parts.protocol === 'string' && this._parts.port === URI.defaultPorts[this._parts.protocol]) {\n      this._parts.port = null;\n      this.build(!build);\n    }\n\n    return this;\n  };\n  p.normalizePath = function(build) {\n    var _path = this._parts.path;\n    if (!_path) {\n      return this;\n    }\n\n    if (this._parts.urn) {\n      this._parts.path = URI.recodeUrnPath(this._parts.path);\n      this.build(!build);\n      return this;\n    }\n\n    if (this._parts.path === '/') {\n      return this;\n    }\n\n    var _was_relative;\n    var _leadingParents = '';\n    var _parent, _pos;\n\n    // handle relative paths\n    if (_path.charAt(0) !== '/') {\n      _was_relative = true;\n      _path = '/' + _path;\n    }\n\n    // handle relative files (as opposed to directories)\n    if (_path.slice(-3) === '/..' || _path.slice(-2) === '/.') {\n      _path += '/';\n    }\n\n    // resolve simples\n    _path = _path\n      .replace(/(\\/(\\.\\/)+)|(\\/\\.$)/g, '/')\n      .replace(/\\/{2,}/g, '/');\n\n    // remember leading parents\n    if (_was_relative) {\n      _leadingParents = _path.substring(1).match(/^(\\.\\.\\/)+/) || '';\n      if (_leadingParents) {\n        _leadingParents = _leadingParents[0];\n      }\n    }\n\n    // resolve parents\n    while (true) {\n      _parent = _path.indexOf('/..');\n      if (_parent === -1) {\n        // no more ../ to resolve\n        break;\n      } else if (_parent === 0) {\n        // top level cannot be relative, skip it\n        _path = _path.substring(3);\n        continue;\n      }\n\n      _pos = _path.substring(0, _parent).lastIndexOf('/');\n      if (_pos === -1) {\n        _pos = _parent;\n      }\n      _path = _path.substring(0, _pos) + _path.substring(_parent + 3);\n    }\n\n    // revert to relative\n    if (_was_relative && this.is('relative')) {\n      _path = _leadingParents + _path.substring(1);\n    }\n\n    _path = URI.recodePath(_path);\n    this._parts.path = _path;\n    this.build(!build);\n    return this;\n  };\n  p.normalizePathname = p.normalizePath;\n  p.normalizeQuery = function(build) {\n    if (typeof this._parts.query === 'string') {\n      if (!this._parts.query.length) {\n        this._parts.query = null;\n      } else {\n        this.query(URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace));\n      }\n\n      this.build(!build);\n    }\n\n    return this;\n  };\n  p.normalizeFragment = function(build) {\n    if (!this._parts.fragment) {\n      this._parts.fragment = null;\n      this.build(!build);\n    }\n\n    return this;\n  };\n  p.normalizeSearch = p.normalizeQuery;\n  p.normalizeHash = p.normalizeFragment;\n\n  p.iso8859 = function() {\n    // expect unicode input, iso8859 output\n    var e = URI.encode;\n    var d = URI.decode;\n\n    URI.encode = escape;\n    URI.decode = decodeURIComponent;\n    try {\n      this.normalize();\n    } finally {\n      URI.encode = e;\n      URI.decode = d;\n    }\n    return this;\n  };\n\n  p.unicode = function() {\n    // expect iso8859 input, unicode output\n    var e = URI.encode;\n    var d = URI.decode;\n\n    URI.encode = strictEncodeURIComponent;\n    URI.decode = unescape;\n    try {\n      this.normalize();\n    } finally {\n      URI.encode = e;\n      URI.decode = d;\n    }\n    return this;\n  };\n\n  p.readable = function() {\n    var uri = this.clone();\n    // removing username, password, because they shouldn't be displayed according to RFC 3986\n    uri.username('').password('').normalize();\n    var t = '';\n    if (uri._parts.protocol) {\n      t += uri._parts.protocol + '://';\n    }\n\n    if (uri._parts.hostname) {\n      if (uri.is('punycode') && punycode) {\n        t += punycode.toUnicode(uri._parts.hostname);\n        if (uri._parts.port) {\n          t += ':' + uri._parts.port;\n        }\n      } else {\n        t += uri.host();\n      }\n    }\n\n    if (uri._parts.hostname && uri._parts.path && uri._parts.path.charAt(0) !== '/') {\n      t += '/';\n    }\n\n    t += uri.path(true);\n    if (uri._parts.query) {\n      var q = '';\n      for (var i = 0, qp = uri._parts.query.split('&'), l = qp.length; i < l; i++) {\n        var kv = (qp[i] || '').split('=');\n        q += '&' + URI.decodeQuery(kv[0], this._parts.escapeQuerySpace)\n          .replace(/&/g, '%26');\n\n        if (kv[1] !== undefined) {\n          q += '=' + URI.decodeQuery(kv[1], this._parts.escapeQuerySpace)\n            .replace(/&/g, '%26');\n        }\n      }\n      t += '?' + q.substring(1);\n    }\n\n    t += URI.decodeQuery(uri.hash(), true);\n    return t;\n  };\n\n  // resolving relative and absolute URLs\n  p.absoluteTo = function(base) {\n    var resolved = this.clone();\n    var properties = ['protocol', 'username', 'password', 'hostname', 'port'];\n    var basedir, i, p;\n\n    if (this._parts.urn) {\n      throw new Error('URNs do not have any generally defined hierarchical components');\n    }\n\n    if (!(base instanceof URI)) {\n      base = new URI(base);\n    }\n\n    if (!resolved._parts.protocol) {\n      resolved._parts.protocol = base._parts.protocol;\n    }\n\n    if (this._parts.hostname) {\n      return resolved;\n    }\n\n    for (i = 0; (p = properties[i]); i++) {\n      resolved._parts[p] = base._parts[p];\n    }\n\n    if (!resolved._parts.path) {\n      resolved._parts.path = base._parts.path;\n      if (!resolved._parts.query) {\n        resolved._parts.query = base._parts.query;\n      }\n    } else if (resolved._parts.path.substring(-2) === '..') {\n      resolved._parts.path += '/';\n    }\n\n    if (resolved.path().charAt(0) !== '/') {\n      basedir = base.directory();\n      basedir = basedir ? basedir : base.path().indexOf('/') === 0 ? '/' : '';\n      resolved._parts.path = (basedir ? (basedir + '/') : '') + resolved._parts.path;\n      resolved.normalizePath();\n    }\n\n    resolved.build();\n    return resolved;\n  };\n  p.relativeTo = function(base) {\n    var relative = this.clone().normalize();\n    var relativeParts, baseParts, common, relativePath, basePath;\n\n    if (relative._parts.urn) {\n      throw new Error('URNs do not have any generally defined hierarchical components');\n    }\n\n    base = new URI(base).normalize();\n    relativeParts = relative._parts;\n    baseParts = base._parts;\n    relativePath = relative.path();\n    basePath = base.path();\n\n    if (relativePath.charAt(0) !== '/') {\n      throw new Error('URI is already relative');\n    }\n\n    if (basePath.charAt(0) !== '/') {\n      throw new Error('Cannot calculate a URI relative to another relative URI');\n    }\n\n    if (relativeParts.protocol === baseParts.protocol) {\n      relativeParts.protocol = null;\n    }\n\n    if (relativeParts.username !== baseParts.username || relativeParts.password !== baseParts.password) {\n      return relative.build();\n    }\n\n    if (relativeParts.protocol !== null || relativeParts.username !== null || relativeParts.password !== null) {\n      return relative.build();\n    }\n\n    if (relativeParts.hostname === baseParts.hostname && relativeParts.port === baseParts.port) {\n      relativeParts.hostname = null;\n      relativeParts.port = null;\n    } else {\n      return relative.build();\n    }\n\n    if (relativePath === basePath) {\n      relativeParts.path = '';\n      return relative.build();\n    }\n\n    // determine common sub path\n    common = URI.commonPath(relativePath, basePath);\n\n    // If the paths have nothing in common, return a relative URL with the absolute path.\n    if (!common) {\n      return relative.build();\n    }\n\n    var parents = baseParts.path\n      .substring(common.length)\n      .replace(/[^\\/]*$/, '')\n      .replace(/.*?\\//g, '../');\n\n    relativeParts.path = (parents + relativeParts.path.substring(common.length)) || './';\n\n    return relative.build();\n  };\n\n  // comparing URIs\n  p.equals = function(uri) {\n    var one = this.clone();\n    var two = new URI(uri);\n    var one_map = {};\n    var two_map = {};\n    var checked = {};\n    var one_query, two_query, key;\n\n    one.normalize();\n    two.normalize();\n\n    // exact match\n    if (one.toString() === two.toString()) {\n      return true;\n    }\n\n    // extract query string\n    one_query = one.query();\n    two_query = two.query();\n    one.query('');\n    two.query('');\n\n    // definitely not equal if not even non-query parts match\n    if (one.toString() !== two.toString()) {\n      return false;\n    }\n\n    // query parameters have the same length, even if they're permuted\n    if (one_query.length !== two_query.length) {\n      return false;\n    }\n\n    one_map = URI.parseQuery(one_query, this._parts.escapeQuerySpace);\n    two_map = URI.parseQuery(two_query, this._parts.escapeQuerySpace);\n\n    for (key in one_map) {\n      if (hasOwn.call(one_map, key)) {\n        if (!isArray(one_map[key])) {\n          if (one_map[key] !== two_map[key]) {\n            return false;\n          }\n        } else if (!arraysEqual(one_map[key], two_map[key])) {\n          return false;\n        }\n\n        checked[key] = true;\n      }\n    }\n\n    for (key in two_map) {\n      if (hasOwn.call(two_map, key)) {\n        if (!checked[key]) {\n          // two contains a parameter not present in one\n          return false;\n        }\n      }\n    }\n\n    return true;\n  };\n\n  // state\n  p.duplicateQueryParameters = function(v) {\n    this._parts.duplicateQueryParameters = !!v;\n    return this;\n  };\n\n  p.escapeQuerySpace = function(v) {\n    this._parts.escapeQuerySpace = !!v;\n    return this;\n  };\n\n  return URI;\n}));\n\n},{\"./IPv6\":139,\"./SecondLevelDomains\":140,\"./punycode\":142}],142:[function(require,module,exports){\n(function (global){\n/*! http://mths.be/punycode v1.2.3 by @mathias */\n;(function(root) {\n\n\t/** Detect free variables */\n\tvar freeExports = typeof exports == 'object' && exports;\n\tvar freeModule = typeof module == 'object' && module &&\n\t\tmodule.exports == freeExports && module;\n\tvar freeGlobal = typeof global == 'object' && global;\n\tif (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {\n\t\troot = freeGlobal;\n\t}\n\n\t/**\n\t * The `punycode` object.\n\t * @name punycode\n\t * @type Object\n\t */\n\tvar punycode,\n\n\t/** Highest positive signed 32-bit float value */\n\tmaxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1\n\n\t/** Bootstring parameters */\n\tbase = 36,\n\ttMin = 1,\n\ttMax = 26,\n\tskew = 38,\n\tdamp = 700,\n\tinitialBias = 72,\n\tinitialN = 128, // 0x80\n\tdelimiter = '-', // '\\x2D'\n\n\t/** Regular expressions */\n\tregexPunycode = /^xn--/,\n\tregexNonASCII = /[^ -~]/, // unprintable ASCII chars + non-ASCII chars\n\tregexSeparators = /\\x2E|\\u3002|\\uFF0E|\\uFF61/g, // RFC 3490 separators\n\n\t/** Error messages */\n\terrors = {\n\t\t'overflow': 'Overflow: input needs wider integers to process',\n\t\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t\t'invalid-input': 'Invalid input'\n\t},\n\n\t/** Convenience shortcuts */\n\tbaseMinusTMin = base - tMin,\n\tfloor = Math.floor,\n\tstringFromCharCode = String.fromCharCode,\n\n\t/** Temporary variable */\n\tkey;\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/**\n\t * A generic error utility function.\n\t * @private\n\t * @param {String} type The error type.\n\t * @returns {Error} Throws a `RangeError` with the applicable error message.\n\t */\n\tfunction error(type) {\n\t\tthrow RangeError(errors[type]);\n\t}\n\n\t/**\n\t * A generic `Array#map` utility function.\n\t * @private\n\t * @param {Array} array The array to iterate over.\n\t * @param {Function} callback The function that gets called for every array\n\t * item.\n\t * @returns {Array} A new array of values returned by the callback function.\n\t */\n\tfunction map(array, fn) {\n\t\tvar length = array.length;\n\t\twhile (length--) {\n\t\t\tarray[length] = fn(array[length]);\n\t\t}\n\t\treturn array;\n\t}\n\n\t/**\n\t * A simple `Array#map`-like wrapper to work with domain name strings.\n\t * @private\n\t * @param {String} domain The domain name.\n\t * @param {Function} callback The function that gets called for every\n\t * character.\n\t * @returns {Array} A new string of characters returned by the callback\n\t * function.\n\t */\n\tfunction mapDomain(string, fn) {\n\t\treturn map(string.split(regexSeparators), fn).join('.');\n\t}\n\n\t/**\n\t * Creates an array containing the numeric code points of each Unicode\n\t * character in the string. While JavaScript uses UCS-2 internally,\n\t * this function will convert a pair of surrogate halves (each of which\n\t * UCS-2 exposes as separate characters) into a single code point,\n\t * matching UTF-16.\n\t * @see `punycode.ucs2.encode`\n\t * @see <http://mathiasbynens.be/notes/javascript-encoding>\n\t * @memberOf punycode.ucs2\n\t * @name decode\n\t * @param {String} string The Unicode input string (UCS-2).\n\t * @returns {Array} The new array of code points.\n\t */\n\tfunction ucs2decode(string) {\n\t\tvar output = [],\n\t\t    counter = 0,\n\t\t    length = string.length,\n\t\t    value,\n\t\t    extra;\n\t\twhile (counter < length) {\n\t\t\tvalue = string.charCodeAt(counter++);\n\t\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t\t// high surrogate, and there is a next character\n\t\t\t\textra = string.charCodeAt(counter++);\n\t\t\t\tif ((extra & 0xFC00) == 0xDC00) { // low surrogate\n\t\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t\t} else {\n\t\t\t\t\t// unmatched surrogate; only append this code unit, in case the next\n\t\t\t\t\t// code unit is the high surrogate of a surrogate pair\n\t\t\t\t\toutput.push(value);\n\t\t\t\t\tcounter--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toutput.push(value);\n\t\t\t}\n\t\t}\n\t\treturn output;\n\t}\n\n\t/**\n\t * Creates a string based on an array of numeric code points.\n\t * @see `punycode.ucs2.decode`\n\t * @memberOf punycode.ucs2\n\t * @name encode\n\t * @param {Array} codePoints The array of numeric code points.\n\t * @returns {String} The new Unicode string (UCS-2).\n\t */\n\tfunction ucs2encode(array) {\n\t\treturn map(array, function(value) {\n\t\t\tvar output = '';\n\t\t\tif (value > 0xFFFF) {\n\t\t\t\tvalue -= 0x10000;\n\t\t\t\toutput += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n\t\t\t\tvalue = 0xDC00 | value & 0x3FF;\n\t\t\t}\n\t\t\toutput += stringFromCharCode(value);\n\t\t\treturn output;\n\t\t}).join('');\n\t}\n\n\t/**\n\t * Converts a basic code point into a digit/integer.\n\t * @see `digitToBasic()`\n\t * @private\n\t * @param {Number} codePoint The basic numeric code point value.\n\t * @returns {Number} The numeric value of a basic code point (for use in\n\t * representing integers) in the range `0` to `base - 1`, or `base` if\n\t * the code point does not represent a value.\n\t */\n\tfunction basicToDigit(codePoint) {\n\t\tif (codePoint - 48 < 10) {\n\t\t\treturn codePoint - 22;\n\t\t}\n\t\tif (codePoint - 65 < 26) {\n\t\t\treturn codePoint - 65;\n\t\t}\n\t\tif (codePoint - 97 < 26) {\n\t\t\treturn codePoint - 97;\n\t\t}\n\t\treturn base;\n\t}\n\n\t/**\n\t * Converts a digit/integer into a basic code point.\n\t * @see `basicToDigit()`\n\t * @private\n\t * @param {Number} digit The numeric value of a basic code point.\n\t * @returns {Number} The basic code point whose value (when used for\n\t * representing integers) is `digit`, which needs to be in the range\n\t * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n\t * used; else, the lowercase form is used. The behavior is undefined\n\t * if `flag` is non-zero and `digit` has no uppercase form.\n\t */\n\tfunction digitToBasic(digit, flag) {\n\t\t//  0..25 map to ASCII a..z or A..Z\n\t\t// 26..35 map to ASCII 0..9\n\t\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n\t}\n\n\t/**\n\t * Bias adaptation function as per section 3.4 of RFC 3492.\n\t * http://tools.ietf.org/html/rfc3492#section-3.4\n\t * @private\n\t */\n\tfunction adapt(delta, numPoints, firstTime) {\n\t\tvar k = 0;\n\t\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\t\tdelta += floor(delta / numPoints);\n\t\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\t\tdelta = floor(delta / baseMinusTMin);\n\t\t}\n\t\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n\t}\n\n\t/**\n\t * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n\t * symbols.\n\t * @memberOf punycode\n\t * @param {String} input The Punycode string of ASCII-only symbols.\n\t * @returns {String} The resulting string of Unicode symbols.\n\t */\n\tfunction decode(input) {\n\t\t// Don't use UCS-2\n\t\tvar output = [],\n\t\t    inputLength = input.length,\n\t\t    out,\n\t\t    i = 0,\n\t\t    n = initialN,\n\t\t    bias = initialBias,\n\t\t    basic,\n\t\t    j,\n\t\t    index,\n\t\t    oldi,\n\t\t    w,\n\t\t    k,\n\t\t    digit,\n\t\t    t,\n\t\t    length,\n\t\t    /** Cached calculation results */\n\t\t    baseMinusT;\n\n\t\t// Handle the basic code points: let `basic` be the number of input code\n\t\t// points before the last delimiter, or `0` if there is none, then copy\n\t\t// the first basic code points to the output.\n\n\t\tbasic = input.lastIndexOf(delimiter);\n\t\tif (basic < 0) {\n\t\t\tbasic = 0;\n\t\t}\n\n\t\tfor (j = 0; j < basic; ++j) {\n\t\t\t// if it's not a basic code point\n\t\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\t\terror('not-basic');\n\t\t\t}\n\t\t\toutput.push(input.charCodeAt(j));\n\t\t}\n\n\t\t// Main decoding loop: start just after the last delimiter if any basic code\n\t\t// points were copied; start at the beginning otherwise.\n\n\t\tfor (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\n\n\t\t\t// `index` is the index of the next character to be consumed.\n\t\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t\t// which gets added to `i`. The overflow checking is easier\n\t\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t\t// value at the end to obtain `delta`.\n\t\t\tfor (oldi = i, w = 1, k = base; /* no condition */; k += base) {\n\n\t\t\t\tif (index >= inputLength) {\n\t\t\t\t\terror('invalid-input');\n\t\t\t\t}\n\n\t\t\t\tdigit = basicToDigit(input.charCodeAt(index++));\n\n\t\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\ti += digit * w;\n\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\n\t\t\t\tif (digit < t) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tbaseMinusT = base - t;\n\t\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tw *= baseMinusT;\n\n\t\t\t}\n\n\t\t\tout = output.length + 1;\n\t\t\tbias = adapt(i - oldi, out, oldi == 0);\n\n\t\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t\t// incrementing `n` each time, so we'll fix that now:\n\t\t\tif (floor(i / out) > maxInt - n) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tn += floor(i / out);\n\t\t\ti %= out;\n\n\t\t\t// Insert `n` at position `i` of the output\n\t\t\toutput.splice(i++, 0, n);\n\n\t\t}\n\n\t\treturn ucs2encode(output);\n\t}\n\n\t/**\n\t * Converts a string of Unicode symbols to a Punycode string of ASCII-only\n\t * symbols.\n\t * @memberOf punycode\n\t * @param {String} input The string of Unicode symbols.\n\t * @returns {String} The resulting Punycode string of ASCII-only symbols.\n\t */\n\tfunction encode(input) {\n\t\tvar n,\n\t\t    delta,\n\t\t    handledCPCount,\n\t\t    basicLength,\n\t\t    bias,\n\t\t    j,\n\t\t    m,\n\t\t    q,\n\t\t    k,\n\t\t    t,\n\t\t    currentValue,\n\t\t    output = [],\n\t\t    /** `inputLength` will hold the number of code points in `input`. */\n\t\t    inputLength,\n\t\t    /** Cached calculation results */\n\t\t    handledCPCountPlusOne,\n\t\t    baseMinusT,\n\t\t    qMinusT;\n\n\t\t// Convert the input in UCS-2 to Unicode\n\t\tinput = ucs2decode(input);\n\n\t\t// Cache the length\n\t\tinputLength = input.length;\n\n\t\t// Initialize the state\n\t\tn = initialN;\n\t\tdelta = 0;\n\t\tbias = initialBias;\n\n\t\t// Handle the basic code points\n\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\tcurrentValue = input[j];\n\t\t\tif (currentValue < 0x80) {\n\t\t\t\toutput.push(stringFromCharCode(currentValue));\n\t\t\t}\n\t\t}\n\n\t\thandledCPCount = basicLength = output.length;\n\n\t\t// `handledCPCount` is the number of code points that have been handled;\n\t\t// `basicLength` is the number of basic code points.\n\n\t\t// Finish the basic string - if it is not empty - with a delimiter\n\t\tif (basicLength) {\n\t\t\toutput.push(delimiter);\n\t\t}\n\n\t\t// Main encoding loop:\n\t\twhile (handledCPCount < inputLength) {\n\n\t\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t\t// larger one:\n\t\t\tfor (m = maxInt, j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\t\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\t\tm = currentValue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t\t// but guard against overflow\n\t\t\thandledCPCountPlusOne = handledCPCount + 1;\n\t\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\t\tn = m;\n\n\t\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\n\t\t\t\tif (currentValue < n && ++delta > maxInt) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tif (currentValue == n) {\n\t\t\t\t\t// Represent delta as a generalized variable-length integer\n\t\t\t\t\tfor (q = delta, k = base; /* no condition */; k += base) {\n\t\t\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\t\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tqMinusT = q - t;\n\t\t\t\t\t\tbaseMinusT = base - t;\n\t\t\t\t\t\toutput.push(\n\t\t\t\t\t\t\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\n\t\t\t\t\t\t);\n\t\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t\t}\n\n\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n\t\t\t\t\tdelta = 0;\n\t\t\t\t\t++handledCPCount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t++delta;\n\t\t\t++n;\n\n\t\t}\n\t\treturn output.join('');\n\t}\n\n\t/**\n\t * Converts a Punycode string representing a domain name to Unicode. Only the\n\t * Punycoded parts of the domain name will be converted, i.e. it doesn't\n\t * matter if you call it on a string that has already been converted to\n\t * Unicode.\n\t * @memberOf punycode\n\t * @param {String} domain The Punycode domain name to convert to Unicode.\n\t * @returns {String} The Unicode representation of the given Punycode\n\t * string.\n\t */\n\tfunction toUnicode(domain) {\n\t\treturn mapDomain(domain, function(string) {\n\t\t\treturn regexPunycode.test(string)\n\t\t\t\t? decode(string.slice(4).toLowerCase())\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/**\n\t * Converts a Unicode string representing a domain name to Punycode. Only the\n\t * non-ASCII parts of the domain name will be converted, i.e. it doesn't\n\t * matter if you call it with a domain that's already in ASCII.\n\t * @memberOf punycode\n\t * @param {String} domain The domain name to convert, as a Unicode string.\n\t * @returns {String} The Punycode representation of the given domain name.\n\t */\n\tfunction toASCII(domain) {\n\t\treturn mapDomain(domain, function(string) {\n\t\t\treturn regexNonASCII.test(string)\n\t\t\t\t? 'xn--' + encode(string)\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/** Define the public API */\n\tpunycode = {\n\t\t/**\n\t\t * A string representing the current Punycode.js version number.\n\t\t * @memberOf punycode\n\t\t * @type String\n\t\t */\n\t\t'version': '1.2.3',\n\t\t/**\n\t\t * An object of methods to convert from JavaScript's internal character\n\t\t * representation (UCS-2) to Unicode code points, and back.\n\t\t * @see <http://mathiasbynens.be/notes/javascript-encoding>\n\t\t * @memberOf punycode\n\t\t * @type Object\n\t\t */\n\t\t'ucs2': {\n\t\t\t'decode': ucs2decode,\n\t\t\t'encode': ucs2encode\n\t\t},\n\t\t'decode': decode,\n\t\t'encode': encode,\n\t\t'toASCII': toASCII,\n\t\t'toUnicode': toUnicode\n\t};\n\n\t/** Expose `punycode` */\n\t// Some AMD build optimizers, like r.js, check for specific condition patterns\n\t// like the following:\n\tif (\n\t\ttypeof define == 'function' &&\n\t\ttypeof define.amd == 'object' &&\n\t\tdefine.amd\n\t) {\n\t\tdefine(function() {\n\t\t\treturn punycode;\n\t\t});\n\t}\telse if (freeExports && !freeExports.nodeType) {\n\t\tif (freeModule) { // in Node.js or RingoJS v0.8.0+\n\t\t\tfreeModule.exports = punycode;\n\t\t} else { // in Narwhal or RingoJS v0.7.0-\n\t\t\tfor (key in punycode) {\n\t\t\t\tpunycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);\n\t\t\t}\n\t\t}\n\t} else { // in Rhino or a web browser\n\t\troot.punycode = punycode;\n\t}\n\n}(this));\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],143:[function(require,module,exports){\n(function (Buffer){\nvar Q = require(\"q\");\nvar qs = require(\"qs\");\n\nmodule.exports = exports = function (app) {\n  var common = app.extensions.common;\n  var select = common.select;\n\n  var oms = app.extensions.oms = {};\n  var omsDeferred;\n\n  function createErrorFromContent(content) {\n    var message = createErrorMessage(content.location, content.data.toString());\n    return new Error(message);\n  }\n\n  function createErrorMessage(location, data) {\n    var message = [];\n    message.push(\"URL:\");\n    message.push(location);\n    message.push(\"CONTENT:\");\n    message.push(data ? data.toString() : \"\");\n    return message.join(\"\\n\");\n  }\n\n  function omsFinishing(result) {\n    var doneScope = \"http://bestbuy.com/retail/oms/order/done/\";\n    if (!result.element.dataset.contentRealm) return result;\n    if (!app.extensions.common.scopeIncludesRealm(doneScope, result.element.dataset.contentRealm)) return result;\n\n    var omsResult = {\n      orderStatesUrl: \"\",\n      orderDetailsUrl: \"\"\n    };\n\n    var statesUrlElement = select(\"[data-lynx-hints~='http://bestbuy.com/retail/oms/order/done/states-link'],a[data-lynx-name=statesLink],a[data-lynx-name=statesUrl]\")(result.element).first();\n\n    if (!statesUrlElement) {\n      omsDeferred.reject(createErrorFromContent(result.content));\n      return result;\n    }\n\n    omsResult.orderStatesUrl = statesUrlElement.pathname + statesUrlElement.search + statesUrlElement.hash;\n\n    function parseLynx(content) {\n      return app.extensions.lynx.parsing(content)\n        .then(function (lynxDoc) {\n          return {\n            content: content,\n            document: lynxDoc\n          };\n        });\n    }\n\n    function resolveOmsDeferred(parseResult) {\n      var orderDetailsLink = parseResult.document.root.find(function (lynxNode) {\n        return lynxNode.hasHint(\"http://bestbuy.com/retail/oms/order/states/data-link\") || lynxNode.name === \"dataLink\";\n      });\n\n      if (!orderDetailsLink || !orderDetailsLink.value || !orderDetailsLink.value.href) {\n        omsDeferred.reject(createErrorFromContent(parseResult.content));\n        return result;\n      }\n\n      omsResult.orderDetailsUrl = orderDetailsLink.value.href;\n      omsDeferred.resolve(omsResult);\n\n      return result;\n    }\n\n    return app.transferring(statesUrlElement.href)\n      .then(parseLynx)\n      .then(resolveOmsDeferred)\n      .fail(function (err) {\n        err.message = createErrorMessage(omsResult.orderStatesUrl, err.message);\n        omsDeferred.reject(err);\n        // always restore finishing function result\n        return result;\n      });\n  }\n\n  var omsIntegrationBranch = app.finishing.composite(function (result) {\n    return !!omsDeferred;\n  });\n  omsIntegrationBranch.add(omsFinishing);\n  app.finishing.add(omsIntegrationBranch);\n\n  function submitFormData(dataObj) {\n    return function submitFormDataWorker(lynxDoc) {\n      var submitControl = lynxDoc.root.find(function (lynxNode) {\n        return lynxNode.hasHint(\"submit\") && lynxNode.value.method === \"POST\";\n      });\n\n      var sendUrl = lynxDoc.resolveURI(submitControl.value.action);\n\n      var bodyData = qs.stringify(dataObj);\n      var body = {\n        data: new Buffer(bodyData),\n        type: \"application/x-www-form-urlencoded\"\n      };\n\n      var options = {\n        method: submitControl.value.method,\n        body: body\n      };\n\n      return app.send(sendUrl, options);\n    };\n  }\n\n  oms.createOrder = function omsCreateOrder(startUrl, order) {\n    omsDeferred = Q.defer();\n\n    if (!startUrl) {\n      omsDeferred.reject(new Error(\"The 'startUrl' parameter is required.\"));\n      return omsDeferred.promise;\n    }\n\n    if (!order) {\n      omsDeferred.reject(new Error(\"The 'order' parameter is required.\"));\n      return omsDeferred.promise;\n    }\n\n    startUrl = app.resolveURI(document.location.href, startUrl);\n\n    app.transferring(startUrl)\n      .then(app.extensions.lynx.parsing)\n      .then(submitFormData(order));\n\n    return omsDeferred.promise;\n  };\n\n  oms.modifyOrder = function omsModifyOrder(orderStatesUrl) {\n    return Q().then(function () {\n      if (!orderStatesUrl) throw new Error(\"The 'orderStatesUrl' parameter is required.\");\n      return mockResult;\n    });\n  };\n\n  oms.validateOrder = function omsValidateOrder(orderStatesUrl) {\n    return Q().then(function () {\n      if (!orderStatesUrl) throw new Error(\"The 'orderStatesUrl' parameter is required.\");\n      return mockResult;\n    });\n  };\n\n  oms.addLines = function omsAddLines(orderStatesUrl, orderLines) {\n    return Q().then(function () {\n      if (!orderStatesUrl || !orderLines) throw new Error(\"The 'orderStatesUrl' and orderLines parameters are required.\");\n      return mockResult;\n    });\n  };\n\n  oms.deleteLines = function omsDeleteLines(orderStatesUrl, orderLines) {\n    return Q().then(function () {\n      if (!orderStatesUrl || !orderLines) throw new Error(\"The 'orderStatesUrl' and 'orderLines' parameters are required.\");\n      return mockResult;\n    });\n  };\n\n  oms.updatePurchaser = function omsUpdatePurchaser(orderStatesUrl, purchaser) {\n    return Q().then(function () {\n      if (!orderStatesUrl || !purchaser) throw new Error(\"The 'orderStatesUrl' and 'purchaser' parameters are required.\");\n      return mockResult;\n    });\n  };\n\n  return app;\n};\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"buffer\":80,\"q\":134,\"qs\":135}],144:[function(require,module,exports){\nmodule.exports = exports = function (app) {\n  var bem = app.extensions.bem;\n  var composite = app.extensions.common.finishing.composite;\n  var lynx = app.extensions.lynx;\n  var ux = app.extensions.ux;\n  \n  function optionsRoleChanged(result) {\n    if (result.state === \"options\") {\n      result = app.extensions.common.finishing.applyOptionsKeyboardBehavior(\"._option\", \"._option--selected\")(result);\n      result = bem.mixin(\"_options\")(result);\n      return tryToConvertOptionsToSelect(result);\n    }\n    \n    if (result.element.removeOptionsKeyboardBehavior) {\n      result.element.removeOptionsKeyboardBehavior();\n    }\n    \n    tryToRemoveSelect(result);\n    bem.remove(\"_options\")(result);\n    \n    return result;\n  }\n  \n  function copyElementsAndStates(sourceElement) {\n    var markerAndElementExp = /^-|__/;\n    return function (result) {  \n      Array.prototype.forEach.call(sourceElement.classList, function (className) {\n          if (markerAndElementExp.test(className)) {\n            result.element.classList.add(className);\n          }\n      });\n      \n      return result;\n    };\n  }\n  \n  function tryToRemoveSelect(result) {\n    var endsWithSelection = /Selection$/;\n    if (!endsWithSelection.test(result.element.dataset.lynxName)) return result;\n    \n    var optionsElement = result.element;\n    ux.visibilityChanged(optionsElement);\n    \n    var selectElement = app.extensions.common.findNearestElement(optionsElement, function (elem) {\n      return optionsElement.dataset.lynxName === elem.dataset.lynxOptionsSelectFor;\n    });\n    \n    selectElement.parentElement.removeChild(selectElement);\n    \n    var inputElement = app.extensions.common.findNearestElement(optionsElement, function (elem) {\n      return elem.dataset.lynxName === optionsElement.dataset.lynxOptionsFor;\n    });\n    \n    inputElement.disabled = false;\n    \n    return result;\n  }\n  \n  function tryToConvertOptionsToSelect(result) {\n    var endsWithSelection = /Selection$/;\n    if (!endsWithSelection.test(result.element.dataset.lynxName)) return result;\n    \n    var optionsElement = result.element;\n    \n    var selectElement = document.createElement(\"select\");\n    var selectResult = { element: selectElement };\n    \n    composite(\n      bem.block(\"input\"),\n      bem.modifier(\"input--select\"),\n      copyElementsAndStates(optionsElement)\n    )(selectResult).then(function () {\n      ux.setVisibility(\"hidden\")(result);\n    });\n    \n    selectElement.appendChild(document.createElement(\"option\"));\n    selectElement.dataset.lynxOptionsSelectFor = optionsElement.dataset.lynxName;\n    optionsElement.dataset.lynxOptionsHasSelect = true;\n    optionsElement.parentElement.insertBefore(selectElement, optionsElement);\n    \n    var inputElement = app.extensions.common.findNearestElement(optionsElement, function (elem) {\n      return elem.dataset.lynxName === optionsElement.dataset.lynxOptionsFor;\n    });\n    \n    inputElement.disabled = true;\n    selectElement.name = inputElement.name;\n    \n    selectElement.addEventListener(\"change\", function () {\n      var selectOptionElement = selectElement.options[selectElement.selectedIndex];\n      var optionElement;\n      \n      if (selectOptionElement.dataset.lynxOptionsOptionFor) {\n        // click the related option\n        var selector = \"[data-lynx-option=true][data-lynx-name='\";\n        selector += selectOptionElement.dataset.lynxOptionsOptionFor;\n        selector += \"']\";\n        \n        optionElement = app.extensions.common.select(selector)(optionsElement).first();\n      }\n      else {\n        // click the currently selected option b/c the empty option was selected\n        optionElement = app.extensions.common.select(\"[data-lynx-option-selected=true]\")(optionsElement).first();\n      }\n      \n      optionElement.click();\n    });\n    \n    return result;\n  }\n  \n  function optionRoleChanged(result) {\n    if (result.state === \"option\") {\n      result = bem.mixin(\"_option\")(result);\n      return tryToConvertOptionToSelectOption(result);\n    }\n    \n    bem.remove(\"_option\")(result);\n    return result;\n  }\n  \n  function tryToConvertOptionToSelectOption(result) {\n    var optionElement = result.element;\n    \n    var optionsElement = app.extensions.common.findNearestElement(optionElement, function (elem) {\n      return elem.dataset.lynxOptionsFor;\n    });\n    \n    if (!optionsElement.dataset.lynxOptionsHasSelect) return result;\n    \n    var selectElement = app.extensions.common.findNearestElement(optionsElement, function (elem) {\n      return optionsElement.dataset.lynxName === elem.dataset.lynxOptionsSelectFor;\n    });\n    \n    var valueElement = app.extensions.common.select(\"[data-lynx-option-value]\")(optionElement).first();\n    var selectOptionElement;\n    \n    if (valueElement.textContent === \"\") {\n      selectOptionElement = app.extensions.common.select(\"option[value=''],option:not([value])\")(selectElement).first();\n    }\n    else {\n      selectOptionElement = document.createElement(\"option\");\n      selectElement.appendChild(selectOptionElement);\n    }\n    \n    var labelElement = app.extensions.lynx.findLabelElement(optionElement);\n    selectOptionElement.text = labelElement && labelElement.textContent;\n    selectOptionElement.value = valueElement.textContent;\n    selectOptionElement.selected = optionElement.dataset.lynxOptionSelected === \"true\";\n    selectOptionElement.dataset.lynxOptionsOptionFor = optionElement.dataset.lynxName;  \n    \n    return result;\n  }\n  \n  function optionSelectedChanged(result) {\n    if (result.state === \"selected\") {\n      return bem.modifier(\"_option--selected\")(result);\n    }\n    \n    bem.remove(\"_option--selected\")(result);\n    \n    return result;\n  }\n  \n  var optionsCallbacks = lynx.finishing.optionsCallbacks = {\n    optionsRoleChanged: optionsRoleChanged,\n    optionRoleChanged: optionRoleChanged,\n    optionSelectedChanged: optionSelectedChanged\n  };\n  \n  app.getApplicationElement().addEventListener(\"jsua\", function (evt) {\n    if (evt.state === \"ready\") {\n      lynx.finishing.applyOptionsBehavior(optionsCallbacks)({ element: app.getApplicationElement() });\n    }\n  });\n};\n\n},{}],145:[function(require,module,exports){\nmodule.exports = exports = function (app) {\n  var uxConfig = app.extensions.uxConfiguration;\n  \n  var retailScope = app.finishing.scope(\"http://bestbuy.com/retail/\");\n  app.finishing.add(retailScope);\n  uxConfig.configureYouAreHere(retailScope);\n  uxConfig.configureMarkersAsOptions(retailScope);\n  \n  // uxConfig.configureSectionBlock(retailScope, \"[data-lynx-hints~='http://bestbuy.com/retail/ux-patterns/section/primary']\", \"section--primary\");\n  uxConfig.configureAttributeList(retailScope, \"[data-lynx-hints~='http://bestbuy.com/retail/ux-patterns/attribute-list']\");\n  uxConfig.configureControlsSectionBlock\n  (retailScope, \"[data-lynx-hints~='http://bestbuy.com/retail/ux-patterns/control-section']\");\n  \n  uxConfig.configureBannerBlock(retailScope);\n  uxConfig.configureHeaderBlock(retailScope);\n  uxConfig.configureListingBlock(retailScope);\n  uxConfig.configureInputBlock(retailScope);\n  uxConfig.configureInputSectionBlock(retailScope);\n  uxConfig.configureComplementBlock(retailScope);\n  uxConfig.configureControlsSectionBlock(retailScope);\n  uxConfig.configureFormSectionBlock(retailScope);\n  uxConfig.configureButtonBlock(retailScope);\n  uxConfig.configureMainSection(retailScope);\n  uxConfig.configureSectionBlock(retailScope, \"[data-lynx-hints~=section]\");\n  uxConfig.configureTextBlock(retailScope);\n  uxConfig.configureLinkBlock(retailScope);\n  uxConfig.configureLinkMixin(retailScope);\n  uxConfig.configureFixedLayout(retailScope);\n};\n\n},{}],146:[function(require,module,exports){\nvar Q = require(\"q\");\n\nmodule.exports = exports = function () {\n  require(\"./polyfills\");\n  var app = require(\"jsua\")();\n\n  app.setApplicationElement(document.body);\n\n  // transferring module configuration\n  // app.transferring = f(url, options) -> (content)\n  var http = app.extensions.http = require(\"jsua-http-transferring\")(app);\n  app.transferring.add(\"http\", http.transferring);\n  app.transferring.add(\"https\", http.transferring);\n  var data = app.extensions.data = require(\"jsua-data-transferring\")(app);\n  app.transferring.add(\"data\", data.transferring);\n\n  // encoding module configuration\n  // app.encoding(formdata, enctype) -> (data,type)\n  var urlEncoding = app.extensions.urlEncoding = require(\"jsua-url-encoding\")(app);\n  app.encoding.add(\"application/x-www-form-urlencoded\", urlEncoding.encoding);\n\n\n  // common module configuration\n  var common = app.extensions.common = require(\"jsua-common\")(app);\n  common.replaceElementAndPreserveAttributes.addPreservedAttribute(\"lynxName\");\n  common.replaceElementAndPreserveAttributes.addPreservedAttribute(\"lynxOptionsFor\");\n  common.css.namespace = \"jsua-\";\n\n  // rendering module configuration\n  // app.rendering = f(content) -> (content, element)\n  var lynx = app.extensions.lynx = require(\"jsua-lynx\")(app);\n\n  lynx.rendering.add(\"container\", lynx.nodeRendering.container);\n  lynx.rendering.add(\"container\", lynx.nodeRendering.containerInput, true);\n  lynx.rendering.add(\"array\", lynx.nodeRendering.container);\n  lynx.rendering.add(\"object\", lynx.nodeRendering.container);\n  lynx.rendering.add(\"content\", lynx.nodeRendering.content);\n  lynx.rendering.add(\"image\", lynx.nodeRendering.image);\n  lynx.rendering.add(\"form\", lynx.nodeRendering.form);\n  lynx.rendering.add(\"submit\", lynx.nodeRendering.submit);\n  lynx.rendering.add(\"link\", lynx.nodeRendering.link);\n  lynx.rendering.add(\"text\", lynx.nodeRendering.text);\n  lynx.rendering.add(\"text\", lynx.nodeRendering.textInput, true);\n\n  var contentSet = require(\"./extensions/http-bestbuy-com-retail/content-set\")(app);\n  lynx.rendering.add(\"http://bestbuy.com/retail/content-set\", contentSet.lynx.rendering);\n\n  lynx.rendering.after(lynx.afterNodeRendering.setName);\n  lynx.rendering.after(lynx.afterNodeRendering.setHints);\n  lynx.rendering.after(lynx.afterNodeRendering.setVisibility);\n  lynx.rendering.after(lynx.afterNodeRendering.setScope);\n  lynx.rendering.after(lynx.afterNodeRendering.setOptions);\n  lynx.rendering.after(lynx.afterNodeRendering.link);\n  lynx.rendering.after(lynx.afterNodeRendering.submit);\n  lynx.rendering.after(lynx.afterNodeRendering.setValidation);\n  lynx.rendering.after(lynx.afterNodeRendering.setLabeledBy);\n  lynx.rendering.after(lynx.afterNodeRendering.setFormatted);\n  lynx.rendering.after(lynx.afterNodeRendering.wrapSectionBody);\n  var marker = require(\"./extensions/http-uncategorized-marker\")(app);\n  lynx.rendering.after(marker.lynx.afterNodeRendering.setMarkerFor);\n\n\n  app.rendering.add(\"application/lynx+json\", lynx.rendering);\n\n  var text = app.extensions.text = require(\"jsua-text-rendering\")(app);\n  app.rendering.add(\"text/plain\", text.rendering);\n\n  var markdown = app.extensions.markdown = require(\"jsua-markdown-rendering\")(app);\n  app.rendering.add(\"text/markdown\", markdown.rendering);\n\n  var image = app.extensions.image = require(\"jsua-image-rendering\")(app);\n  app.rendering.add(\"image/*\", image.rendering);\n\n  var html = app.extensions.html = require(\"jsua-html-rendering\")(app);\n  app.rendering.add(\"text/html\", html.rendering);\n  app.rendering.add(\"application/xhtml+xml\", html.rendering);\n\n  var generic = app.extensions.generic = require(\"jsua-generic-rendering\")(app);\n  app.rendering.add(\"*/*\", generic.rendering);\n\n  app.rendering.after(common.afterRendering.setContentContext);\n\n  // Finishing\n  var bem = app.extensions.bem = require(\"jsua-bem\")(app);\n  var ux = app.extensions.ux = require(\"./ux-patterns\")(app);\n  var uxConfig = app.extensions.uxConfiguration = require(\"./ux-configuration\")(app);\n\n\n  app.finishing.add(app.extensions.lynx.finishing.applyValidationBehavior(ux.visibilityChanged, ux.validityChanged));\n\n\n  app.finishing.add(app.extensions.common.finishing.applyLinkBehavior);\n  app.finishing.add(app.extensions.common.finishing.applySubmitBehavior);\n\n  app.finishing.add(app.extensions.common.finishing.attachElementByScope);\n\n  app.finishing.add(require(\"./extensions/attach-view\")(app).finishing);\n\n  var select = common.select;\n  var apply = common.finishing.apply;\n  var composite = common.finishing.composite;\n\n\n  function configureValidation(finishing) {\n    finishing.add(app.extensions.lynx.finishing.showHideValidationConstraintContentForAll(ux.visibilityChanged));\n    finishing.add(apply(\"[data-lynx-validation-state]\", ux.validityState));\n\n    finishing.add(apply(\".input[data-lynx-validation-state]\", function (result) {\n\n      var constraints = [];\n      app.extensions.lynx.forEachValidationConstraint(result.element, function (constraint) {\n        constraints.push(constraint);\n      });\n\n      function setFocusForConstraint(constraint, inputHasFocus) {\n        [\"valid\", \"invalid\", \"unknown\"].forEach(function (name) {\n          if (!(name in constraint)) return;\n\n          var contentElement = app.extensions.common.findNearestElement(result.element, function (element) {\n            return element.dataset.lynxName === constraint[name];\n          });\n\n          if (!contentElement) return;\n\n          if (inputHasFocus) bem.state(\"-input-has-focus\")({element: contentElement});\n          else bem.remove(\"-input-has-focus\")({element: contentElement});\n        });\n      }\n\n      result.element.addEventListener(\"focus\", function () {\n        constraints.forEach(function (constraint) {\n          setFocusForConstraint(constraint, true);\n        });\n      });\n\n      result.element.addEventListener(\"blur\", function () {\n        constraints.forEach(function (constraint) {\n          setFocusForConstraint(constraint, false);\n        });\n      });\n\n      return result;\n    }));\n\n    finishing.add(apply(\"[data-lynx-validation-content-for-state]\", ux.setValidationContentForStates));\n  }\n\n  function configureLabeling(finishing) {\n    finishing.add(apply(\".input[data-lynx-labeled-by]\", function (result) {\n      var labelElement = app.extensions.lynx.findLabelElement(result.element);\n      if (!labelElement) return result;\n\n      labelElement.addEventListener(\"click\", function () {\n        result.element.focus();\n      });\n\n      return result;\n    }));\n  }\n\n  function configureVisibility(finishing) {\n    finishing.add(apply(\"[data-lynx-visibility]\", ux.visibilityState));\n  }\n\n  function configureFocus(finishing) {\n    finishing.add(apply(select.first(select.concat(\".input.-invalid\", \".input:not(.-disabled)\", \".button\")), function (result) {\n      result.element.focus();\n      return result;\n    }));\n  }\n\n  function configureContainerInput(finishing) {\n    finishing.add(apply(\"[data-lynx-hints~='container'][data-lynx-input]\", app.extensions.lynx.finishing.applyContainerInputBehavior));\n  }\n\n  function configureFormatted(finishing) {\n    finishing.add(apply(\"[data-lynx-validation-formatted]\", app.extensions.lynx.finishing.applyFormattedBehavior));\n  }\n\n  app.getApplicationElement().addEventListener(\"jsua\", function (evt) {\n    var applicationElement = app.getApplicationElement();\n    var appBusyModifier = \"application--busy\";\n\n    if (evt.state === \"busy\") {\n      bem.modifier(appBusyModifier)({element: applicationElement});\n    }\n    else if (evt.state === \"ready\") {\n      bem.remove(appBusyModifier)({element: applicationElement});\n    }\n  });\n\n  require(\"./application-options\")(app);\n  //require(\"./application-oms\")(app);\n  require(\"./application-retail\")(app);\n  require(\"./application-oms-extension\")(app);\n\n  configureValidation(app.finishing);\n  configureFormatted(app.finishing);\n  configureVisibility(app.finishing);\n  configureLabeling(app.finishing);\n  configureFocus(app.finishing);\n  configureContainerInput(app.finishing);\n  uxConfig.configureApplicationBlock(app.finishing);\n\n  window.jsua = app;\n\n  return app;\n};\n\n},{\"./application-oms-extension\":143,\"./application-options\":144,\"./application-retail\":145,\"./extensions/attach-view\":147,\"./extensions/dev-states\":148,\"./extensions/http-bestbuy-com-retail/content-set\":149,\"./extensions/http-uncategorized-marker\":152,\"./polyfills\":154,\"./ux-configuration\":155,\"./ux-patterns\":158,\"jsua\":75,\"jsua-bem\":1,\"jsua-common\":9,\"jsua-data-transferring\":24,\"jsua-generic-rendering\":25,\"jsua-html-rendering\":26,\"jsua-http-transferring\":27,\"jsua-image-rendering\":28,\"jsua-lynx\":38,\"jsua-markdown-rendering\":68,\"jsua-text-rendering\":69,\"jsua-url-encoding\":70,\"q\":134}],147:[function(require,module,exports){\nmodule.exports = exports = function (app) {\n\n  function attachView(result) {\n    if (result.element.parentElement) return result;\n\n    var applicationElement = app.getApplicationElement();\n\n    while (applicationElement.firstChild) {\n      applicationElement.removeChild(applicationElement.firstChild);\n    }\n\n    applicationElement.appendChild(result.element);\n\n    return result;\n  }\n\n  var extension = {\n    finishing: attachView\n  };\n\n  return extension;\n};\n\n},{}],148:[function(require,module,exports){\nmodule.exports = exports = function (app) {\n  var url = require(\"url\");\n\n  function recordHistory(result) {\n    // ignore history for transitions originating from dev states\n    if (result.options.origin &&\n      (result.options.origin.dataset.devStates ||\n      result.options.origin.dataset.devStatesTargetId)) return result;\n\n    var element = result.element;\n\n    if (element.dataset.contentScope) return result;\n\n    if (element.dataset.contentLocation !== document.location.href) {\n      //TODO: This will fail for external links.\n      history.pushState(null, null, element.dataset.contentLocation);\n    }\n\n    return result;\n  }\n\n  function appendStatesForEachContentElement(result) {\n    if (result.options.origin && result.options.origin.dataset.devStates) return result;\n\n    var applicationElement = app.getApplicationElement();\n\n    var elementToRemove = applicationElement.querySelector(\"[data-dev-states]\");\n    if (elementToRemove) {\n      elementToRemove.parentElement.removeChild(elementToRemove);\n    }\n\n    var selector = \"[data-content-location]\";\n    var contentElements = applicationElement.querySelectorAll(selector);\n\n    contentElements = Array.prototype.slice.call(contentElements);\n    // if (result.element.matches(selector)) contentElements.push(result.element);\n\n    function appendStates(contentElement) {\n      if (contentElement.dataset.contentType !== \"application/lynx+json\") return result;\n       \n      var contentLocation = contentElement.dataset.contentLocation;\n      var statesLocation = url.resolve(contentLocation, \"./states.lnx\");\n\n      var correlationId = \"N\" + Math.random().toString(36).slice(2);\n      contentElement.dataset.devStatesId = correlationId;\n\n      var options = {};\n      options.origin = statesContainerElement;\n      options.type = \"application/lynx+json\";\n\n      app.follow(statesLocation, options).then(function (result) {\n        var linkElements = result.element.querySelectorAll(\"a,[role*=link]\");\n\n        Array.prototype.forEach.call(linkElements, function (linkElement) {\n          linkElement.dataset.devStatesTargetId = correlationId;\n        });\n      });\n    }\n\n    var statesContainerElement = document.createElement(\"div\");\n    statesContainerElement.dataset.devStates = \"true\";\n    contentElements.forEach(appendStates);\n    applicationElement.appendChild(statesContainerElement);\n\n    return result;\n  }\n\n  function attachStatesDocument(result) {\n    if (result.element.parentElement) return result;\n    if (!result.options.origin || !result.options.origin.dataset.devStates) return result;\n\n    result.options.origin.appendChild(result.element);\n\n    return result;\n  }\n\n  function attachStatesTransitionResult(result) {\n    if (result.element.parentElement) return result;\n    if (!result.options.origin || !result.options.origin.dataset.devStatesTargetId) return result;\n\n\n    var applicationElement = app.getApplicationElement();\n    var targetId = result.options.origin.dataset.devStatesTargetId;\n    var selector = \"[data-dev-states-id=\" + targetId + \"]\";\n    var targetElement = applicationElement.querySelector(selector);\n    if (!targetElement) return result;\n\n    app.extensions.common.replaceElementAndPreserveAttributes(targetElement, result.element);\n    return result;\n  }\n\n  var extension = {\n    finishing: {\n      recordHistory: recordHistory,\n      appendStatesForEachContentElement: appendStatesForEachContentElement,\n      attachStatesDocument: attachStatesDocument,\n      attachStatesTransitionResult: attachStatesTransitionResult\n    }\n  };\n\n  return extension;\n};\n\n},{\"url\":111}],149:[function(require,module,exports){\nvar contentType = require(\"content-type\");\n\nmodule.exports = exports = function (app) {\n  var printEscPos = require(\"./print-esc-pos\")(app);\n  var printPdf = require(\"./print-pdf\")(app);\n\n  var extension = {\n    lynx: {\n      rendering: renderContentSet\n    }\n  };\n\n  var printers = {\n    \"application/vnd.bestbuy.esc-pos\": printEscPos,\n    \"application/pdf\": printPdf\n  };\n\n  function renderContentSet(node) {\n    var promiseForElement;\n\n    node.children.forEach(function (childNode) {\n      var content = childNode.value;\n      var type = contentType.parse(content.type).type;\n      var printer = printers[type];\n\n      if (!printer) {\n        printer = app.rendering;\n      }\n\n      if (!promiseForElement) {\n        promiseForElement = printer(content);\n      }\n      else {\n        promiseForElement = promiseForElement.fail(function (err) {\n          app.error(err);\n          return printer(content);\n        });\n      }\n    });\n\n    return promiseForElement.then(function (result) {\n      return result.element;\n    });\n  }\n\n  return extension;\n};\n\n},{\"./print-esc-pos\":150,\"./print-pdf\":151,\"content-type\":126}],150:[function(require,module,exports){\nvar Q = require(\"q\");\nvar contentType = require(\"content-type\");\nvar linesToAdvanceAfterCuttingPaper = 5;\n\nmodule.exports = exports = function (app) {\n  function ensureContentHasData(content) {\n    if (content.data) return Q(content);\n\n    return app.transferring(content.src).then(function (content) {\n      var type = contentType.parse(content.type).type;\n      if (type !== \"application/vnd.bestbuy.esc-pos\") throw new Error(\"Invalid content\");\n      return content;\n    }).then(function (transferred) {\n      transferred.alt = content.alt;\n      return transferred;\n    });\n  }\n\n  function createThermalPrinterControl() {\n    // var thermalPrinterControlMock = {\n    //   Open: function () {\n    //     return {\n    //       OPOSResultCode: 0\n    //     };\n    //   },\n    //   PrintToReceipt: function (data) {\n    //     console.log(data);\n    //     return {\n    //       OPOSResultCode: 0\n    //     };\n    //   },\n    //   CutPaper: function (lines) {\n    //     console.log(\"cut\", lines);\n    //     return {\n    //       OPOSResultCode: 0\n    //     };\n    //   },\n    //   Close: function () {}\n    // };\n    //\n    // return thermalPrinterControlMock;\n\n    var thermalPrinterControl = new ActiveXObject(\"E3Retail.DMS.Fireball.ComPrinter\");\n    return thermalPrinterControl;\n  }\n\n  function printContent(content) {\n    console.log(\"Started printing ESC-POS content\", new Date());\n\n    var thermalPrinterControl = createThermalPrinterControl();\n    if (!thermalPrinterControl) throw new Error(\"Unable to Create OPOS Printer Control\");\n\n    try {\n      var result = thermalPrinterControl.Open();\n      if (!result || result.OPOSResultCode !== 0) throw new Error(\"Unable to Open OPOS Printer\");\n      var print = content.data.toString();\n      var newlineRegex = /\\\\n/ig;\n      var posESCRegex = /\\\\x1B/ig;\n      print = print.replace(newlineRegex, \"\\n\").replace(posESCRegex, \"\\x1B\");\n      result = thermalPrinterControl.PrintToReceipt(print);\n      if (!result || result.OPOSResultCode !== 0) throw new Error(\"Unable to Print to OPOS Printer\");\n\n      thermalPrinterControl.CutPaper(linesToAdvanceAfterCuttingPaper);\n    }\n    finally {\n      if (thermalPrinterControl) thermalPrinterControl.Close();\n      console.log(\"Finished printing ESC-POS content\", new Date());\n    }\n  }\n\n  function renderElement(content) {\n    var rootElement = document.createElement(\"div\");\n    rootElement.dataset.lynxControl = true;\n    rootElement.textContent = \"Reprint \" + content.alt;\n\n    rootElement.addEventListener(\"click\", function (evt) {\n      printContent(content);\n    });\n\n    printContent(content);\n\n    return {\n      content: content,\n      element: rootElement\n    };\n  }\n\n  function printEscPos(content) {\n    return ensureContentHasData(content).then(renderElement);\n  }\n\n  return printEscPos;\n};\n\n},{\"content-type\":126,\"q\":134}],151:[function(require,module,exports){\nvar Q = require(\"q\");\n\nmodule.exports = exports = function (app) {\n  function objectTagHasReadyState() {\n    var objectElement = document.createElement(\"object\");\n    return (\"readyState\" in objectElement);\n  }\n\n  function renderContentElementUsingObjectTag(content) {\n    var contentElement = document.createElement(\"object\");\n\n    contentElement.data = content.src;\n    contentElement.type = \"application/pdf\";\n\n    var altText = content.alt || \"Unable to display content from: \" + content.src;\n    var altElement = document.createElement(\"a\");\n    altElement.setAttribute(\"download\", \"content\");\n    altElement.href = content.src;\n    altElement.textContent = altText;\n    contentElement.appendChild(altElement);\n\n    contentElement.addEventListener(\"printContent\", function () {\n      contentElement.PrintWithDialog();\n    });\n\n    contentElement.addEventListener(\"readystatechange\", function () {\n      if (contentElement.readyState !== 4) return;\n      sendPrintContentMessage(contentElement);\n    });\n\n    return contentElement;\n  }\n\n  function renderContentElementUsingFrameTag(content) {\n    function printFrameContentWhenReady() {\n      if (contentElement.contentDocument === null) {\n        window.setTimeout(printFrameContentWhenReady, 100);\n      }\n      else {\n        if (contentElement.contentDocument.readyState !== \"complete\") {\n          contentElement.contentDocument.addEventListener(\"readystatechange\", function () {\n            if (contentElement.contentDocument.readyState !== \"complete\") return;\n            sendPrintContentMessage(contentElement);\n          });\n        }\n        else {\n          sendPrintContentMessage(contentElement);\n        }\n      }\n    }\n\n    var contentElement = document.createElement(\"iframe\");\n    contentElement.src = content.src;\n\n    contentElement.addEventListener(\"printContent\", function () {\n      contentElement.contentWindow.print();\n    });\n\n    window.setTimeout(printFrameContentWhenReady, 100);\n\n    return contentElement;\n  }\n\n  function renderContentElement(content) {\n    var contentElement;\n\n    if (objectTagHasReadyState()) {\n      // Internet Explorer goes down this path\n      contentElement = renderContentElementUsingObjectTag(content);\n    }\n    else {\n      // Chrome goes down this path\n      contentElement = renderContentElementUsingFrameTag(content);\n    }\n\n    contentElement.style.position = \"fixed\";\n    contentElement.style.top = \"-1px\";\n    contentElement.style.left = \"-1\";\n    contentElement.style.height = \"1px\";\n    contentElement.style.width = \"1px\";\n\n    return contentElement;\n  }\n\n  function sendPrintContentMessage(element) {\n    var evt = document.createEvent(\"Event\");\n    evt.initEvent(\"printContent\", true, true);\n    element.dispatchEvent(evt);\n  }\n\n  function renderElement(content) {\n    var rootElement = document.createElement(\"div\");\n    rootElement.dataset.lynxControl = true;\n    rootElement.textContent = \"Reprint \" + content.alt;\n\n    var contentElement = renderContentElement(content);\n\n    rootElement.addEventListener(\"click\", function (evt) {\n      sendPrintContentMessage(contentElement);\n    });\n\n    rootElement.appendChild(contentElement);\n\n    return {\n      content: content,\n      element: rootElement\n    };\n  }\n\n  function printPdf(content) {\n    return Q(content).then(renderElement);\n  }\n\n  return printPdf;\n};\n\n},{\"q\":134}],152:[function(require,module,exports){\nmodule.exports = exports = function (app) {\n  var extension = {};\n\n  extension.lynx = {};\n  extension.lynx.afterNodeRendering = {};\n  extension.lynx.afterNodeRendering.setMarkerFor = setMarkerFor;\n\n  function setMarkerFor(result) {\n    if (!result.node.hasHint(\"http://uncategorized/marker\")) return result;\n    result.element.dataset.lynxMarkerFor = result.node.value.for;\n    return result;\n  }\n\n  return extension;\n};\n\n},{}],153:[function(require,module,exports){\nvar url = require(\"url\");\nvar app = require(\"../application\")();\n\nfunction recordHistory(result) {\n  var element = result.element;\n\n  if (element.dataset.contentScope) return result;\n  if (element.dataset.contentLocation === getContentLocation(document.location.href)) return result;\n  if (element.querySelector(\"a[data-follow]\")) return result;\n\n  var contentLocation = element.dataset.contentLocation;\n  var htmlPageUrl = getHtmlPageUrl(contentLocation);\n\n  history.pushState(null, null, htmlPageUrl);\n  return result;\n}\n\napp.finishing.add(recordHistory);\n\nwindow.addEventListener(\"popstate\", function () {\n  var contentLocation = getContentLocation(document.location.href);\n  app.follow(contentLocation);\n});\n\nfunction getContentLocation(htmlPageUrl) {\n  var current = url.parse(htmlPageUrl);\n  if (!current || !current.query || current.query.indexOf(\"url=\") !== 0) return null;\n  var contentLocation = current.query.substr(4);\n  contentLocation = url.resolve(start, contentLocation);\n  return contentLocation;\n}\n\nfunction getHtmlPageUrl(contentLocation) {\n  var htmlPageUrl = url.parse(document.location.href);\n  contentLocation = url.parse(contentLocation);\n  htmlPageUrl.search = \"?url=\" + contentLocation.path;\n  return url.format(htmlPageUrl);\n}\n\n// var contentLocation = getContentLocation(document.location.href) || \"http://localhost:3000/\";\nvar start = url.resolve(document.location.href, \"/\");\napp.follow(start);\n\n// app.transferring(start).then(function (result) {\n//   start = result.data.toString();\n//   app.follow(start);\n// });\n\n},{\"../application\":146,\"url\":111}],154:[function(require,module,exports){\nif (!Array.prototype.find) {\n  Array.prototype.find = function (predicate) {\n    if (this === null) {\n      throw new TypeError('Array.prototype.find called on null or undefined');\n    }\n    if (typeof predicate !== 'function') {\n      throw new TypeError('predicate must be a function');\n    }\n    var list = Object(this);\n    var length = list.length >>> 0;\n    var thisArg = arguments[1];\n    var value;\n\n    for (var i = 0; i < length; i++) {\n      value = list[i];\n      if (predicate.call(thisArg, value, i, list)) {\n        return value;\n      }\n    }\n    return undefined;\n  };\n}\n\n},{}],155:[function(require,module,exports){\nmodule.exports = exports = function (app) {\n  var bem = app.extensions.bem;\n  var common = app.extensions.common;\n  var select = common.select;\n  var apply = common.finishing.apply;\n  var whenReady = common.finishing.whenReady;\n  var composite = common.finishing.composite;\n  var ux = app.extensions.ux = require(\"./ux-patterns\")(app);\n\n  var extension = {};\n\n  extension.configureApplicationBlock = function configureApplicationBlock(finishing) {\n    finishing.add(apply(select.applicationElement, composite(bem.block(\"application\"), (bem.element(\"application__root\")))));\n    finishing.add(apply(\".application > :first-child\", bem.element(\"application__content\")));\n    // TODO: Reevaluate after dev-states refactoring.\n    finishing.add(apply(select.fromApp(\".application > .dev-states\"), bem.element(\"application__dev-states\")));\n  };\n\n  extension.configureMainSection = function configureMainSection(finishing){\n    extension.configureSectionBlock(finishing, ux.selectors.mainSection, \"section--main\");\n    finishing.add(apply(\".section--main\", function (result) {\n      if (select(\"[data-lynx-hints~='http://bestbuy.com/retail/ux-patterns/listing']\")(result.element).some()) {\n        bem.remove(\"section--main\")(result);\n        bem.modifier(\"section--full-page\")(result);\n      }\n      \n      return result;\n    }));\n  };\n  \n  // extension.configurePage = function configurePage(finishing) {\n  //   // page block\n  //   finishing.add(apply(ux.selectors.pageElement, bem.block(\"page\")));\n  //   finishing.add(apply(\".page > [data-lynx-hints~=header]\", bem.element(\"page__header\")));\n  //\n  //   //page body layouts\n  //   finishing.add(apply(select.wrap(\".page > *:not(.page__header)\"), composite(bem.block(\"page-body\"), bem.element(\"page__body\"))));\n  //   finishing.add(apply(\".page__body > *\", bem.element(\"page__body-content\")));\n  //\n  //   finishing.add(apply(\".page-body\", function (result) {\n  //     var select = app.extensions.common.select;\n  //\n  //     if (select(\"[data-lynx-name$=Listing]\")(result.element).some()) {\n  //       return bem.modifier(\"page-body--full-page\")(result);\n  //     }\n  //\n  //     return result;\n  //   }));\n  // };\n\n  // \n  // extension.configurePageFullWidthBlock = function configurePageFullWidthBlock(finishing) {\n  //   // page block\n  //   finishing.add(apply(\".page-full-width > [data-lynx-hints~=header]\", bem.element(\"page-full-width__header\")));\n  // \n  //   //page body layouts\n  //   finishing.add(apply(select.wrap(\".page-full-width > *:not(.page-full-width__header)\"), composite(bem.block(\"page-body\"), bem.modifier(\"page-body--full-page\"), bem.element(\"page-full-width__body\"))));\n  //   finishing.add(apply(\".page-full-width__body > *\", bem.element(\"page-full-width__body-content\")));\n  // };\n  // \n  extension.configureBannerBlock = function configureBannerBlock(finishing) {\n    // banner block\n    finishing.add(apply(\"[data-lynx-name=banner]\", bem.block(\"banner\")));\n\n    // banner - clock element\n    finishing.add(apply(\".banner\", ux.banner.addClock));\n    finishing.add(apply(\".banner > *:nth-child(1)\", bem.element(\"banner__clock\")));\n\n    // banner - brand element\n    finishing.add(apply(\".banner > *:nth-child(2)\", bem.element(\"banner__brand\")));\n\n    // banner - utilities element\n    finishing.add(apply(\".banner > *:nth-child(3)\", composite(bem.element(\"banner__utilities\"), bem.block(\"utilities\"))));\n    finishing.add(apply(\".utilities > *\", bem.block(\"utilities-item\")));\n    finishing.add(apply(\".utilities > *\", bem.element(\"utilities__item\")));\n  };\n\n  extension.configureHeaderBlock = function configureHeaderBlock(finishing) {\n    finishing.add(apply(\"[data-lynx-hints~=header]\", bem.block(\"header\")));\n    finishing.add(apply(\".header[data-lynx-hints~=text]\", bem.element(\"header--text\")));\n    finishing.add(apply(\".header > [data-lynx-hints~=text]\", bem.element(\"header__text\")));\n    finishing.add(apply(\".header > *\", bem.element(\"header__item\")));\n  };\n\n  extension.configureInputBlock = function configureInputBlock(finishing) {\n    finishing.add(apply(\"input, textarea\", bem.block(\"input\")));\n    finishing.add(apply(\"input[type=text]\", bem.modifier(\"input--text\")));\n    finishing.add(apply(\"input[type=password]\", bem.modifier(\"input--password\")));\n    finishing.add(apply(\"textarea\", bem.modifier(\"input--textarea\")));\n  };\n\n  extension.configureButtonBlock = function configureButtonBlock(finishing, selector) {\n    selector = selector || \"[data-lynx-hints~=submit]\";\n    finishing.add(apply(selector, bem.block(\"button\")));\n  };\n\n  extension.configureLinkMixin = function configureLinkBlock(finishing) {\n    finishing.add(apply(\"[data-lynx-hints~=link]\", bem.mixin(\"_link\")));\n  };\n\n  extension.configureInputSectionBlock = function configureInputSectionBlock(finishing) {\n    finishing.add(apply(ux.selectors.inputSections, bem.block(\"input-section\")));\n    finishing.add(apply(\".input-section\", apply(ux.wrapWithInputSection(select.siblings(\"[data-lynx-hints~=link], [data-lynx-hints~=submit]\")), bem.block(\"input-section\"))));\n    finishing.add(apply(\".input-section > [data-lynx-hints~=header]\", bem.element(\"input-section__header\")));\n    finishing.add(apply(\".input-section > .input.-visible, .input-section > .options.-visible, .input-section > .button.-visible\", bem.element(\"input-section__control\")));\n    finishing.add(apply(\".input-section > *\", bem.element(\"input-section__item\")));\n  };\n\n  extension.configureFormSectionBlock = function configureFormSectionBlock(finishing) {\n    finishing.add(apply(ux.selectors.formSection, bem.block(\"form-section\")));\n    finishing.add(apply(\".form-section > [data-lynx-hints~=header]\", bem.element(\"form-section__header\")));\n    finishing.add(apply(\".form-section > .form-section\", bem.element(\"form-section__form-section\")));\n    finishing.add(apply(\".form-section > *\", bem.element(\"form-section__item\")));\n  };\n\n  extension.configureFormBlock = function configureFormBlock(finishing) {\n    finishing.add(apply(\"[data-lynx-hints~=form]\", bem.block(\"form\")));\n    finishing.add(apply(\".form > .input-section > .button\", bem.element(\"form__button\")));\n    finishing.add(apply(\".form > *\", bem.element(\"form__item\")));\n  };\n\n  extension.configureListingBlock = function configureListingBlock(finishing) {\n    finishing.add(apply(\"[data-lynx-name$=Listing]\", bem.block(\"listing\")));\n    finishing.add(apply(select.parent(\".listing\"), function (result) {\n      bem.modifier(\"section--listing\")(result);\n      return result;\n    }));\n    finishing.add(apply(\".listing > *\", composite(bem.block(\"listing-item\"), bem.element(\"listing__item\"))));\n    finishing.add(apply(\"[data-lynx-hints~='http://uncategorized/child']\", bem.modifier(\"listing-item--child\")));\n    finishing.add(apply(\".listing-item > img\", composite(bem.remove(\"listing-item__item\"), bem.element(\"listing-item__image\"))));\n    finishing.add(apply(select.wrapEachMatching(\".listing-item__image\"), composite(bem.element(\"listing-item__item\"), bem.element(\"listing-item__image-wrapper\"), bem.modifier(\"listing-item__item--no-separator\"))));\n    finishing.add(apply(\".listing-item > *\", bem.element(\"listing-item__item\")));\n    finishing.add(apply(\".listing-item > [data-lynx-hints~=header]\", bem.element(\"listing-item__header\")));\n    \n    var compoundSectionFinishing = composite(bem.block(\"listing-item\"), bem.element(\"listing-item__listing-item\"), bem.modifier(\"listing-item__item--no-separator\"));\n    finishing.add(apply(ux.selectors.compoundSections(\".listing-item__item\"), compoundSectionFinishing));\n  };\n\n  extension.configureSectionBlock = function configureSectionBlock(finishing, selector, modifier) {\n    var blockFn = app.finishing.composite(bem.hasNoBlock());\n    blockFn.add(bem.block(\"section\"));\n\n    if (modifier) {\n      blockFn.add(bem.modifier(modifier));\n    }\n\n    // TODO: Removing the page-body wrapper until we need it.\n    // blockFn.add(apply(select.wrap(\"* > :not([data-lynx-hints~=header]):not([data-lynx-hints~=complement])\"), composite(bem.block(\"section-body\"), bem.element(\"section__body\"))));\n\n    finishing.add(apply(selector, blockFn));\n    finishing.add(apply(\".section > [data-lynx-hints~=header]\", bem.element(\"section__header\")));\n    finishing.add(apply(\".section > [data-lynx-hints~=submit], .section > .input-section > [data-lynx-hints~=submit]\", bem.element(\"section__button\")));\n    finishing.add(apply(\".section > [data-lynx-hints~=complement]\", bem.element(\"section__complement\")));\n    finishing.add(apply(\".section > [data-lynx-hints~=section]\", bem.element(\"section__section\")));\n    finishing.add(apply(\".section > *\", bem.element(\"section__item\")));\n  };\n  \n  extension.configureFixedLayout = function configureFixedLayout(finishing) {\n    finishing.add(apply(ux.selectors.pageElement, bem.mixin(\"_fixed\")));\n    finishing.add(apply(\"._fixed > [data-lynx-hints~=header]\", bem.element(\"_fixed__top\")));\n    finishing.add(apply(\"._fixed [data-lynx-hints~='http://bestbuy.com/retail/ux-patterns/fixed/sticky']\", bem.element(\"_fixed__sticky\")));\n    finishing.add(apply(\"._fixed [data-lynx-hints~='http://bestbuy.com/retail/ux-patterns/fixed/top']\", bem.element(\"_fixed__top\")));\n    finishing.add(apply(\"._fixed [data-lynx-hints~='http://bestbuy.com/retail/ux-patterns/fixed/left']\", bem.element(\"_fixed__left\")));\n    finishing.add(apply(\"._fixed [data-lynx-hints~='http://bestbuy.com/retail/ux-patterns/fixed/right']\", bem.element(\"_fixed__right\")));\n    finishing.add(apply(\"._fixed [data-lynx-hints~='http://bestbuy.com/retail/ux-patterns/fixed/bottom']\", bem.element(\"_fixed__bottom\")));\n    \n    ux.fixedLayout();\n  };\n\n  extension.configureComplementBlock = function configureComplementBlock(finishing) {\n    // TODO: this is temporary - we need to combine the complement and listing-item blocks into same concept\n    finishing.add(apply(\"[data-lynx-hints~=complement]\", bem.block(\"listing-item\")));\n    finishing.add(apply(\".listing-item[data-lynx-hints~=complement] > img\", composite(bem.remove(\"listing-item__item\"), bem.element(\"listing-item__image\"))));\n    finishing.add(apply(select.wrapEachMatching(\".listing-item[data-lynx-hints~=complement] > .listing-item__image\"), composite(bem.element(\"listing-item__item\"), bem.element(\"listing-item__image-wrapper\"), bem.modifier(\"listing-item__item--no-separator\"))));\n    finishing.add(apply(\".listing-item[data-lynx-hints~=complement] > *\", bem.element(\"listing-item__item\")));\n    finishing.add(apply(\".listing-item[data-lynx-hints~=complement] > [data-lynx-hints~=header]\", composite(bem.element(\"listing-item__header\"), bem.modifier(\"listing-item__header--wide\"))));\n  };\n\n  extension.configurePhrasingContainerBlock = function configurePhrasingContainerBlock(finishing, selector) {\n    finishing.add(apply(selector, bem.block(\"phrasing-container\")));\n    finishing.add(apply(\".phrasing-container > *\", bem.element(\"phrasing-container__item\")));\n    finishing.add(apply(\".phrasing-container > [data-lynx-hints~=header]\", bem.element(\"phrasing-container__header\")));\n  };\n\n  extension.configureControlsSectionBlock = function configureControlsSectionBlock(finishing, selector) {\n    selector = selector || ux.selectors.controlsSection;\n    finishing.add(apply(selector, bem.block(\"form-controls-section\")));\n    finishing.add(apply(\".form-controls-section > *\", bem.element(\"form-controls-section__control\")));\n\n    extension.configureButtonBlock(finishing, \".form-controls-section > [data-lynx-hints~=submit], .form-controls-section > [data-lynx-hints~=link]\");\n    finishing.add(apply(select.first(\".form-controls-section > [data-lynx-hints~=submit]\"), bem.modifier(\"form-controls-section__control--primary\")));\n    finishing.add(apply(\".form-controls-section > :last-child\", bem.modifier(\"form-controls-section__control--negative\")));\n  };\n\n  extension.configureTextBlock = function configureTextBlock(finishing) {\n    finishing.add(apply(\"pre\", composite(bem.mixin(\"_text\"), bem.element(\"_text__content\"))));\n  };\n\n  extension.configureLinkBlock = function configureLinkBlock(finishing) {\n    finishing.add(apply(\"[data-lynx-hints~=link]\", bem.block(\"link\")));\n    finishing.add(apply(\".link > *\", bem.element(\"link__item\")));\n  };\n  \n  extension.configureYouAreHere = function configureYouAreHere(finishing) {\n    finishing.add(apply(\"[data-lynx-marker-for]\", function (result) {\n      var element = result.element;\n      var forScope = element.dataset.lynxMarkerFor;\n      \n      var elementInMarkerScope = app.extensions.common.findNearestAncestor(element, function (current) {\n        return app.extensions.common.scopeIncludesRealm(forScope, current.dataset.contentRealm);\n      });\n      \n      if (elementInMarkerScope) {\n        return bem.state(\"-you-are-here\")(result);\n      }\n      \n      return result;\n    }));\n  };\n  \n  extension.configureMarkersAsOptions = function configureMarkersAsOptions(finishing) {\n    finishing.add(apply(ux.selectors.markersAsOptions, composite(\n      bem.mixin(\"_options\"), \n      bem.block(\"listbox\"),\n      apply(select.wrapEachMatching(\".listbox > *\"), composite(\n        bem.element(\"listbox__item-wrapper\"),\n        apply(select.children(\"[data-lynx-marker-for]\"), composite(bem.mixin(\"_option\"), bem.block(\"listbox-item\"))))),\n      apply(\".-you-are-here\", bem.modifier(\"_option--selected\")))));\n  };\n  \n  extension.configureAttributeList = function configureAttributeList(finishing) {\n    finishing.add(apply(\"[data-lynx-hints~='http://bestbuy.com/retail/ux-patterns/attribute-list']\", bem.block(\"attribute-list\")));\n    finishing.add(apply(\".attribute-list > *\", composite(bem.block(\"attribute\"), bem.element(\"attribute-list__item\"))));\n    finishing.add(apply(\".attribute > [data-lynx-hints~=label]\", bem.element(\"attribute__label\")));\n  };\n\n  return extension;\n};\n\n},{\"./ux-patterns\":158}],156:[function(require,module,exports){\nmodule.exports = exports = function (app) {\n  var bem = app.extensions.bem;\n  var select = app.extensions.common.select;\n  \n  function applyFixedLayout(result) {\n    var element = result.element;\n    var top = 0, bottom = 0, left = 0, right = 0;\n    function fixTop() { \n      select(\"._fixed__top\")(element).forEach(function (el) {\n        el.style.top = top + \"px\";\n        top += el.offsetHeight;\n      });\n    }\n    \n    function fixBottom() {\n      var elements = select(\"._fixed__bottom\")(element).array();\n      var elementsReversed = [];\n\n      elements.forEach(function (el) {\n        elementsReversed.unshift(el);\n      });\n      \n      elementsReversed.forEach(function (el) {\n        el.style.bottom = bottom + \"px\";\n        bottom += el.offsetHeight;\n      });\n    }\n    \n    function fixLeft() { \n      select(\"._fixed__left\")(element).forEach(function (el) {\n        el.style.top = top + \"px\";\n        el.style.bottom = bottom + \"px\";\n        el.style.left = left + \"px\";\n        left += el.offsetWidth;\n      });\n    }\n    \n    function fixRight() {\n      var elements = select(\"._fixed__right\")(element).array();\n      var elementsReversed = [];\n\n      // There's gotta be a better way.\n      elements.forEach(function (el) {\n        elementsReversed.unshift(el);\n      });\n      \n      elementsReversed.forEach(function (el) {\n        el.style.top = top + \"px\";\n        el.style.bottom = bottom + \"px\";\n        el.style.right = right + \"px\";\n        right += el.offsetWidth;\n      });\n    }\n    \n    function fixSticky() {\n      var stickiesAboveTop = select(\"._fixed__sticky\")(element).filter(function (el) {\n        return el.getBoundingClientRect().top < top;\n      });\n      \n      var currentSticky = select(\"._fixed__stuck\")(element).first();\n      \n      if (!stickiesAboveTop.some()) {\n        if (currentSticky) {\n          element.removeChild(currentSticky);\n        }\n        return;\n      }\n      \n      if (stickiesAboveTop.some()) {\n        var stickyToStick = stickiesAboveTop.last();\n\n        var clone = stickyToStick.cloneNode(true);\n        \n        bem.element(\"_fixed__stuck\")({ element: clone });\n        clone.style.position = \"fixed\";\n        clone.style.top = top + \"px\";\n        clone.style.left = left + \"px\";\n        clone.style.right = right + \"px\";\n        \n        if (currentSticky) {\n          currentSticky.parentElement.replaceChild(clone, currentSticky);\n        } else {\n          element.appendChild(clone);\n        }\n      }\n    }\n    \n    fixTop();\n    fixBottom();\n    fixLeft();\n    fixRight();\n    fixSticky();\n    \n    element.style.marginTop = top + \"px\";\n    element.style.marginBottom = bottom + \"px\";\n    element.style.marginLeft = left + \"px\";\n    element.style.marginRight = right + \"px\";\n    \n    var verticalMargin = top + bottom;\n    element.style.minHeight = \"calc(100vh - \" + verticalMargin + \"px)\";\n    return result;\n  }\n  \n  function applyOnTimer() {\n    var fixedElement = select(\"._fixed\")(app.getApplicationElement()).first();\n    \n    if (fixedElement) {\n      applyFixedLayout({ element: fixedElement });\n    }\n    \n    setTimeout(applyOnTimer, 20);\n  }\n  \n  return applyOnTimer;\n};\n\n},{}],157:[function(require,module,exports){\nmodule.exports = exports = function (app) {\n  function initializeClock(element) {\n    function getLocalTime() {\n      var time = new Date();\n\n      return time.toLocaleDateString(navigator.language, {month: \"2-digit\", day: \"2-digit\", year: \"numeric\"}) + \" \" +\n        time.toLocaleTimeString(navigator.language, {hour: '2-digit', minute: '2-digit'});\n    }\n\n    function updateLocalTime() {\n      if (!app.extensions.common.elementIsAttached(element)) return;\n\n      element.textContent = getLocalTime();\n      setTimeout(updateLocalTime, 10000);\n    }\n\n    setTimeout(updateLocalTime, 10000);\n\n    element.textContent = getLocalTime();\n  }\n  \n  return {\n    addClock: function (result) {\n      var clockElement = document.createElement(\"div\");\n      result.element.insertBefore(clockElement, result.element.firstChild);\n      initializeClock(clockElement);\n      \n      return result;\n    }\n  }\n};\n\n},{}],158:[function(require,module,exports){\nmodule.exports = exports = function (app) {\n  var bem = app.extensions.bem;\n\n  var validityClasses = {\n    unknown: \"-validity-unknown\",\n    invalid: \"-invalid\",\n    valid: \"-valid\"\n  };\n\n  var visibilityClasses = {\n    hidden: \"-hidden\",\n    concealed: \"-concealed\",\n    visible: \"-visible\"\n  };\n\n  function validityState(result) {\n    var state = validityClasses[result.element.dataset.lynxValidationState];\n    return bem.state(state)(result);\n  }\n\n  function validityChanged(element) {\n    var state;\n\n    for (var key in validityClasses) {\n      state = validityClasses[key];\n      bem.remove(state)({element: element});\n    }\n\n    state = validityClasses[element.dataset.lynxValidationState];\n    bem.state(state)({element: element});\n  }\n\n  function visibilityChanged(element) {\n    var state;\n    for (var key in visibilityClasses) {\n      state = visibilityClasses[key];\n      bem.remove(state)({element: element});\n    }\n\n    var state = visibilityClasses[element.dataset.lynxVisibility];\n    bem.state(state)({element: element});\n  }\n\n  function setVisibility(visibility) {\n    return function (result) {\n      var state;\n      for (var p in visibilityClasses) {\n        state = visibilityClasses[p];\n        bem.remove(state)(result);\n      }\n\n      return bem.state(visibilityClasses[visibility])(result);\n    };\n  }\n\n  function visibilityState(result) {\n    return setVisibility(result.element.dataset.lynxVisibility)(result);\n  }\n\n  function setValidationContentForStates(result) {\n    var state = \"-when\" + validityClasses[result.element.dataset.lynxValidationContentForState];\n    return bem.state(state)(result);\n  }\n\n  function wrapWithInputSection(selector) {\n    return function (element) {\n      var elements = select(selector)(element);\n      if (!elements.some()) return new app.extensions.common.Iterable();\n\n      return elements.map(function (inputElement) {\n        var inputSection = document.createElement(\"div\");\n        inputSection.dataset.lynxHints = \"section\";\n\n        var header = document.createElement(\"div\");\n        header.innerHTML = \"&nbsp;\";\n        header.dataset.lynxHints = \"header\";\n        inputSection.appendChild(header);\n\n        inputElement.parentElement.replaceChild(inputSection, inputElement);\n        inputSection.appendChild(inputElement);\n\n        return inputSection;\n      });\n    };\n  }\n\n  var extension = {};\n  extension.validityState = validityState;\n  extension.validityChanged = validityChanged;\n  extension.visibilityChanged = visibilityChanged;\n  extension.setVisibility = setVisibility;\n  extension.visibilityState = visibilityState;\n  extension.setValidationContentForStates = setValidationContentForStates;\n  extension.wrapWithInputSection = wrapWithInputSection;\n\n  extension.banner = require(\"./banner\")(app);\n\n  var common = app.extensions.common;\n  var select = common.select;\n  var Iterable = app.extensions.common.Iterable;\n  extension.selectors = {\n    pageElement: function selectPageElement(element) {\n      if (element.parentElement === app.getApplicationElement()) return new Iterable([element]);\n      return new app.extensions.common.Iterable();\n    },\n    mainSection: function selectMainSection(element) {\n      if (element.parentElement !== app.getApplicationElement()) return new Iterable();\n\n      var page = app.getApplicationElement().firstElementChild;\n      if (!app.extensions.common.matchesSelector(page, \"[data-lynx-hints~=section\")) return new Iterable();\n\n      var sections = select.children(\"[data-lynx-hints~=section\")(page);\n\n      return sections.count() === 1 ? sections : new Iterable();\n    },\n    inputSections: function getInputSections(element) {\n      return select(\"[data-lynx-hints~=section]\")(element).filter(function (section) {\n        var inputChildren = Array.prototype.filter.call(section.children, function (child) {\n          return app.extensions.common.matchesSelector(child, \".input:not(.-hidden), ._options\");\n        });\n        return inputChildren.length === 1;\n      });\n    },\n    formSection: function selectFormSection(element) {\n      var formSectionSelector = \"[data-lynx-hints~=form] [data-lynx-hints~=section]\";\n      return select(formSectionSelector)(element).filter(function (el) {\n        return Array.prototype.some.call(el.children, function (child) {\n          return app.extensions.common.matchesSelector(child, \".input-section\");\n        });\n      });\n    },\n    controlsSection: function selectControlsSection(element) {\n      var formSectionSelector = \"[data-lynx-hints~=form] > [data-lynx-hints~=section]\";\n      return select(formSectionSelector)(element).filter(function (el) {\n        return Array.prototype.every.call(el.children, function (child) {\n          return app.extensions.common.matchesSelector(child, \"[data-lynx-visibility=hidden], [data-lynx-hints~=submit], [data-lynx-hints~=link]\");\n        });\n      });\n    },\n    markersAsOptions: function selectMarkersAsOptions(element) {\n      var markerSelector = \"[data-lynx-hints~=form] [data-lynx-hints~='http://uncategorized/marker']\";\n      return select.parent(markerSelector)(element).filter(function (p) {\n        var allSiblingsAreMarkers = Array.prototype.every.call(p.children, function (c) {\n          return app.extensions.common.matchesSelector(c, \"[data-lynx-hints~='http://uncategorized/marker']\");\n        });\n        \n        var someMarkersAreLinks = Array.prototype.some.call(p.children, function (c) {\n          return app.extensions.common.matchesSelector(c, \"[data-lynx-hints~='link']\");\n        });\n        \n        return allSiblingsAreMarkers && someMarkersAreLinks;\n      });\n    },\n    compoundSections: function selectCompoundSections(selector) {\n      function isVisibleOrConcealed(el) {\n        return app.extensions.common.matchesSelector(el, \"[data-lynx-visibility=visible],[data-lynx-visibility=concealed]\");\n      }\n      \n      function isNotContent(el) {\n        return !app.extensions.common.matchesSelector(el, \"[data-lynx-hints~=text],[data-lynx-hints~=content]\");\n      }\n      \n      function isCompoundSection(possibleCompoundSection) {\n        if(possibleCompoundSection.children.length === 0) return false;\n        var children = Array.prototype.slice.call(possibleCompoundSection.children);\n        return children.filter(isVisibleOrConcealed).every(isNotContent);\n      }\n      \n      return function (element) {\n        var possibleCompoundSections = select(selector)(element);\n        return possibleCompoundSections.filter(isCompoundSection);\n      };\n    }\n  };\n  \n  extension.fixedLayout = require(\"./_fixed\")(app);\n\n  return extension;\n};\n\n},{\"./_fixed\":156,\"./banner\":157}]},{},[153]);\n"],"file":"out/html-page/application.js","sourceRoot":"/source/"}